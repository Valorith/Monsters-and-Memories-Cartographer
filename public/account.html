<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Account Settings - MMC</title>
  
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-FS1GD2527L"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-FS1GD2527L');
  </script>
  
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@600&display=swap');
    
    /* Animation for data inspector */
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.5; }
      100% { opacity: 1; }
    }
    
    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(-10px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }
    
    /* Tree view styles */
    .inspector-tree-node {
      margin: 2px 0;
      animation: slideIn 0.3s ease;
    }
    
    .inspector-tree-expand {
      cursor: pointer;
      user-select: none;
      display: inline-block;
      width: 16px;
      text-align: center;
      color: #60a5fa;
      transition: transform 0.2s ease;
    }
    
    .inspector-tree-expand.expanded {
      transform: rotate(90deg);
    }
    
    .inspector-tree-icon {
      display: inline-block;
      margin: 0 4px;
    }
    
    .inspector-tree-label {
      color: #e0e0e0;
      transition: color 0.2s ease;
    }
    
    .inspector-tree-label:hover {
      color: #60a5fa;
    }
    
    .inspector-tree-node.selected {
      background: rgba(96, 165, 250, 0.1);
      border-left: 3px solid #60a5fa;
      padding-left: 5px;
      margin-left: -8px;
    }
    
    .inspector-tree-status {
      display: inline-block;
      margin-left: 8px;
      padding: 1px 4px;
      border-radius: 3px;
      font-size: 0.65rem;
      font-weight: normal;
    }
    
    .inspector-tree-status.loading {
      background: transparent;
      color: #6b7280;
      animation: pulse 1s infinite;
    }
    
    .inspector-tree-status.success {
      background: #064e3b;
      color: #10b981;
    }
    
    .inspector-tree-status.error {
      background: #7f1d1d;
      color: #ef4444;
    }
    
    .inspector-tree-status.pending {
      background: #374151;
      color: #9ca3af;
    }
    
    .inspector-tree-node.excluded {
      opacity: 0.5;
    }
    
    .inspector-tree-node.excluded .inspector-tree-label {
      text-decoration: line-through;
      color: #6b7280;
    }
    
    .inspector-tree-status.list-loading {
      background: transparent;
      color: #8b5cf6;
      animation: listLoadPulse 1.5s ease-in-out infinite;
    }
    
    .inspector-tree-status.extracted {
      background: #064e3b;
      color: #10b981;
    }
    
    /* Disabled button styling */
    .primary-btn:disabled {
      background: #374151 !important;
      border-color: #4b5563 !important;
      color: #9ca3af !important;
      cursor: not-allowed !important;
      opacity: 0.7;
    }
    
    @keyframes listLoadPulse {
      0%, 100% {
        opacity: 0.5;
        transform: scale(0.95);
      }
      50% {
        opacity: 1;
        transform: scale(1.05);
      }
    }
    
    .inspector-tree-count {
      display: inline-block;
      margin-left: 4px;
      color: #6b7280;
      font-size: 0.8rem;
    }
    
    .inspector-tree-children {
      margin-left: 20px;
      border-left: 1px dashed #374151;
      padding-left: 10px;
      margin-top: 4px;
    }
    
    /* Context menu styles */
    .inspector-context-menu {
      position: fixed;
      background: #1f2937;
      border: 1px solid #374151;
      border-radius: 6px;
      padding: 4px 0;
      min-width: 180px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      z-index: 10001;
      display: none;
    }
    
    .inspector-context-menu-item {
      padding: 8px 16px;
      color: #e0e0e0;
      cursor: pointer;
      font-size: 0.9rem;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .inspector-context-menu-item:hover {
      background: #374151;
      color: #60a5fa;
    }
    
    .inspector-context-menu-separator {
      height: 1px;
      background: #374151;
      margin: 4px 0;
    }
    
    .inspector-context-menu-icon {
      width: 16px;
      text-align: center;
    }
    
    .inspector-verified-badge {
      display: inline-block;
      margin-left: 6px;
      padding: 2px 6px;
      background: rgba(16, 185, 129, 0.2);
      color: #10b981;
      border-radius: 3px;
      font-size: 0.7rem;
      font-weight: bold;
    }
    
    /* Race/Class Selector Modal Styles */
    .race-class-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }
    
    .race-class-modal-content {
      background: #2d2d2d;
      border-radius: 12px;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    }
    
    .race-class-modal-header {
      padding: 20px;
      border-bottom: 1px solid #444;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .race-class-modal-header h3 {
      margin: 0;
      color: #FFD700;
      font-size: 1.4rem;
    }
    
    .race-class-modal-close {
      background: none;
      border: none;
      color: #999;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      transition: all 0.2s;
    }
    
    .race-class-modal-close:hover {
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
    }
    
    .race-class-modal-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
    }
    
    .race-class-select-all {
      margin-bottom: 20px;
      padding: 15px;
      background: rgba(255, 215, 0, 0.1);
      border: 1px solid rgba(255, 215, 0, 0.3);
      border-radius: 8px;
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .race-class-select-all:hover {
      background: rgba(255, 215, 0, 0.2);
    }
    
    .race-class-select-all input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }
    
    .race-class-select-all label {
      color: #FFD700;
      font-weight: 500;
      cursor: pointer;
      margin: 0;
    }
    
    .race-class-options {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 10px;
    }
    
    .race-class-option {
      padding: 12px;
      background: #1a1a1a;
      border: 1px solid #444;
      border-radius: 6px;
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .race-class-option:hover {
      background: #222;
      border-color: #666;
    }
    
    .race-class-option.selected {
      background: rgba(74, 124, 89, 0.2);
      border-color: #4a7c59;
    }
    
    .race-class-option input[type="checkbox"] {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }
    
    .race-class-option label {
      cursor: pointer;
      margin: 0;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    
    .race-class-option .code {
      font-size: 0.9rem;
      color: #FFD700;
      font-weight: 500;
    }
    
    .race-class-option .name {
      font-size: 0.8rem;
      color: #999;
    }
    
    .race-class-modal-footer {
      padding: 20px;
      border-top: 1px solid #444;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .race-class-selection-count {
      color: #999;
      font-size: 0.9rem;
    }
    
    .race-class-modal-buttons {
      display: flex;
      gap: 10px;
    }
    
    .race-class-modal-buttons button {
      padding: 8px 20px;
      border-radius: 6px;
      border: none;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .race-class-apply-btn {
      background: #FFD700;
      color: #000;
    }
    
    .race-class-apply-btn:hover {
      background: #FFC700;
      transform: translateY(-1px);
    }
    
    .race-class-cancel-btn {
      background: #555;
      color: #fff;
    }
    
    .race-class-cancel-btn:hover {
      background: #666;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #1a1a1a;
      color: #e0e0e0;
      margin: 0;
      padding: 0;
      min-height: 100vh;
      overflow-x: hidden;
    }
    
    #app {
      display: flex;
      flex-direction: column;
    }
    
    /* Avatar upload progress animation */
    #upload-progress-bar {
      background: linear-gradient(90deg, #4a7c59, #5fa772, #4a7c59);
      background-size: 200% 100%;
      animation: shimmer 1.5s infinite;
    }
    
    @keyframes shimmer {
      0% { background-position: -200% 0; }
      100% { background-position: 200% 0; }
    }
    
    .account-header {
      background: #2d2d2d;
      color: white;
      padding: 1rem 0;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      width: 100%;
    }
    
    .header-content {
      width: 100%;
      margin: 0;
      padding: 0 2rem;
      box-sizing: border-box;
    }
    
    .back-link {
      color: #FFD700;
      text-decoration: none;
      font-size: 0.9rem;
      display: inline-block;
      margin-bottom: 0.5rem;
    }
    
    .back-link:hover {
      color: #FFA500;
    }
    
    .account-header h1 {
      margin: 0;
      font-size: 2rem;
      font-family: 'Cinzel', serif;
      background: linear-gradient(135deg, #FFD700, #FFA500, #FF8C00);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .account-container {
      width: 100%;
      margin: 0;
      padding: 2rem;
      display: flex;
      gap: 2rem;
      box-sizing: border-box;
      align-items: flex-start;
      min-height: 0;
    }
    
    .account-sidebar {
      background: #2d2d2d;
      border-radius: 8px;
      padding: 1rem;
      height: fit-content;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      position: sticky;
      top: 2rem;
      max-height: calc(100vh - 4rem);
      overflow-y: auto;
      width: 250px;
      flex-shrink: 0;
      align-self: flex-start;
    }
    
    .nav-item {
      display: block;
      padding: 0.75rem 1rem;
      color: #ccc;
      text-decoration: none;
      border-radius: 6px;
      margin-bottom: 0.5rem;
      cursor: pointer;
      border: none;
      background: none;
      width: 100%;
      text-align: left;
      font-size: 1rem;
    }
    
    .nav-item:hover {
      background: #3a3a3a;
      color: white;
    }
    
    .nav-item.active {
      background: #4a7c59;
      color: white;
    }
    
    .account-content {
      background: #2d2d2d;
      border-radius: 8px;
      padding: 1.5rem;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      min-width: 0;
      overflow-x: auto;
      width: 100%;
      max-width: 1000px;
      margin-left: auto;
      margin-right: auto;
      margin-top: 0;
      margin-bottom: 0;
    }
    
    .tab-content {
      display: none;
      width: 100%;
    }
    
    .tab-content.active {
      display: block;
    }
    
    /* Message div */
    #message {
      width: 100%;
      margin-bottom: 1rem;
    }
    
    /* Tab headings */
    .tab-content > h2 {
      text-align: center;
      margin-bottom: 2rem;
    }
    
    /* Admin tab specific */
    #admin-tab > * {
      max-width: 100%;
      width: 100%;
    }
    
    /* Dynamic width classes for when editors are active */
    .account-content {
      transition: max-width 0.3s ease;
    }
    
    .account-content.editor-active {
      max-width: calc(100vw - 350px) !important;
      padding: 1rem !important;
    }
    
    .account-content.both-editors-active {
      max-width: calc(100vw - 350px) !important;
      padding: 1rem !important;
    }
    
    /* Profile card */
    .profile-card {
      background: #3a3a3a;
      border-radius: 8px;
      padding: 2rem;
      margin-bottom: 2rem;
    }
    
    /* Settings sections */
    .settings-section,
    .preference-section {
      max-width: 800px;
      width: 100%;
      margin-bottom: 2rem;
    }
    
    .profile-xp-section {
      margin-top: 2rem;
      padding-top: 2rem;
      border-top: 1px solid #555;
    }
    
    .xp-level-display {
      display: flex;
      align-items: center;
      gap: 2rem;
    }
    
    .level-badge-large {
      background: radial-gradient(circle, #FFD700, #FFA500);
      border: 3px solid #8B4513;
      border-radius: 50%;
      width: 80px;
      height: 80px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
    }
    
    .level-badge-large .level-number {
      font-size: 32px;
      font-weight: bold;
      color: #2a1810;
      font-family: 'Cinzel', serif;
    }
    
    .level-badge-large .level-label {
      font-size: 12px;
      color: #2a1810;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-weight: bold;
    }
    
    .xp-info-display {
      flex: 1;
    }
    
    .xp-info-display .xp-text {
      display: flex;
      align-items: baseline;
      gap: 6px;
      color: #FFD700;
      font-family: 'Cinzel', serif;
      margin-bottom: 0.5rem;
    }
    
    .xp-info-display .current-xp {
      font-size: 24px;
      font-weight: bold;
    }
    
    .xp-info-display .separator {
      font-size: 20px;
      color: #FFA500;
    }
    
    .xp-info-display .next-level-xp {
      font-size: 20px;
      color: #FFA500;
    }
    
    .xp-info-display .xp-label {
      font-size: 16px;
      margin-left: 8px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .xp-info-display .xp-bar-wrapper {
      width: 100%;
      height: 24px;
      margin-bottom: 0.5rem;
    }
    
    .xp-info-display .xp-bar-background {
      width: 100%;
      height: 100%;
      background: #1a1a1a;
      border: 2px solid #8B4513;
      border-radius: 12px;
      overflow: hidden;
    }
    
    .xp-info-display .xp-bar-fill {
      height: 100%;
      background: linear-gradient(to right, #FF6B35, #FFD700, #FFA500);
      transition: width 0.3s ease;
    }
    
    .xp-rank {
      color: #999;
      font-size: 0.9rem;
    }
    
    /* Donation Tier Styles */
    .donation-tier-display {
      display: flex;
      align-items: center;
      gap: 2rem;
    }
    
    .tier-badge-large {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100px;
      height: 100px;
      background: #2d2d2d;
      border-radius: 50%;
      border: 3px solid #444;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      padding: 0.5rem;
      text-align: center;
    }
    
    .tier-badge-large .tier-icon {
      font-size: 2.5rem;
      filter: drop-shadow(0 0 8px currentColor);
      animation: badge-glow 2s ease-in-out infinite;
      line-height: 1;
    }
    
    .tier-badge-large .tier-name {
      font-size: 0.75rem;
      font-weight: bold;
      margin-top: 0.25rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      line-height: 1;
      max-width: 80px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    @keyframes badge-glow {
      0%, 100% { opacity: 0.8; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.1); }
    }
    
    .tier-progress-info {
      flex: 1;
    }
    
    .tier-progress-bar-wrapper {
      width: 100%;
      height: 20px;
    }
    
    .tier-progress-bar-background {
      width: 100%;
      height: 100%;
      background: #1a1a1a;
      border: 2px solid #444;
      border-radius: 10px;
      overflow: hidden;
      position: relative;
    }
    
    .tier-progress-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #FFD700, #FFA500);
      transition: width 0.5s ease;
      box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    }
    
    .donate-button:hover {
      background: #5a8c69 !important;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.4) !important;
      box-shadow: 0 4px 12px rgba(233, 75, 71, 0.4);
    }
    
    /* Donation Styles */
    .donation-stats-card {
      background: #3a3a3a;
      border-radius: 8px;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
      border: 1px solid #444;
      transition: all 0.3s ease;
    }
    
    .donation-stats-card:hover {
      background: #424242;
      border-color: #555;
    }
    
    .profile-section {
      padding-top: 2rem;
      border-top: 1px solid #555;
    }
    
    .user-match-option {
      padding: 0.75rem;
      border: 1px solid #444;
      border-radius: 4px;
      margin-bottom: 0.5rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .user-match-option:hover {
      background: #3a3a3a;
    }
    
    .profile-stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
      margin-bottom: 2rem;
    }
    
    .stat-card {
      background: #3a3a3a;
      border-radius: 8px;
      padding: 1.5rem;
      border: 1px solid #444;
      display: flex;
      align-items: center;
      gap: 1rem;
      transition: all 0.3s ease;
    }
    
    .stat-card:hover {
      background: #424242;
      border-color: #555;
      transform: translateY(-2px);
    }
    
    .stat-icon {
      font-size: 2.5rem;
      opacity: 0.8;
    }
    
    .stat-info {
      flex: 1;
    }
    
    .stat-value {
      font-size: 1.8rem;
      font-weight: bold;
      color: #FFD700;
      font-family: 'Cinzel', serif;
    }
    
    .stat-label {
      font-size: 0.9rem;
      color: #999;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    @media (max-width: 768px) {
      .profile-stats-grid {
        grid-template-columns: repeat(2, 1fr);
      }
      
      .xp-level-display {
        flex-direction: column;
        text-align: center;
      }
      
      .donation-stats-card div[style*="grid"] {
        grid-template-columns: repeat(2, 1fr) !important;
      }
    }
    
    .profile-header {
      display: flex;
      align-items: center;
      gap: 1.5rem;
      margin-bottom: 2rem;
    }
    
    .profile-avatar {
      width: 100px;
      height: 100px;
      border-radius: 50%;
      object-fit: cover;
      border: 3px solid #4a7c59;
    }
    
    .admin-badge {
      display: inline-block;
      background: #4CAF50;
      color: white;
      padding: 6px 16px;
      border-radius: 4px;
      font-size: 0.85rem;
      align-self: flex-start;
      white-space: nowrap;
    }
    
    .preference-section {
      margin-bottom: 2rem;
      padding-bottom: 2rem;
      border-bottom: 1px solid #444;
    }
    
    .preference-section:last-child {
      border-bottom: none;
    }
    
    .preference-item {
      margin-bottom: 1rem;
    }
    
    .preference-item label {
      display: block;
      color: #ccc;
      font-size: 0.9rem;
      margin-bottom: 0.5rem;
    }
    
    .preference-item select {
      width: 100%;
      max-width: 300px;
      padding: 0.75rem;
      border: 1px solid #444;
      border-radius: 4px;
      font-size: 1rem;
      background: #3a3a3a;
      color: #e0e0e0;
    }
    
    .btn {
      background: #4a7c59;
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 4px;
      font-size: 1rem;
      cursor: pointer;
      margin-top: 1rem;
    }
    
    .btn:hover {
      background: #3a6249;
    }
    
    .secondary-btn {
      background: #6c757d;
    }
    
    .secondary-btn:hover {
      background: #5a6268;
    }
    
    .danger-btn {
      background: #dc3545;
    }
    
    .danger-btn:hover {
      background: #c82333;
    }
    
    .loading {
      text-align: center;
      padding: 4rem;
      color: #ccc;
    }
    
    .error {
      background: #f8d7da;
      color: #721c24;
      padding: 1rem;
      border-radius: 4px;
      margin-bottom: 1rem;
    }
    
    .success {
      background: #d4edda;
      color: #155724;
      padding: 1rem;
      border-radius: 4px;
      margin-bottom: 1rem;
    }
    
    .admin-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 1rem;
    }
    
    .admin-table th {
      background: #3a3a3a;
      padding: 0.75rem;
      text-align: left;
      font-weight: 600;
      color: #e0e0e0;
      border-bottom: 2px solid #444;
    }
    
    .admin-table td {
      padding: 0.75rem;
      border-bottom: 1px solid #444;
      color: #ccc;
      vertical-align: middle;
    }
    
    .admin-table td img {
      display: block;
      margin: 0 auto;
      object-fit: cover;
    }
    
    .admin-table tr:hover {
      background: #333;
    }
    
    .sub-header {
      font-size: 1.2rem;
      font-weight: 600;
      color: #FFD700;
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 2px solid #444;
    }
    
    .pagination {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      margin-top: 1.5rem;
      padding: 1rem 0;
    }
    
    .pagination-btn {
      background: #4a7c59;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background-color 0.3s;
    }
    
    .pagination-btn:hover:not(:disabled) {
      background: #5a8d69;
    }
    
    .pagination-btn:disabled {
      background: #333;
      color: #666;
      cursor: not-allowed;
    }
    
    .pagination-info {
      color: #ccc;
      font-size: 0.9rem;
    }
    
    .vote-buttons {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      justify-content: center;
    }
    
    .vote-btn {
      background: #444;
      color: white;
      border: none;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1rem;
      transition: all 0.2s;
      min-width: 35px;
    }
    
    .vote-btn:hover {
      background: #555;
    }
    
    .vote-btn.upvote {
      background: #444;
    }
    
    .vote-btn.upvote.active {
      background: #4CAF50;
    }
    
    .vote-btn.downvote {
      background: #444;
    }
    
    .vote-btn.downvote.active {
      background: #f44336;
    }
    
    .vote-score {
      font-weight: bold;
      color: #FFD700;
      min-width: 40px;
      text-align: center;
    }
    
    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      animation: fadeIn 0.3s;
      overflow-y: auto;
      align-items: flex-start;
      justify-content: center;
      padding: 2rem 0;
    }
    
    .modal-content {
      background-color: #2a2a2a;
      margin: auto;
      padding: 0;
      border: 1px solid rgba(255, 215, 0, 0.2);
      border-radius: 12px;
      width: 80%;
      max-width: 600px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
      animation: slideIn 0.3s;
      max-height: 90vh;
      overflow-y: auto;
    }
    
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      border-bottom: 1px solid #444;
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 165, 0, 0.05));
      border-radius: 12px 12px 0 0;
    }
    
    .modal-header h2 {
      margin: 0;
      color: #FFD700;
      font-size: 1.5rem;
      font-family: 'Cinzel', serif;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    .modal-body {
      padding: 1.5rem;
    }
    
    .modal-body h3 {
      color: #FFD700;
      margin-bottom: 0.5rem;
    }
    
    .modal-body p {
      color: #ccc;
      margin-bottom: 1rem;
    }
    
    .close-btn {
      background: none;
      border: none;
      color: #ccc;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      transition: all 0.2s;
    }
    
    .close-btn:hover {
      background: #444;
      color: white;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    @keyframes slideIn {
      from { 
        transform: translateY(-50px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }
    
    @keyframes progressStripes {
      0% {
        background-position: 0 0;
      }
      100% {
        background-position: 30px 30px;
      }
    }
    
    .small-btn {
      background: #4a7c59;
      color: white;
      border: none;
      padding: 0.25rem 0.75rem;
      border-radius: 4px;
      font-size: 0.85rem;
      cursor: pointer;
      transition: background 0.2s;
      white-space: nowrap;
    }
    
    .small-btn:hover {
      background: #3a6249;
    }
    
    .small-btn.secondary-btn {
      background: #6c757d;
    }
    
    .small-btn.secondary-btn:hover {
      background: #5a6268;
    }
    
    .small-btn.danger-btn {
      background: #dc3545;
    }
    
    .small-btn.danger-btn:hover {
      background: #c82333;
    }
    
    .small-btn.warning-btn {
      background: #FF6B35;
    }
    
    .small-btn.warning-btn:hover {
      background: #FF5722;
    }
    
    .small-btn.info-btn {
      background: #17a2b8;
    }
    
    .small-btn.info-btn:hover {
      background: #138496;
    }
    
    .small-btn.success-btn {
      background: #28a745;
    }
    
    .small-btn.success-btn:hover {
      background: #218838;
    }
    
    .action-buttons {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      justify-content: flex-start;
      align-items: center;
    }
    
    .action-group {
      display: flex;
      gap: 0.25rem;
    }
    
    .admin-actions {
      border-left: 2px solid #444;
      padding-left: 0.5rem;
      margin-left: 0.25rem;
    }
    
    .btn-icon {
      margin-right: 0.25rem;
      display: inline-block;
    }
    /* Voting Status Bar Styles */
    .vote-status-row {
      background: transparent !important;
    }
    
    .vote-status-row:hover {
      background: transparent !important;
    }
    
    .vote-status-row td {
      border: none !important;
      border-top: none !important;
      padding-top: 0 !important;
      padding-bottom: 0.75rem !important;
      background: transparent !important;
    }
    
    /* Remove bottom border from POI data rows when followed by status bar */
    .admin-table tbody tr:has(+ .vote-status-row) td {
      border-bottom: none !important;
    }
    
    /* Fallback for browsers without :has() support */
    .admin-table tbody tr.poi-data-row td {
      border-bottom: none !important;
    }
    
    /* Restore border for status rows followed by data rows */
    .admin-table tbody tr.vote-status-row + tr.poi-data-row td {
      border-top: 1px solid #dee2e6 !important;
    }
    
    .vote-status-bar {
      width: 100%;
      padding: 0 1rem;
    }
    
    .vote-bar-track {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      width: 100%;
    }
    
    .vote-bar-container {
      flex: 1;
      height: 16px;
      background: #f8f8f8;
      border-radius: 8px;
      position: relative;
      overflow: hidden;
      border: 1px solid #ddd;
      box-shadow: inset 0 1px 3px rgba(0,0,0,0.05);
    }
    
    .vote-bar-fill {
      position: absolute;
      height: 100%;
      transition: all 0.3s ease;
      opacity: 0.9;
      box-shadow: 0 1px 2px rgba(0,0,0,0.15);
      z-index: 0;
    }
    
    .vote-bar-marker {
      position: absolute;
      width: 2px;
      height: 100%;
      background: #333;
      top: 0;
      transform: translateX(-50%);
      z-index: 2;
      box-shadow: 0 0 2px rgba(0,0,0,0.3);
    }
    
    .vote-bar-center {
      position: absolute;
      width: 2px;
      height: 100%;
      background: #333;
      left: 50%;
      top: 0;
      transform: translateX(-50%);
      z-index: 1;
      box-shadow: 0 0 1px rgba(0,0,0,0.5);
    }
    
    .vote-label {
      font-size: 0.75rem;
      font-weight: 600;
      white-space: nowrap;
      min-width: 85px;
      text-align: center;
    }
    
    .vote-label.reject {
      color: #dc3545;
    }
    
    .vote-label.approve {
      color: #28a745;
    }
    
    .xp-input {
      width: 80px;
      padding: 0.25rem 0.5rem;
      border: 1px solid #555;
      border-radius: 4px;
      font-size: 1rem;
      text-align: center;
      background: #2d2d2d;
      color: #e0e0e0;
    }
    
    .xp-input:focus {
      outline: none;
      border-color: #4a7c59;
      background: #1a1a1a;
      box-shadow: 0 0 0 2px rgba(74, 124, 89, 0.3);
    }
    
    .btn-sm {
      padding: 0.25rem 0.75rem;
      font-size: 0.875rem;
    }
    
    .admin-section {
      background: #3a3a3a;
      border-radius: 8px;
      padding: 1.5rem;
      margin-bottom: 2rem;
      border: 1px solid #444;
      width: 100%;
      max-width: 100%;
    }
    
    .admin-section h3 {
      margin: 0 0 0.5rem 0;
      color: #FFD700;
      font-size: 1.3rem;
    }
    
    #toggle-admin-btn.small-btn {
      background: #6f42c1;
    }
    
    #toggle-admin-btn.small-btn:hover {
      background: #5930a1;
    }
    
    /* Button styles for POI type management */
    .primary-btn {
      background: #4a7c59;
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 500;
      transition: all 0.3s;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .primary-btn:hover:not(:disabled) {
      background: #5a8d69;
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(74, 124, 89, 0.3);
    }
    
    .primary-btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    
    .primary-btn:disabled,
    .secondary-btn:disabled {
      background: #555;
      color: #999;
      cursor: not-allowed;
      opacity: 0.6;
      transform: none;
      box-shadow: none;
    }
    
    .secondary-btn {
      background: #555;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background-color 0.3s;
    }
    
    .secondary-btn:hover {
      background: #666;
    }
    
    /* Small buttons for inline actions */
    .small-btn {
      padding: 0.25rem 0.75rem;
      font-size: 0.85rem;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      transition: all 0.2s;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-weight: 500;
    }
    
    .small-btn.primary-btn {
      background: #4a7c59;
      color: white;
    }
    
    .small-btn.primary-btn:hover {
      background: #5a8d69;
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(74, 124, 89, 0.3);
    }
    
    .small-btn.danger-btn {
      background: #dc3545;
      color: white;
    }
    
    .small-btn.danger-btn:hover {
      background: #c82333;
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(220, 53, 69, 0.3);
    }
    
    .btn-sm {
      padding: 0.25rem 0.5rem;
      font-size: 0.8rem;
    }
    
    /* Markdown formatting buttons */
    .markdown-btn {
      background: #3a3a3a;
      color: #e0e0e0;
      border: 1px solid #555;
      padding: 0.4rem 0.75rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
      font-family: inherit;
      transition: all 0.2s;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 40px;
    }
    
    .markdown-btn:hover {
      background: #4a4a4a;
      border-color: #7fb069;
      color: #7fb069;
      transform: translateY(-1px);
    }
    
    .markdown-btn:active {
      transform: translateY(0);
    }
    
    .markdown-btn code {
      font-family: 'Consolas', 'Monaco', monospace;
      font-size: 0.85em;
    }
    
    /* Form styles */
    .form-group {
      margin-bottom: 1.5rem;
      max-width: 600px;
    }
    
    .form-group label {
      display: block;
      margin-bottom: 0.5rem;
      color: #e0e0e0;
      font-weight: 500;
    }
    
    .form-group input[type="text"],
    .form-group input[type="file"] {
      width: 100%;
      padding: 0.75rem;
      border: 1px solid #555;
      border-radius: 4px;
      background: #1a1a1a;
      color: #e0e0e0;
      font-size: 1rem;
    }
    
    .form-group input[type="text"]:focus {
      outline: none;
      border-color: #4a7c59;
      box-shadow: 0 0 0 2px rgba(74, 124, 89, 0.2);
    }
    
    .radio-group {
      display: flex;
      gap: 1.5rem;
    }
    
    .radio-group label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      cursor: pointer;
      margin-bottom: 0;
    }
    
    .radio-group input[type="radio"] {
      cursor: pointer;
    }
    
    .help-text {
      font-size: 0.85rem;
      color: #999;
      margin-top: 0.25rem;
    }
    
    .help-text a {
      color: #4a7c59;
      text-decoration: none;
    }
    
    .help-text a:hover {
      text-decoration: underline;
    }
    
    .modal-actions {
      display: flex;
      gap: 1rem;
      justify-content: flex-end;
      margin-top: 2rem;
    }
    
    /* Emoji picker styles */
    .emoji-category-btn {
      background: #2d2d2d;
      border: 1px solid #444;
      font-size: 1.5rem;
      padding: 0.75rem 1rem;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.2s ease;
      min-width: 50px;
    }
    
    .emoji-category-btn:hover {
      background: #3d3d3d;
      border-color: #FFD700;
      transform: translateY(-1px);
    }
    
    .emoji-category-btn.active {
      background: #4a7c59;
      border-color: #FFD700;
      box-shadow: 0 2px 8px rgba(255, 215, 0, 0.3);
    }
    
    /* POI Type Modal specific styles */
    #poi-type-modal .modal-content {
      max-width: 800px !important;
      width: 90% !important;
    }
    
    #emoji-picker {
      margin-top: 1rem;
      border: 1px solid #555;
      border-radius: 8px;
      background: #2d2d2d;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }
    
    #emoji-grid {
      display: grid !important;
      grid-template-columns: repeat(auto-fill, minmax(50px, 1fr)) !important;
      gap: 0.5rem !important;
      padding: 1rem !important;
      max-height: 400px !important;
      overflow-y: auto !important;
      background: #1a1a1a !important;
    }
    
    /* Icon set buttons */
    .icon-set-btn {
      background: #444;
      color: #e0e0e0;
      border: 1px solid #555;
      padding: 0.4rem 0.8rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.85rem;
      transition: all 0.2s;
    }
    
    .icon-set-btn:hover {
      background: #555;
      border-color: #666;
    }
    
    .icon-set-btn.active {
      background: #4a7c59;
      border-color: #5a8d69;
    }
    
    /* Iconify icon grid items */
    .iconify-icon-item {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0.75rem;
      border: 1px solid transparent;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
      background: transparent;
    }
    
    .iconify-icon-item:hover {
      background: #444;
      border-color: #555;
    }
    
    .iconify-icon-item.selected {
      background: #4a7c59;
      border-color: #5a8d69;
    }
    
    /* Ensure SVG icons display properly */
    .iconify-icon-item svg {
      width: 24px;
      height: 24px;
    }
    
    .iconify-icon-item:hover {
      transform: scale(1.1);
    }
    
    .iconify-icon-item.selected {
      transform: scale(1.1);
    }
    
    /* Pagination Styles */
    .pagination-btn {
      padding: 0.5rem 0.75rem;
      margin: 0 0.25rem;
      border: 1px solid #444;
      background: #2d2d2d;
      color: #e0e0e0;
      cursor: pointer;
      border-radius: 4px;
      font-size: 0.875rem;
      transition: all 0.2s;
      min-width: 36px;
    }
    
    .pagination-btn:hover:not(:disabled) {
      background: #3d3d3d;
      border-color: #666;
    }
    
    .pagination-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .pagination-btn.active {
      background: #FFD700;
      color: #2a1810;
      border-color: #FFD700;
    }
    
    /* Collapsible Section Styles */
    .admin-section {
      margin-bottom: 1.5rem;
      border: 1px solid #444;
      border-radius: 8px;
      overflow: hidden;
      width: 100%;
    }
    
    .admin-section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      background: #2d2d2d;
      cursor: pointer;
      transition: background 0.2s;
      user-select: none;
    }
    
    .admin-section-header:hover {
      background: #3d3d3d;
    }
    
    .admin-section-header h3 {
      margin: 0;
      color: #FFD700;
    }
    
    .admin-section-header .collapse-icon {
      font-size: 1.2rem;
      transition: transform 0.3s;
      color: #FFD700;
    }
    
    .admin-section.collapsed .collapse-icon {
      transform: rotate(-90deg);
    }
    
    .admin-section-content {
      padding: 1rem;
      background: #1a1a1a;
      transition: max-height 0.3s ease-out, padding 0.3s ease-out;
      overflow: hidden;
    }
    
    .admin-section.collapsed .admin-section-content {
      max-height: 0;
      padding: 0 1rem;
    }
    
    /* POI Editor Styles */
    .poi-editor-table {
      font-size: 0.9rem;
      width: 100%;
    }
    
    /* Ensure table containers use full width */
    .table-container {
      width: 100%;
      overflow-x: auto;
    }
    
    #poi-editor-content,
    #item-editor-content {
      width: 100%;
    }
    
    .poi-editor-table td {
      padding: 0.5rem;
      position: relative;
    }
    
    .poi-editor-table input[type="text"],
    .poi-editor-table input[type="number"],
    .poi-editor-table textarea,
    .poi-editor-table select {
      width: 100%;
      padding: 0.35rem 0.5rem;
      border: 1px solid transparent;
      background: transparent;
      color: #e0e0e0;
      font-size: 0.9rem;
      transition: all 0.2s;
      box-sizing: border-box;
      min-width: 0; /* Allow select to shrink properly */
    }
    
    /* Item Editor Styles - matching POI Editor */
    .item-editor-table {
      font-size: 0.9rem;
      width: 100%;
    }
    
    .item-editor-table td {
      padding: 0.5rem;
      position: relative;
      border-bottom: 1px solid #3a3a3a;
    }
    
    .item-editor-table input[type="text"],
    .item-editor-table input[type="number"],
    .item-editor-table textarea,
    .item-editor-table select {
      width: 100%;
      padding: 0.35rem 0.5rem;
      border: 1px solid transparent;
      background: transparent;
      color: #e0e0e0;
      font-size: 0.9rem;
      transition: all 0.2s;
      box-sizing: border-box;
      min-width: 0;
    }
    
    /* Add hover effect to item editor table rows */
    .item-editor-table tr:hover {
      background: #333;
    }
    
    /* Cell hover effect for both editors */
    .poi-editor-table td:hover,
    .item-editor-table td:hover {
      outline: 2px solid #4a7c59;
      outline-offset: -2px;
      background: rgba(74, 124, 89, 0.1);
    }
    
    /* Match POI editor focus styles */
    .item-editor-table input[type="text"]:focus,
    .item-editor-table input[type="number"]:focus,
    .item-editor-table textarea:focus,
    .item-editor-table select:focus {
      outline: none;
      border-color: #4a7c59;
      background: #2d2d2d;
    }
    
    .poi-editor-table input[type="number"] {
      text-align: center;
      width: 100%;
    }
    
    .item-editor-table input[type="number"] {
      text-align: center;
      width: 100% !important;
      box-sizing: border-box;
    }
    
    .poi-editor-table input[type="text"]:focus,
    .poi-editor-table input[type="number"]:focus,
    .poi-editor-table textarea:focus,
    .poi-editor-table select:focus {
      outline: none;
      border-color: #4a7c59;
      background: #2d2d2d;
    }
    
    .poi-editor-table textarea {
      resize: vertical;
      min-height: 50px;
    }
    
    .poi-editor-table input[type="checkbox"] {
      cursor: pointer;
      width: 18px;
      height: 18px;
    }
    
    .poi-editor-table .cell-changed {
      background: rgba(255, 215, 0, 0.1) !important;
      border: 1px solid rgba(255, 215, 0, 0.3) !important;
      position: relative;
    }
    
    .poi-editor-table .cell-changed::after {
      content: '';
      position: absolute;
      top: -1px;
      right: -1px;
      width: 0;
      height: 0;
      border-left: 10px solid transparent;
      border-top: 10px solid #FFD700;
    }
    
    .poi-editor-table tr.marked-for-deletion {
      background: rgba(255, 0, 0, 0.2) !important;
      opacity: 0.8;
    }
    
    .poi-editor-table tr.highlighted-poi {
      position: relative;
      animation: highlightPulse 2s ease-in-out;
    }
    
    .poi-editor-table tr.highlighted-poi td {
      border-top: 3px solid #FFD700 !important;
      border-bottom: 3px solid #FFD700 !important;
      position: relative;
    }
    
    .poi-editor-table tr.highlighted-poi td:first-child {
      border-left: 3px solid #FFD700 !important;
    }
    
    .poi-editor-table tr.highlighted-poi td:last-child {
      border-right: 3px solid #FFD700 !important;
    }
    
    /* Keep the border visible after animation */
    .poi-editor-table tr.highlighted-poi::after {
      content: '';
      position: absolute;
      top: -3px;
      left: -3px;
      right: -3px;
      bottom: -3px;
      border: 3px solid #FFD700;
      pointer-events: none;
      border-radius: 4px;
    }
    
    @keyframes highlightPulse {
      0% { 
        box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7);
      }
      50% { 
        box-shadow: 0 0 0 10px rgba(255, 215, 0, 0);
      }
      100% { 
        box-shadow: 0 0 0 0 rgba(255, 215, 0, 0);
      }
    }
    
    .poi-editor-table tr.marked-for-deletion td {
      text-decoration: line-through;
      color: #ff6666 !important;
    }
    
    .poi-editor-table tr.marked-for-deletion input,
    .poi-editor-table tr.marked-for-deletion textarea,
    .poi-editor-table tr.marked-for-deletion select,
    .poi-editor-table tr.marked-for-deletion .custom-select-display {
      opacity: 0.6;
      pointer-events: none;
    }
    
    /* Item Editor Styles */
    .item-editor-table input.inline-edit,
    .item-editor-table select.inline-edit {
      background: transparent;
      border: 1px solid transparent;
      color: inherit;
      font-family: inherit;
      font-size: inherit;
      padding: 0.25rem 0.5rem;
      transition: border-color 0.2s;
    }
    
    .item-editor-table input.inline-edit:focus,
    .item-editor-table select.inline-edit:focus {
      outline: none;
      border-color: #FFD700;
      background: #2d2d2d;
    }
    
    .item-editor-table .cell-changed {
      background: rgba(255, 215, 0, 0.1) !important;
      border: 1px solid rgba(255, 215, 0, 0.3) !important;
      position: relative;
    }
    
    .item-editor-table .cell-changed::after {
      content: '';
      position: absolute;
      top: -1px;
      right: -1px;
      width: 0;
      height: 0;
      border-left: 10px solid transparent;
      border-top: 10px solid #FFD700;
    }
    
    .item-editor-table tr.marked-for-deletion {
      background: rgba(255, 0, 0, 0.2) !important;
      opacity: 0.8;
    }
    
    /* Race/Class Multi-select Dropdown Styles */
    .race-display, .class-display {
      transition: all 0.2s;
    }
    
    .race-display:hover, .class-display:hover {
      background: #3a3a3a !important;
      border-color: #666 !important;
    }
    
    .item-editor-table .race-display.changed,
    .item-editor-table .class-display.changed {
      background: rgba(74, 124, 89, 0.3) !important;
      border-color: #4a7c59 !important;
    }
    
    /* NPC Editor Styles - matching Item Editor */
    .npc-editor-table {
      font-size: 0.9rem;
      width: 100%;
    }
    
    .npc-editor-table td {
      padding: 0.5rem;
      position: relative;
      border-bottom: 1px solid #3a3a3a;
    }
    
    .npc-editor-table input[type="text"],
    .npc-editor-table input[type="number"],
    .npc-editor-table textarea,
    .npc-editor-table select {
      width: 100%;
      padding: 0.35rem 0.5rem;
      border: 1px solid transparent;
      background: transparent;
      color: #e0e0e0;
      font-size: 0.9rem;
      transition: all 0.2s;
      box-sizing: border-box;
      min-width: 0;
    }
    
    /* Add hover effect to NPC editor table rows */
    .npc-editor-table tr:hover {
      background: #333;
    }
    
    /* Cell hover effect for NPC editor */
    .npc-editor-table td:hover {
      outline: 2px solid #4a7c59;
      outline-offset: -2px;
      background: rgba(74, 124, 89, 0.1);
    }
    
    /* Match Item editor focus styles */
    .npc-editor-table input[type="text"]:focus,
    .npc-editor-table input[type="number"]:focus,
    .npc-editor-table textarea:focus,
    .npc-editor-table select:focus {
      outline: none;
      border-color: #4a7c59;
      background: #2d2d2d;
    }
    
    .npc-editor-table input[type="number"] {
      text-align: center;
      width: 100% !important;
      box-sizing: border-box;
    }
    
    .npc-editor-table input.inline-edit,
    .npc-editor-table select.inline-edit {
      background: transparent;
      border: 1px solid transparent;
      color: inherit;
      font-family: inherit;
      font-size: inherit;
      padding: 0.25rem 0.5rem;
      transition: border-color 0.2s;
    }
    
    .npc-editor-table input.inline-edit:focus,
    .npc-editor-table select.inline-edit:focus {
      outline: none;
      border-color: #FFD700;
      background: #2d2d2d;
    }
    
    .npc-editor-table .cell-changed {
      background: rgba(255, 215, 0, 0.1) !important;
      border: 1px solid rgba(255, 215, 0, 0.3) !important;
      position: relative;
    }
    
    .npc-editor-table .cell-changed::after {
      content: '';
      position: absolute;
      top: -1px;
      right: -1px;
      width: 0;
      height: 0;
      border-left: 10px solid transparent;
      border-top: 10px solid #FFD700;
    }
    
    .npc-editor-table tr.marked-for-deletion {
      background: rgba(255, 0, 0, 0.2) !important;
      opacity: 0.8;
    }
    
    /* NPC and Item stats styling */
    .npc-stats,
    .item-stats {
      display: flex;
      gap: 2rem;
      padding: 1rem;
      background: #1a1a1a;
      border-radius: 4px;
      font-size: 0.9rem;
    }
    
    .npc-stat,
    .item-stat {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }
    
    .npc-stat-value,
    .item-stat-value {
      font-weight: bold;
      color: #FFD700;
    }
    
    .item-editor-table tr.marked-for-deletion input,
    .item-editor-table tr.marked-for-deletion select {
      text-decoration: line-through;
      opacity: 0.6;
      pointer-events: none;
    }
    
    .delete-btn {
      background: #dc3545;
      color: white;
      border: none;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.875rem;
      transition: all 0.2s;
    }
    
    .delete-btn:hover {
      background: #c82333;
    }
    
    .delete-btn.undo {
      background: #28a745;
    }
    
    .delete-btn.undo:hover {
      background: #218838;
    }
    
    .poi-editor-table tbody tr:hover {
      background: rgba(74, 124, 89, 0.05);
    }
    
    .poi-editor-table td {
      transition: background 0.2s;
    }
    
    .poi-editor-table input:hover:not(:focus),
    .poi-editor-table textarea:hover:not(:focus),
    .poi-editor-table select:hover:not(:focus) {
      background: rgba(74, 124, 89, 0.05);
      border-color: rgba(74, 124, 89, 0.3);
    }
    
    .poi-editor-table .invalid-type {
      background: rgba(255, 0, 0, 0.2) !important;
      border: 1px solid rgba(255, 0, 0, 0.5) !important;
    }
    
    .poi-type-select {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .poi-type-icon {
      font-size: 1.2rem;
      text-align: center;
      vertical-align: middle;
    }
    
    .poi-type-icon span {
      display: inline-block;
      line-height: 1;
    }
    
    .poi-type-icon img {
      display: inline-block;
      vertical-align: middle;
    }
    
    /* POI Editor enhancements */
    .poi-editor-search {
      flex: 1;
      max-width: 300px;
      padding: 0.5rem 1rem;
      border: 1px solid #555;
      border-radius: 4px;
      background: #2d2d2d;
      color: #e0e0e0;
      font-size: 0.9rem;
    }
    
    .poi-editor-search:focus {
      outline: none;
      border-color: #4a7c59;
    }
    
    .poi-editor-table th {
      cursor: pointer;
      user-select: none;
      position: relative;
      transition: background 0.2s;
    }
    
    .poi-editor-table th:hover {
      background: rgba(74, 124, 89, 0.2);
    }
    
    .poi-editor-table th.sorted-asc::after,
    .poi-editor-table th.sorted-desc::after {
      position: absolute;
      right: 8px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 0.8rem;
    }
    
    .poi-editor-table th.sorted-asc::after {
      content: '';
    }
    
    .poi-editor-table th.sorted-desc::after {
      content: '';
    }
    
    .export-btn {
      background: #17a2b8;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.875rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      transition: background 0.2s;
    }
    
    .export-btn:hover {
      background: #138496;
    }
    
    .poi-stats {
      display: flex;
      gap: 1rem;
      align-items: center;
      color: #999;
      font-size: 0.875rem;
    }
    
    .poi-stat {
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }
    
    .poi-stat-value {
      font-weight: bold;
      color: #e0e0e0;
    }
    
    /* Loading animation for reload button */
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    .loading-spinner {
      animation: spin 1s linear infinite;
      display: inline-block;
    }
    
    /* Voting Tab Styles */
    .voting-stats-container {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 0.75rem;
      margin-bottom: 1.5rem;
    }
    
    .voting-stat-card {
      background: #3a3a3a;
      border: 2px solid transparent;
      border-radius: 8px;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
    }
    
    .voting-stat-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    
    .voting-stat-card.active {
      border-color: #FFD700;
      background: #4a4a4a;
    }
    
    .voting-stat-card .stat-main {
      padding: 1rem;
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
      width: 100%;
    }
    
    .voting-stat-card .stat-icon {
      font-size: 1.5rem;
    }
    
    .voting-stat-card .stat-info {
      text-align: center;
      width: 100%;
    }
    
    .voting-stat-card .stat-value {
      font-size: 1.5rem;
      font-weight: bold;
      color: #FFD700;
      line-height: 1;
    }
    
    .voting-stat-card .stat-label {
      font-size: 0.8rem;
      color: #ccc;
      margin-top: 0.2rem;
    }
    
    .voting-stat-card .stat-pending {
      background: #FF6B00;
      color: white;
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      font-weight: bold;
      text-align: center;
      width: 100%;
    }
    
    .voting-stat-card .stat-pending.none {
      background: #2d5a2d;
      color: #a8d5a8;
    }
    
    .voting-controls {
      display: flex;
      gap: 1rem;
      align-items: flex-end;
      margin-bottom: 1.5rem;
      flex-wrap: wrap;
    }
    
    .filter-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    
    .filter-group label {
      font-size: 0.875rem;
      color: #999;
    }
    
    .proposals-list {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    
    .proposal-card {
      background: #2d2d2d;
      border-radius: 8px;
      padding: 1.5rem;
      border: 1px solid #444;
      transition: all 0.2s;
    }
    
    .proposal-card:hover {
      border-color: #4a7c59;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }
    
    .proposal-card.collapsed {
      padding: 1rem 1.5rem;
    }
    
    .proposal-card.collapsed .proposal-header {
      margin-bottom: 0;
    }
    
    .proposal-card.expanded {
      border-color: #4a7c59;
      box-shadow: 0 4px 12px rgba(74, 124, 89, 0.3);
    }
    
    .proposal-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 1rem;
    }
    
    .proposal-title {
      font-size: 1.1rem;
      font-weight: bold;
      color: #FFD700;
      margin-bottom: 0.5rem;
    }
    
    .proposal-meta {
      display: flex;
      gap: 1rem;
      font-size: 0.875rem;
      color: #999;
    }
    
    .proposal-type {
      display: inline-block;
      padding: 0.25rem 0.75rem;
      background: rgba(74, 124, 89, 0.2);
      color: #4a7c59;
      border-radius: 4px;
      font-size: 0.875rem;
    }
    
    .proposal-content {
      margin-bottom: 1rem;
    }
    
    .proposal-voting {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding-top: 1rem;
      border-top: 1px solid #444;
    }
    
    .vote-buttons {
      display: flex;
      gap: 0.5rem;
    }
    
    .vote-btn {
      background: #3a3a3a;
      border: 1px solid #555;
      color: #e0e0e0;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      transition: all 0.2s;
    }
    
    .vote-btn:hover {
      background: #444;
    }
    
    .vote-btn.upvote {
      color: #4CAF50;
    }
    
    .vote-btn.upvote.active {
      background: rgba(76, 175, 80, 0.2);
      border-color: #4CAF50;
    }
    
    .vote-btn.downvote {
      color: #f44336;
    }
    
    .vote-btn.downvote.active {
      background: rgba(244, 67, 54, 0.2);
      border-color: #f44336;
    }
    
    .vote-score {
      font-weight: bold;
      font-size: 1.1rem;
    }
    
    .vote-score.positive {
      color: #4CAF50;
    }
    
    .vote-score.negative {
      color: #f44336;
    }
    
    .proposal-actions {
      display: flex;
      gap: 0.5rem;
      margin-left: auto;
    }
    
    .proposal-status {
      padding: 0.25rem 0.75rem;
      border-radius: 4px;
      font-size: 0.875rem;
      font-weight: bold;
    }
    
    .proposal-status.pending {
      background: rgba(255, 193, 7, 0.2);
      color: #FFC107;
    }
    
    .proposal-status.approved {
      background: rgba(76, 175, 80, 0.2);
      color: #4CAF50;
    }
    
    .proposal-status.rejected {
      background: rgba(244, 67, 54, 0.2);
      color: #f44336;
    }
    
    .proposal-status.withdrawn {
      background: rgba(158, 158, 158, 0.2);
      color: #9e9e9e;
    }
    
    /* Modal form styling */
    .form-group {
      margin-bottom: 1rem;
    }
    
    .form-group label {
      display: block;
      margin-bottom: 0.5rem;
      color: #e0e0e0;
      font-weight: 500;
    }
    
    .form-control {
      width: 100%;
      padding: 0.5rem;
      background: #1a1a1a;
      border: 1px solid #555;
      border-radius: 4px;
      color: #e0e0e0;
      font-size: 1rem;
      transition: border-color 0.2s;
    }
    
    .form-control:focus {
      outline: none;
      border-color: #4a7c59;
      box-shadow: 0 0 0 2px rgba(74, 124, 89, 0.2);
    }
    
    .form-control:disabled {
      background: #2d2d2d;
      color: #999;
      cursor: not-allowed;
    }
    
    select.form-control {
      cursor: pointer;
    }
    
    select.form-control option {
      background: #1a1a1a;
      color: #e0e0e0;
    }
    
    textarea.form-control {
      resize: vertical;
      min-height: 60px;
    }
    
    /* Radio group styling */
    .radio-group {
      display: flex;
      gap: 1rem;
      margin-top: 0.5rem;
    }
    
    .radio-group label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0;
      cursor: pointer;
      color: #ccc;
    }
    
    .radio-group input[type="radio"] {
      cursor: pointer;
    }
    
    .radio-group label:hover {
      color: #e0e0e0;
    }
    
    /* Number input styling */
    input[type="number"].form-control {
      -moz-appearance: textfield;
    }
    
    input[type="number"].form-control::-webkit-outer-spin-button,
    input[type="number"].form-control::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    
    /* Grid layout for stat inputs */
    .stat-inputs-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 0.5rem;
    }
    
    /* Placeholder styling */
    .form-control::placeholder {
      color: #666;
      opacity: 1;
    }
    
    /* Focus states for better accessibility */
    .form-control:focus,
    .vote-btn:focus,
    .btn:focus {
      outline: 2px solid #4a7c59;
      outline-offset: 2px;
    }
    
    /* Proposal form specific styles */
    #proposal-form-content {
      background: #2d2d2d;
      padding: 1rem;
      border-radius: 8px;
      margin-top: 1rem;
    }
    
    #proposal-notes {
      background: #1a1a1a;
      border: 1px solid #444;
    }
    
    #proposal-notes:focus {
      border-color: #4a7c59;
    }
    
    /* Table loading state */
    .poi-editor-loading-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      border-radius: 8px;
    }
    
    .poi-editor-table-container {
      position: relative;
    }
    
    /* Custom POI Type Select Styles */
    .custom-poi-type-select {
      position: relative;
    }
    
    .custom-select-display {
      transition: all 0.2s;
    }
    
    .custom-select-display:hover {
      background: rgba(74, 124, 89, 0.05) !important;
      border-color: rgba(74, 124, 89, 0.3) !important;
    }
    
    .custom-select-dropdown {
      scrollbar-width: thin;
      scrollbar-color: #555 #2d2d2d;
    }
    
    .custom-select-dropdown::-webkit-scrollbar {
      width: 8px;
    }
    
    .custom-select-dropdown::-webkit-scrollbar-track {
      background: #2d2d2d;
    }
    
    .custom-select-dropdown::-webkit-scrollbar-thumb {
      background: #555;
      border-radius: 4px;
    }
    
    .custom-select-dropdown::-webkit-scrollbar-thumb:hover {
      background: #666;
    }
    
    /* Resizable columns for POI Editor */
    .poi-editor-table {
      table-layout: fixed;
    }
    
    .poi-editor-table th {
      position: relative;
      user-select: none;
    }
    
    .column-resizer {
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 5px;
      cursor: col-resize;
      background: transparent;
      z-index: 10;
    }
    
    .column-resizer:hover,
    .column-resizer.resizing {
      background: #4a7c59;
    }
    
    .poi-editor-table th.resizing {
      background: #3a3a3a;
    }
    
    /* Twemoji styling */
    img.twemoji-icon {
      height: 1.2em;
      width: 1.2em;
      margin: 0 .05em 0 .1em;
      vertical-align: -0.1em;
    }
    
    /* Responsive design */
    @media (max-width: 768px) {
      .account-container {
        flex-direction: column;
        padding: 1rem;
      }
      
      .account-sidebar {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
        padding: 0.5rem;
        position: static;
      }
      
      .nav-item {
        flex: 1;
        min-width: 120px;
        padding: 0.5rem;
        font-size: 0.9rem;
      }
      
      .account-content {
        padding: 1rem;
      }
      
      .admin-section-content {
        padding: 1rem;
      }
      
      .tab-content {
        max-width: 100%;
      }
    }
    
    /* Ensure tables don't break layout */
    .admin-table {
      width: 100%;
      table-layout: auto;
    }
    
    /* Table containers should handle overflow */
    .poi-editor-table-container,
    .item-editor-table-container {
      width: 100%;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }
    
    /* Prevent content from overflowing */
    .admin-section-content {
      overflow-x: auto;
    }
    
    /* Fix button groups on small screens */
    @media (max-width: 1024px) {
      .poi-editor-search,
      .item-editor-search {
        max-width: 200px;
      }
      
      .export-btn span {
        display: none;
      }
      
      .export-btn::after {
        content: 'CSV';
      }
    }
    
    /* Ensure all inputs are properly contained */
    input, select, textarea {
      max-width: 100%;
      box-sizing: border-box;
    }
    
    /* Fix search bar layouts */
    #poi-search, #item-search {
      flex: 1;
      min-width: 0;
      max-width: 100%;
    }
    
    /* Admin section headers should not overflow */
    .admin-section-header h3 {
      word-wrap: break-word;
      overflow-wrap: break-word;
    }
    
    /* Admin tab full width */
    #admin-tab {
      padding: 0;
    }
    
    #admin-tab > * {
      width: 100%;
    }
    
    /* Ensure flex containers wrap properly */
    .admin-section-content > div:first-child {
      flex-wrap: wrap;
      gap: 1rem;
    }
    
    /* Fix button groups */
    div[style*="display: flex"][style*="gap"] {
      flex-wrap: wrap;
    }
    
    
    /* Stats cards container */
    .profile-stats {
      max-width: 800px;
      width: 100%;
    }
    
    /* Fix proposal diff overflow */
    .proposal-content {
      overflow: hidden;
      width: 100%;
    }
    
    .proposal-diff-grid {
      display: grid !important;
      grid-template-columns: 1fr 1fr !important;
      gap: 1rem !important;
      overflow: hidden;
      width: 100%;
    }
    
    .proposal-diff-grid > div {
      min-width: 0;
      overflow: hidden;
      padding: 0.75rem !important;
      border-radius: 4px;
      word-break: break-word;
    }
    
    /* Ensure list items in proposals wrap properly */
    .proposal-content ul {
      padding-left: 1.5rem;
      margin: 0;
    }
    
    .proposal-content li {
      word-wrap: break-word;
      overflow-wrap: break-word;
      word-break: break-word;
      margin-bottom: 0.5rem;
    }
    
    /* Fix flex items in proposal headers */
    .proposal-content div[style*="display: flex"] {
      flex-wrap: wrap;
    }
    
    .proposal-content span[style*="margin-right"] {
      white-space: nowrap;
    }
    
    .proposal-content p {
      word-wrap: break-word;
      overflow-wrap: break-word;
      word-break: break-word;
      hyphens: auto;
      margin: 0.5rem 0;
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    /* For very long unbreakable strings */
    .proposal-content p:hover {
      overflow: visible;
      word-break: break-all;
    }
    
    .proposal-content strong {
      display: inline-block;
      min-width: fit-content;
      margin-right: 0.5rem;
    }
    
    /* Equal spacing for diff sections */
    .proposal-card {
      container-type: inline-size;
    }
    
    .proposal-diff-grid > div:first-child {
      background: rgba(255, 0, 0, 0.1) !important;
    }
    
    .proposal-diff-grid > div:last-child {
      background: rgba(0, 255, 0, 0.1) !important;
    }
    
    /* Vote status bar */
    .vote-status-bar {
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid #444;
    }
    
    .vote-bar-container {
      position: relative;
      height: 28px;
      background: #1a1a1a;
      border-radius: 14px;
      overflow: hidden;
      border: 2px solid #333;
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
      margin: 0 2px;
    }
    
    
    .vote-bar-track {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      overflow: hidden;
    }
    
    .vote-bar-left,
    .vote-bar-right {
      flex: 1;
      position: relative;
      background: #2a2a2a;
    }
    
    .vote-bar-left {
      background: linear-gradient(90deg, rgba(239, 68, 68, 0.1), rgba(0, 0, 0, 0));
    }
    
    .vote-bar-right {
      background: linear-gradient(90deg, rgba(0, 0, 0, 0), rgba(74, 222, 128, 0.1));
    }
    
    
    .vote-bar-fill {
      position: absolute;
      top: 0;
      bottom: 0;
      transition: all 0.3s ease;
      height: 100%;
      z-index: 1;
    }
    
    .vote-bar-fill.positive {
      left: 50%;
      background: linear-gradient(90deg, #4ade80, #22c55e);
      border-radius: 0;
      box-shadow: 0 0 8px rgba(74, 222, 128, 0.5);
    }
    
    .vote-bar-fill.negative {
      right: 50%;
      background: linear-gradient(90deg, #dc2626, #ef4444);
      border-radius: 0;
      box-shadow: 0 0 8px rgba(239, 68, 68, 0.5);
    }
    
    .vote-bar-labels {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
      font-size: 0.85rem;
    }
    
    .vote-bar-labels .label-left {
      color: #ef4444;
      font-weight: 600;
    }
    
    .vote-bar-labels .label-center {
      color: #999;
      font-size: 0.75rem;
    }
    
    .vote-bar-labels .label-right {
      color: #4ade80;
      font-weight: 600;
    }
    
    .vote-bar-markers {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: 5;
    }
    
    .vote-bar-marker {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      font-size: 0.75rem;
      color: #fff;
      font-weight: 700;
      z-index: 10;
      line-height: 1;
      font-family: 'Arial', sans-serif;
      letter-spacing: 0.5px;
      background: rgba(0, 0, 0, 0.95);
      padding: 0.25rem 0.5rem;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 32px;
      height: 20px;
      backdrop-filter: blur(4px);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
    }
    
    .vote-bar-marker.left {
      left: 12px;
    }
    
    .vote-bar-marker.center {
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      z-index: 15;
    }
    
    .vote-bar-marker.right {
      right: 12px;
    }
    
    
    /* Pulsing effect for near-threshold scores */
    .vote-bar-fill.near-threshold {
      animation: pulse-glow 2s ease-in-out infinite;
    }
    
    @keyframes pulse-glow {
      0%, 100% {
        opacity: 1;
        box-shadow: none;
      }
      50% {
        opacity: 0.8;
        box-shadow: 0 0 20px currentColor;
      }
    }
    
    .vote-status-text {
      display: flex;
      justify-content: center;
      margin-top: 0.75rem;
    }
    
    .vote-status-text .vote-score {
      font-size: 1.5rem;
      font-weight: 700;
      letter-spacing: 0.5px;
    }
    
    .vote-status-text .vote-score.positive {
      color: #4ade80;
    }
    
    .vote-status-text .vote-score.negative {
      color: #ef4444;
    }
    
    .vote-status-text .vote-score.neutral {
      color: #999;
    }
    
    /* Responsive proposal diffs */
    @media (max-width: 768px) {
      .proposal-diff-grid {
        grid-template-columns: 1fr !important;
      }
      
      .proposal-card {
        padding: 1rem;
      }
    }
    
    /* Modal Styles */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(5px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      animation: fadeIn 0.2s ease-out;
    }
    
    .modal-content {
      background: #2d2d2d;
      border: 2px solid #4a7c59;
      border-radius: 8px;
      padding: 2rem;
      max-width: 600px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      animation: slideIn 0.3s ease-out;
    }
    
    .modal-content h3 {
      margin-top: 0;
    }
    
    .modal-content .form-group {
      margin-bottom: 1.25rem;
    }
    
    .modal-content .form-group label {
      display: block;
      margin-bottom: 0.5rem;
      color: #FFD700;
      font-weight: 500;
      font-size: 0.9rem;
    }
    
    .modal-content input[type="text"],
    .modal-content input[type="number"],
    .modal-content input[type="color"],
    .modal-content textarea {
      width: 100%;
      padding: 0.75rem;
      background: #1a1a1a;
      border: 1px solid #444;
      border-radius: 6px;
      color: #e0e0e0;
      font-size: 1rem;
      transition: all 0.2s;
    }
    
    .modal-content input[type="text"]:focus,
    .modal-content input[type="number"]:focus,
    .modal-content textarea:focus {
      outline: none;
      border-color: #4a7c59;
      background: #222;
      box-shadow: 0 0 0 3px rgba(74, 124, 89, 0.2);
    }
    
    .modal-content input[type="color"] {
      height: 45px;
      cursor: pointer;
      padding: 0.25rem;
    }
    
    .modal-content input[type="checkbox"] {
      margin-right: 0.5rem;
      transform: scale(1.2);
      cursor: pointer;
    }
    
    .modal-content textarea {
      resize: vertical;
      min-height: 80px;
      font-family: inherit;
    }
    
    .modal-actions {
      display: flex;
      gap: 1rem;
      justify-content: flex-end;
      margin-top: 1.5rem;
    }
    
    .modal-content .btn {
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 6px;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .modal-content .btn-primary {
      background: #4a7c59;
      color: #FFD700;
      border: 1px solid #FFD700;
    }
    
    .modal-content .btn-primary:hover {
      background: #5fa772;
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(74, 124, 89, 0.4);
    }
    
    .modal-content .btn-secondary {
      background: #444;
      color: #e0e0e0;
      border: 1px solid #666;
    }
    
    .modal-content .btn-secondary:hover {
      background: #555;
      border-color: #888;
    }
    
    /* Emoji Picker Styles */
    .emoji-input-wrapper {
      position: relative;
      display: flex;
      gap: 0.5rem;
      align-items: stretch;
    }
    
    .emoji-input-wrapper input[type="text"] {
      flex: 1;
    }
    
    .emoji-picker-toggle {
      background: #4a7c59;
      color: #FFD700;
      border: 1px solid #FFD700;
      border-radius: 6px;
      padding: 0.75rem 1rem;
      cursor: pointer;
      font-size: 1.2rem;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 50px;
    }
    
    .emoji-picker-toggle:hover {
      background: #5fa772;
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(74, 124, 89, 0.4);
    }
    
    .emoji-picker-dropdown {
      position: absolute;
      top: calc(100% + 0.5rem);
      left: 0;
      right: 0;
      background: #1a1a1a;
      border: 2px solid #4a7c59;
      border-radius: 12px;
      padding: 1.5rem;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.9);
      z-index: 10001;
      max-height: 400px;
      overflow-y: auto;
      display: none;
      animation: fadeInScale 0.2s ease-out;
    }
    
    @keyframes fadeInScale {
      from {
        opacity: 0;
        transform: translateY(-10px) scale(0.95);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }
    
    .emoji-picker-dropdown.show {
      display: block;
    }
    
    .emoji-picker-dropdown::-webkit-scrollbar {
      width: 8px;
    }
    
    .emoji-picker-dropdown::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 4px;
    }
    
    .emoji-picker-dropdown::-webkit-scrollbar-thumb {
      background: #4a7c59;
      border-radius: 4px;
    }
    
    .emoji-picker-dropdown::-webkit-scrollbar-thumb:hover {
      background: #5fa772;
    }
    
    .emoji-picker-grid {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 0.5rem;
    }
    
    .emoji-option {
      background: #2d2d2d;
      border: 1px solid #3a3a3a;
      border-radius: 8px;
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 1.3rem;
      transition: all 0.15s ease;
      position: relative;
    }
    
    .emoji-option:hover {
      background: #4a7c59;
      border-color: #FFD700;
      transform: scale(1.15);
      z-index: 1;
      box-shadow: 0 4px 12px rgba(255, 215, 0, 0.3);
    }
    
    .emoji-option:active {
      transform: scale(1.05);
    }
    
    .emoji-category {
      margin-bottom: 1.25rem;
    }
    
    .emoji-category:last-child {
      margin-bottom: 0;
    }
    
    .emoji-category-title {
      color: #FFD700;
      font-size: 0.75rem;
      font-weight: 700;
      margin-bottom: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid rgba(255, 215, 0, 0.2);
    }
    
    /* Custom Confirmation Dialog */
    .confirm-dialog-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(5px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      animation: fadeIn 0.2s ease-out;
    }
    
    .confirm-dialog {
      background: #2d2d2d;
      border: 2px solid #4a7c59;
      border-radius: 8px;
      padding: 2rem;
      max-width: 400px;
      width: 90%;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      animation: slideIn 0.3s ease-out;
    }
    
    .confirm-dialog-title {
      color: #FFD700;
      margin: 0 0 1rem 0;
      font-size: 1.5rem;
      font-family: 'Cinzel', serif;
    }
    
    .confirm-dialog-message {
      color: #e0e0e0;
      margin: 0 0 1.5rem 0;
      line-height: 1.5;
    }
    
    .confirm-dialog-buttons {
      display: flex;
      gap: 1rem;
      justify-content: flex-end;
    }
    
    .confirm-dialog-btn {
      padding: 0.5rem 1.5rem;
      border: none;
      border-radius: 4px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .confirm-dialog-btn-cancel {
      background: #555;
      color: #fff;
    }
    
    .confirm-dialog-btn-cancel:hover {
      background: #666;
    }
    
    .confirm-dialog-btn-confirm {
      background: #dc3545;
      color: #fff;
    }
    
    .confirm-dialog-btn-confirm:hover {
      background: #c82333;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    @keyframes slideIn {
      from { 
        transform: translateY(-20px);
        opacity: 0;
      }
      to { 
        transform: translateY(0);
        opacity: 1;
      }
    }
    
    /* Batch Import Conflict Styles */
    .batch-import-cell.has-conflict {
      background-color: rgba(220, 53, 69, 0.1) !important;
      border: 1px solid rgba(220, 53, 69, 0.3) !important;
      position: relative;
      cursor: pointer;
    }
    
    /* Batch Import Inferred Field Styles */
    td.batch-import-inferred {
      position: relative;
    }
    
    td.batch-import-inferred input,
    td.batch-import-inferred select,
    td.batch-import-inferred textarea {
      background-color: rgba(77, 124, 254, 0.1) !important;
      border-color: rgba(77, 124, 254, 0.3) !important;
      box-shadow: 0 0 3px rgba(77, 124, 254, 0.2);
    }
    
    td.batch-import-inferred:hover input,
    td.batch-import-inferred:hover select,
    td.batch-import-inferred:hover textarea {
      background-color: rgba(77, 124, 254, 0.15) !important;
      border-color: rgba(77, 124, 254, 0.5) !important;
    }
    
    td.batch-import-inferred::before {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      color: #4d7cfe;
      font-size: 0.75rem;
      opacity: 0.8;
      pointer-events: none;
      z-index: 10;
    }
    
    /* Direct data source styling (green) */
    td.batch-import-direct {
      position: relative;
    }
    
    td.batch-import-direct input,
    td.batch-import-direct select,
    td.batch-import-direct textarea {
      background-color: rgba(76, 175, 80, 0.1) !important;
      border-color: rgba(76, 175, 80, 0.3) !important;
      box-shadow: 0 0 3px rgba(76, 175, 80, 0.2);
    }
    
    td.batch-import-direct:hover input,
    td.batch-import-direct:hover select,
    td.batch-import-direct:hover textarea {
      background-color: rgba(76, 175, 80, 0.15) !important;
      border-color: rgba(76, 175, 80, 0.5) !important;
    }
    
    td.batch-import-direct::before {
      content: '';
      position: absolute;
      top: 2px;
      left: 2px;
      color: #4caf50;
      font-size: 0.75rem;
      opacity: 0.8;
      pointer-events: none;
      z-index: 10;
    }
    
    .batch-import-cell.has-conflict:hover {
      background-color: rgba(220, 53, 69, 0.2) !important;
      border-color: rgba(220, 53, 69, 0.5) !important;
    }
    
    .batch-import-cell.has-conflict::after {
      content: '';
      position: absolute;
      top: 2px;
      right: 2px;
      color: #dc3545;
      font-size: 0.75rem;
      font-weight: bold;
    }
    
    /* Merge Conflict Modal */
    .merge-conflict-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10001;
    }
    
    .merge-conflict-content {
      background: #2d2d2d;
      border-radius: 12px;
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    }
    
    .merge-conflict-header {
      padding: 20px;
      border-bottom: 1px solid #444;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .merge-conflict-header h3 {
      margin: 0;
      color: #FFD700;
      font-size: 1.3rem;
    }
    
    .merge-conflict-close {
      background: none;
      border: none;
      color: #999;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 0;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      transition: all 0.2s;
    }
    
    .merge-conflict-close:hover {
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
    }
    
    .merge-conflict-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
    }
    
    .conflict-field-name {
      color: #999;
      font-size: 0.9rem;
      margin-bottom: 10px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .conflict-values {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 20px;
    }
    
    .conflict-value-option {
      padding: 15px;
      background: #1a1a1a;
      border: 2px solid #444;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }
    
    .conflict-value-option:hover {
      border-color: #666;
      background: #252525;
    }
    
    .conflict-value-option.selected {
      border-color: #4a7c59;
      background: rgba(74, 124, 89, 0.1);
    }
    
    .conflict-value-option.selected::after {
      content: '';
      position: absolute;
      top: 10px;
      right: 10px;
      color: #4a7c59;
      font-size: 1.2rem;
      font-weight: bold;
    }
    
    .conflict-value-label {
      color: #999;
      font-size: 0.8rem;
      margin-bottom: 5px;
    }
    
    .conflict-value-content {
      color: #e0e0e0;
      font-size: 1rem;
      font-weight: 500;
    }
    
    .merge-conflict-footer {
      padding: 20px;
      border-top: 1px solid #444;
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }
    
    .existing-item-indicator {
      display: inline-block;
      background: #FF6B00;
      color: white;
      padding: 3px 10px;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: bold;
      margin-left: 10px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      animation: pulse 2s ease-in-out infinite;
      cursor: help;
      position: relative;
    }
    
    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.7; }
      100% { opacity: 1; }
    }
    
    .existing-item-warning {
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: #333;
      color: #fff;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 0.85rem;
      white-space: nowrap;
      margin-bottom: 5px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      z-index: 1000;
      text-transform: none;
      font-weight: normal;
      letter-spacing: normal;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }
    
    .existing-item-warning::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 6px solid transparent;
      border-top-color: #333;
    }
    
    .existing-item-indicator:hover .existing-item-warning {
      opacity: 1;
    }
    
    /* Unchanged existing items - subdued appearance */
    tr.unchanged-item {
      opacity: 0.5;
      background: rgba(128, 128, 128, 0.1) !important;
    }
    
    tr.unchanged-item:hover {
      opacity: 0.7;
    }
    
    tr.unchanged-item td {
      color: #888;
    }
    
    tr.unchanged-item input,
    tr.unchanged-item select,
    tr.unchanged-item textarea {
      opacity: 0.7;
    }
    
    .unchanged-indicator {
      display: inline-block;
      background: #666;
      color: #ccc;
      padding: 3px 10px;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: normal;
      margin-left: 10px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    /* Conflict field highlighting */
    .conflict-field {
      background: rgba(255, 152, 0, 0.2) !important;
      border: 1px solid #FF9800 !important;
      cursor: pointer;
      position: relative;
    }
    
    .conflict-field:hover {
      background: rgba(255, 152, 0, 0.3) !important;
      border-color: #FFB74D !important;
    }
    
    .conflict-field::after {
      content: '';
      position: absolute;
      right: 2px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 0.8rem;
      opacity: 0.8;
    }
    
    /* Conflict resolution modal */
    .conflict-modal {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: #2d2d2d;
      border: 2px solid #FF9800;
      border-radius: 12px;
      padding: 20px;
      z-index: 10001;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      max-width: 500px;
      width: 90%;
    }
    
    .conflict-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      z-index: 10000;
    }
    
    .conflict-modal h3 {
      color: #FFD700;
      margin: 0 0 20px 0;
      font-size: 1.2rem;
    }
    
    .conflict-options {
      display: flex;
      gap: 20px;
      margin: 20px 0;
    }
    
    .conflict-option {
      flex: 1;
      padding: 15px;
      border: 2px solid #444;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
    }
    
    .conflict-option:hover {
      border-color: #FFD700;
      background: rgba(255, 215, 0, 0.1);
    }
    
    .conflict-option.old-value {
      border-color: #4CAF50;
    }
    
    .conflict-option.new-value {
      border-color: #FF9800;
    }
    
    .conflict-option-label {
      font-size: 0.8rem;
      color: #999;
      margin-bottom: 5px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .conflict-option-value {
      font-size: 1.1rem;
      color: #e0e0e0;
      font-weight: 500;
    }
  </style>
  <script src="/safe-html.js"></script>
  <script src="/csrf-helper.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/iconify-icon@2.1.0/dist/iconify-icon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/twemoji@latest/dist/twemoji.min.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>
  <div id="app">
    <header class="account-header">
      <div class="header-content">
        <a href="/" class="back-link"> Back to Maps</a>
        <h1>Account Settings</h1>
      </div>
    </header>

    <div class="account-container" id="account-content" style="display: none;">
      <div class="account-sidebar">
        <button class="nav-item active"> Profile</button>
        <button class="nav-item"> Preferences</button>
        <button class="nav-item"> Privacy & Security</button>
        <button class="nav-item"> Custom POIs</button>
        <button class="nav-item" id="voting-tab-btn"> Voting</button>
        <button class="nav-item" id="admin-tab-btn" style="display: none;"> Admin</button>
      </div>

      <div class="account-content">
        <div id="message"></div>
        
        <!-- Profile Tab -->
        <div id="profile-tab" class="tab-content active">
          <h2>Profile Information</h2>
          
          <!-- Main Profile Card -->
          <div class="profile-card">
            <div class="profile-header">
              <img id="user-avatar" class="profile-avatar" alt="">
              <div style="flex: 1;">
                <h3 id="user-name"></h3>
                <p id="user-email"></p>
              </div>
              <span id="admin-badge" class="admin-badge" style="display: none;">Administrator</span>
            </div>
            
            <!-- XP and Level Info -->
            <div class="profile-xp-section">
              <div class="xp-level-display">
                <div class="level-badge-large">
                  <div class="level-number" id="user-level">1</div>
                  <div class="level-label">Level</div>
                </div>
                <div class="xp-info-display">
                  <div class="xp-text">
                    <span class="current-xp" id="user-current-xp">0</span>
                    <span class="separator">/</span>
                    <span class="next-level-xp" id="user-next-level-xp">100</span>
                    <span class="xp-label">XP</span>
                  </div>
                  <div class="xp-bar-wrapper">
                    <div class="xp-bar-background">
                      <div class="xp-bar-fill" id="user-xp-bar" style="width: 0%;"></div>
                    </div>
                  </div>
                  <div class="xp-rank" id="user-rank">Rank: #--</div>
                </div>
              </div>
            </div>
          </div>
          
          <!-- Statistics Section -->
          <div class="profile-stats-grid">
            <div class="stat-card">
              <div class="stat-icon"></div>
              <div class="stat-info">
                <div class="stat-value" id="total-pois">0</div>
                <div class="stat-label">POIs Created</div>
              </div>
            </div>
            <div class="stat-card">
              <div class="stat-icon"></div>
              <div class="stat-info">
                <div class="stat-value" id="approved-pois">0</div>
                <div class="stat-label">Approved POIs</div>
              </div>
            </div>
            <div class="stat-card">
              <div class="stat-icon"></div>
              <div class="stat-info">
                <div class="stat-value" id="total-votes">0</div>
                <div class="stat-label">Votes Cast</div>
              </div>
            </div>
          </div>
          
          <!-- Donations Section -->
          <div class="profile-section" style="margin-top: 2rem;">
            <h3 style="color: #FFD700; margin-bottom: 1.5rem;">Your Donations</h3>
            
            <!-- Donate Button -->
            <div style="text-align: center; margin-bottom: 1.5rem;">
              <a href="https://ko-fi.com/valorith" target="_blank" class="donate-button" style="display: inline-block; padding: 0.75rem 1.5rem; background: #4a7c59; color: #FFD700; text-decoration: none; border-radius: 8px; font-weight: bold; transition: all 0.3s; border: 2px solid #FFD700; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">
                 Donate to the project!
              </a>
            </div>
            
            <div id="user-donations-loading" style="text-align: center; padding: 2rem; color: #999;">
              Loading donation history...
            </div>
            <div id="user-donations-content" style="display: none;">
              <!-- Donation Tier Progress -->
              <div id="donation-tier-progress" class="tier-progress-card" style="background: #3a3a3a; border-radius: 8px; padding: 1.5rem; margin-bottom: 1.5rem; border: 1px solid #444; position: relative;">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 1.5rem;">
                  <h4 style="color: #FFA500; margin: 0;">Tier Progress</h4>
                  <div id="current-tier-badge" class="tier-badge-large" style="display: none;">
                    <div class="tier-icon" id="current-tier-icon"></div>
                    <div class="tier-name" id="current-tier-name">Bronze</div>
                  </div>
                </div>
                
                <div class="progress-container" style="margin-bottom: 1rem;">
                  <div class="progress-labels" style="display: flex; justify-content: space-between; margin-bottom: 0.5rem; font-size: 0.9rem;">
                    <span style="color: #999;">Donated $<span id="progress-current-amount">0</span></span>
                    <span id="next-tier-info" style="color: #FFD700; cursor: help;">
                      <span id="next-tier-name">Loading...</span> - $<span id="next-tier-amount">0</span>
                    </span>
                  </div>
                  <div class="progress-bar-container" style="background: #2d2d2d; height: 24px; border-radius: 12px; overflow: hidden; position: relative;">
                    <div id="user-tier-progress-bar" style="background: linear-gradient(90deg, #FFD700, #FFA500); height: 100%; width: 0%; transition: width 0.5s ease;"></div>
                    <div class="progress-percentage" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-weight: bold; font-size: 0.85rem; text-shadow: 1px 1px 2px rgba(0,0,0,0.5);">
                      <span id="progress-percentage">0</span>%
                    </div>
                  </div>
                  <div id="tier-complete-message" style="display: none; text-align: center; margin-top: 0.5rem; color: #4a7c59;">
                    <span style="font-size: 1.2rem;"></span> Highest tier achieved!
                  </div>
                </div>
                
                <!-- Next Tier Perks Tooltip -->
                <div id="next-tier-perks" style="display: none; position: absolute; background: #2d2d2d; padding: 1rem; border-radius: 8px; border: 1px solid #555; box-shadow: 0 4px 12px rgba(0,0,0,0.5); z-index: 1000; min-width: 200px; max-width: 300px;">
                  <h5 style="color: #FFD700; margin-bottom: 0.5rem; font-size: 0.9rem;">Next Tier Perks:</h5>
                  <ul id="perks-list" style="margin: 0; padding-left: 1.5rem; color: #e0e0e0; font-size: 0.85rem;"></ul>
                </div>
              </div>
              
              <div id="user-donation-stats" class="donation-stats-card" style="background: #3a3a3a; border-radius: 8px; padding: 1.5rem; margin-bottom: 1.5rem; border: 1px solid #444;">
                <h4 style="color: #FFA500; margin-bottom: 1rem;">Total Support</h4>
                <div style="display: flex; align-items: baseline; gap: 0.5rem; margin-bottom: 0.5rem;">
                  <span style="font-size: 2rem; font-weight: bold; color: #FFD700; font-family: 'Cinzel', serif;">$<span id="user-total-donated">0.00</span></span>
                  <span style="color: #999;">USD</span>
                </div>
                <div style="color: #999; font-size: 0.9rem;">
                  <span id="user-donation-count">0</span> donation<span id="user-donation-plural">s</span>
                </div>
              </div>
              
              <div id="user-donations-list" style="display: none;">
                <h4 style="color: #FFA500; margin-bottom: 1rem;">Donation History</h4>
                <div id="user-donations-table-container"></div>
              </div>
              
              <div id="no-user-donations" style="display: none; text-align: center; padding: 2rem; color: #999;">
                <p style="margin-bottom: 1rem;">No donations found for your account.</p>
                <p style="font-size: 0.9rem;">Make sure your Ko-fi donation name matches your nickname: <strong id="donation-nickname-hint"></strong></p>
              </div>
            </div>
          </div>
        </div>

        <!-- Preferences Tab -->
        <div id="preferences-tab" class="tab-content">
          <h2>Preferences</h2>
          
          <div class="preference-section">
            <h3>Profile Customization</h3>
            
            <!-- Profile Picture -->
            <div style="margin-bottom: 2rem;">
              <h4 style="color: #FFD700; margin-bottom: 1rem;">Profile Picture</h4>
              <div style="display: flex; align-items: center; gap: 2rem;">
                <div style="position: relative;">
                  <img id="preview-avatar" style="width: 100px; height: 100px; border-radius: 50%; border: 3px solid #4a7c59; object-fit: cover;">
                  <div id="avatar-loading" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); border-radius: 50%; align-items: center; justify-content: center; flex-direction: column;">
                    <div style="color: white; font-size: 0.9rem; margin-bottom: 8px;">Uploading...</div>
                    <div style="width: 80%; background: rgba(255,255,255,0.2); height: 6px; border-radius: 3px; overflow: hidden;">
                      <div id="upload-progress-bar" style="width: 0%; height: 100%; background: #4a7c59; transition: width 0.3s ease;"></div>
                    </div>
                    <div id="upload-status" style="color: white; font-size: 0.8rem; margin-top: 8px;"></div>
                  </div>
                </div>
                <div style="flex: 1;">
                  <p style="color: #999; margin-bottom: 1rem; font-size: 0.9rem;">
                    Upload a custom profile picture. Images will be resized to 200x200 pixels.
                  </p>
                  <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                    <label for="avatar-upload" class="btn btn-sm" style="cursor: pointer;">
                       Upload New Picture
                    </label>
                    <input type="file" id="avatar-upload" accept="image/*" style="display: none;" onchange="handleAvatarUpload(event)">
                    <button id="reset-avatar-btn" class="btn secondary-btn btn-sm" style="display: none;">
                       Reset to Google Picture
                    </button>
                  </div>
                  <p style="color: #666; margin-top: 0.5rem; font-size: 0.85rem;">
                    Maximum file size: 5MB. Supported formats: JPG, PNG, GIF, WebP
                  </p>
                </div>
              </div>
            </div>
            
            <!-- Nickname -->
            <div style="margin-bottom: 2rem;">
              <h4 style="color: #FFD700; margin-bottom: 1rem;">Display Name (Nickname)</h4>
              <p style="color: #999; margin-bottom: 1rem; font-size: 0.9rem;">
                Set a nickname that will be displayed instead of your real name throughout the application.
              </p>
              <div style="display: flex; gap: 1rem; align-items: center; max-width: 500px;">
                <input type="text" id="nickname-input" placeholder="Enter nickname (optional)" maxlength="50" 
                       style="flex: 1; padding: 0.5rem; border: 1px solid #555; border-radius: 4px; 
                              background: #2d2d2d; color: #e0e0e0;">
                <button class="btn btn-sm" id="save-nickname-btn">Save</button>
              </div>
              <p style="color: #666; margin-top: 0.5rem; font-size: 0.85rem;">
                Leave empty to use your real name. 3-50 characters, letters, numbers, spaces, underscores, and hyphens only.
              </p>
              <p id="nickname-error" style="color: #dc3545; margin-top: 0.5rem; font-size: 0.85rem; display: none;"></p>
            </div>
          </div>
          
          <div class="preference-section">
            <h3>Display Settings</h3>
            <div style="text-align: center; padding: 2rem;">
              <div style="display: inline-block; background: #4a7c59; color: white; padding: 0.75rem 2rem; border-radius: 30px; font-size: 1.1rem; font-weight: 500; box-shadow: 0 4px 12px rgba(74, 124, 89, 0.3);">
                 More Options Coming Soon
              </div>
              <p style="margin-top: 1rem; color: #999; font-size: 0.95rem;">
                Theme customization and other display options will be available in a future update.
              </p>
            </div>
          </div>
        </div>

        <!-- Privacy Tab -->
        <div id="privacy-tab" class="tab-content">
          <h2>Privacy & Security</h2>
          <div class="preference-section">
            <h3>Data & Privacy</h3>
            <p>Your data is stored securely and is never shared with third parties.</p>
            <button class="btn danger-btn" id="delete-account-btn">Delete Account</button>
          </div>
          
          <div class="preference-section">
            <h3>Active Sessions</h3>
            <p>Manage your active login sessions across devices.</p>
            <button class="btn secondary-btn" id="logout-all-btn">Log Out All Devices</button>
          </div>
        </div>

        <!-- Custom POIs Tab -->
        <div id="custom-pois-tab" class="tab-content">
          <h2 style="color: #FFD700;">Custom Points of Interest (POI)</h2>
          <p style="color: #999; margin-bottom: 2rem;">Create personal markers on maps that only you can see. Share them with friends or keep them private.</p>
          
          <div id="custom-pois-loading" style="text-align: center; padding: 2rem;">
            Loading custom POIs...
          </div>
          
          <div id="custom-pois-content" style="display: none;">
            <h3 class="sub-header">My POIs</h3>
            
            <table id="custom-pois-table" class="admin-table">
              <thead>
                <tr>
                  <th>Icon</th>
                  <th>Name</th>
                  <th>Map</th>
                  <th>Created</th>
                  <th>Status</th>
                  <th>Shared</th>
                  <th>Actions</th>
                </tr>
              </thead>
              <tbody id="custom-pois-tbody"></tbody>
            </table>
            
            <!-- My POIs Pagination -->
            <div id="my-pois-pagination" class="pagination" style="display: none;">
              <button class="pagination-btn" id="my-pois-prev">Previous</button>
              <span class="pagination-info" id="my-pois-page-info">Page 1 of 1</span>
              <button class="pagination-btn" id="my-pois-next">Next</button>
            </div>
            
            <!-- Shared POIs Section -->
            <div id="shared-pois-section" style="display: block; margin-top: 3rem;">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                <div>
                  <h3 class="sub-header" style="margin-bottom: 0.5rem;">Shared POIs</h3>
                  <p style="color: #999; font-size: 0.9rem; margin: 0;">POIs that other users have shared with you.</p>
                </div>
                <button class="btn btn-sm" onclick="showAddSharedPOIModal()" style="background: #4a7c59;">
                  <span style="margin-right: 0.5rem;"></span>Add Shared POI
                </button>
              </div>
              
              <table id="shared-pois-table" class="admin-table">
                <thead>
                  <tr>
                    <th>Icon</th>
                    <th>Name</th>
                    <th>Map</th>
                    <th>Shared By</th>
                    <th>Status</th>
                    <th>Actions</th>
                  </tr>
                </thead>
                <tbody id="shared-pois-tbody"></tbody>
              </table>
              
              <!-- Shared POIs Pagination -->
              <div id="shared-pois-pagination" class="pagination" style="display: none;">
                <button class="pagination-btn" id="shared-pois-prev">Previous</button>
                <span class="pagination-info" id="shared-pois-page-info">Page 1 of 1</span>
                <button class="pagination-btn" id="shared-pois-next">Next</button>
              </div>
            </div>
            
          </div>
        </div>

        <!-- Voting Tab -->
        <div id="voting-tab" class="tab-content">
          <h2 style="color: #FFD700;">Community Voting</h2>
          <p style="color: #999; margin-bottom: 2rem;">Vote on proposed changes to POIs, NPCs, and Items. Changes with +10 votes are automatically approved!</p>
          
          <!-- Voting Stats -->
          <div class="voting-stats-container">
            <div class="voting-stat-card" onclick="filterByCard('mine')" data-filter-type="mine" style="padding-bottom: 1rem;">
              <div class="stat-main">
                <div class="stat-icon"></div>
                <div class="stat-info">
                  <div class="stat-value" id="my-proposals-count">0</div>
                  <div class="stat-label">My Proposals</div>
                </div>
              </div>
            </div>
            <div class="voting-stat-card" onclick="filterByCard('add_poi')" data-filter-type="add_poi">
              <div class="stat-main">
                <div class="stat-icon"></div>
                <div class="stat-info">
                  <div class="stat-value" id="add-poi-total">0</div>
                  <div class="stat-label">New POIs</div>
                </div>
              </div>
              <div class="stat-pending" id="add-poi-pending">0 pending vote!</div>
            </div>
            <div class="voting-stat-card" onclick="filterByCard('edit_poi')" data-filter-type="edit_poi">
              <div class="stat-main">
                <div class="stat-icon"></div>
                <div class="stat-info">
                  <div class="stat-value" id="edit-poi-total">0</div>
                  <div class="stat-label">POI Edits</div>
                </div>
              </div>
              <div class="stat-pending" id="edit-poi-pending">0 pending vote!</div>
            </div>
            <div class="voting-stat-card" onclick="filterByCard('move_poi')" data-filter-type="move_poi">
              <div class="stat-main">
                <div class="stat-icon"></div>
                <div class="stat-info">
                  <div class="stat-value" id="move-poi-total">0</div>
                  <div class="stat-label">POI Moves</div>
                </div>
              </div>
              <div class="stat-pending" id="move-poi-pending">0 pending vote!</div>
            </div>
            <div class="voting-stat-card" onclick="filterByCard('delete_poi')" data-filter-type="delete_poi">
              <div class="stat-main">
                <div class="stat-icon"></div>
                <div class="stat-info">
                  <div class="stat-value" id="delete-poi-total">0</div>
                  <div class="stat-label">POI Deletions</div>
                </div>
              </div>
              <div class="stat-pending" id="delete-poi-pending">0 pending vote!</div>
            </div>
            <div class="voting-stat-card" onclick="filterByCard('add_npc')" data-filter-type="add_npc">
              <div class="stat-main">
                <div class="stat-icon"></div>
                <div class="stat-info">
                  <div class="stat-value" id="add-npc-total">0</div>
                  <div class="stat-label">New NPCs</div>
                </div>
              </div>
              <div class="stat-pending" id="add-npc-pending">0 pending vote!</div>
            </div>
            <div class="voting-stat-card" onclick="filterByCard('edit_npc')" data-filter-type="edit_npc">
              <div class="stat-main">
                <div class="stat-icon"></div>
                <div class="stat-info">
                  <div class="stat-value" id="edit-npc-total">0</div>
                  <div class="stat-label">NPC Edits</div>
                </div>
              </div>
              <div class="stat-pending" id="edit-npc-pending">0 pending vote!</div>
            </div>
            <div class="voting-stat-card" onclick="filterByCard('change_loot')" data-filter-type="change_loot">
              <div class="stat-main">
                <div class="stat-icon"></div>
                <div class="stat-info">
                  <div class="stat-value" id="change-loot-total">0</div>
                  <div class="stat-label">Loot Changes</div>
                </div>
              </div>
              <div class="stat-pending" id="change-loot-pending">0 pending vote!</div>
            </div>
            <div class="voting-stat-card" onclick="filterByCard('add_item')" data-filter-type="add_item">
              <div class="stat-main">
                <div class="stat-icon"></div>
                <div class="stat-info">
                  <div class="stat-value" id="add-item-total">0</div>
                  <div class="stat-label">New Items</div>
                </div>
              </div>
              <div class="stat-pending" id="add-item-pending">0 pending vote!</div>
            </div>
            <div class="voting-stat-card" onclick="filterByCard('edit_item')" data-filter-type="edit_item">
              <div class="stat-main">
                <div class="stat-icon"></div>
                <div class="stat-info">
                  <div class="stat-value" id="edit-item-total">0</div>
                  <div class="stat-label">Item Edits</div>
                </div>
              </div>
              <div class="stat-pending" id="edit-item-pending">0 pending vote!</div>
            </div>
          </div>

          <!-- Filter Controls -->
          <div class="voting-controls">
            <div class="filter-group">
              <label>Type:</label>
              <select id="proposal-type-filter" class="form-control">
                <option value="">All Types</option>
                <option value="add_poi">New POI</option>
                <option value="edit_poi">Edit POI</option>
                <option value="move_poi">Move POI</option>
                <option value="delete_poi">Delete POI</option>
                <option value="add_npc">New NPC</option>
                <option value="edit_npc">Edit NPC</option>
                <option value="change_loot">Change NPC Loot</option>
                <option value="add_item">New Item</option>
                <option value="edit_item">Edit Item</option>
              </select>
            </div>
            <div class="filter-group">
              <label>Show:</label>
              <select id="proposal-filter" class="form-control">
                <option value="all">All Proposals</option>
                <option value="mine">My Proposals</option>
                <option value="not-voted" selected>Not Voted</option>
              </select>
            </div>
            <div class="filter-group">
              <label>Sort by:</label>
              <select id="proposal-sort" class="form-control" onchange="sortProposals()">
                <option value="newest">Newest First</option>
                <option value="oldest">Oldest First</option>
                <option value="score-high">Highest Score</option>
                <option value="score-low">Lowest Score</option>
                <option value="votes-most">Most Votes</option>
                <option value="votes-least">Least Votes</option>
                <option value="name-asc">Name (A-Z)</option>
                <option value="name-desc">Name (Z-A)</option>
                <option value="type">Type</option>
              </select>
            </div>
            <div class="filter-group">
              <button class="btn btn-sm" onclick="refreshProposals()" style="background: #4a7c59; padding: 0.5rem 1rem;">
                <span style="margin-right: 0.5rem;"></span>Refresh
              </button>
            </div>
            <div class="filter-group">
              <button class="btn btn-sm" onclick="resetProposalFilters()" style="background: #666; padding: 0.5rem 1rem;">
                <span style="margin-right: 0.5rem;"></span>Reset
              </button>
            </div>
          </div>

          <!-- Proposals List -->
          <div id="proposals-loading" style="text-align: center; padding: 2rem;">
            Loading proposals...
          </div>
          
          <div id="proposals-container" style="display: none;">
            <div id="proposals-list" class="proposals-list"></div>
            
            <!-- Pagination -->
            <div id="proposals-pagination" class="pagination" style="display: none;">
              <button class="pagination-btn" id="proposals-prev">Previous</button>
              <span class="pagination-info" id="proposals-page-info">Page 1 of 1</span>
              <button class="pagination-btn" id="proposals-next">Next</button>
            </div>
          </div>
        </div>

        <!-- Admin Tab -->
        <div id="admin-tab" class="tab-content">
          <h2 style="color: #FFD700;">Admin Settings</h2>
          
          <div class="admin-section collapsed" id="xp-config-section">
            <div class="admin-section-header" onclick="toggleAdminSection('xp-config-section')">
              <div>
                <h3>XP Configuration</h3>
                <p style="color: #999; margin: 0.25rem 0 0 0; font-size: 0.9rem;">Configure experience points awarded for various actions</p>
              </div>
              <span class="collapse-icon"></span>
            </div>
            <div class="admin-section-content">
              <div id="xp-config-loading" style="text-align: center; padding: 2rem;">
                Loading XP configuration...
              </div>
              
              <div id="xp-config-content" style="display: none;">
                <table class="admin-table">
                  <thead>
                    <tr>
                      <th>Action</th>
                      <th>Description</th>
                      <th>XP Value</th>
                      <th>Actions</th>
                    </tr>
                  </thead>
                  <tbody id="xp-config-tbody"></tbody>
                </table>
              </div>
            </div>
          </div>
          
          <!-- Welcome Message Management -->
          <div class="admin-section collapsed" id="welcome-message-section">
            <div class="admin-section-header" onclick="toggleAdminSection('welcome-message-section')">
              <div>
                <h3>Welcome Message</h3>
                <p style="color: #999; margin: 0.25rem 0 0 0; font-size: 0.9rem;">Configure the welcome message shown to users on new sessions</p>
              </div>
              <span class="collapse-icon"></span>
            </div>
            <div class="admin-section-content">
              <div id="welcome-message-loading" style="text-align: center; padding: 2rem;">
                Loading welcome message...
              </div>
              
              <div id="welcome-message-content" style="display: none;">
                <div style="margin-bottom: 1rem;">
                  <p style="color: #999; font-size: 0.9rem; margin-bottom: 0.5rem;">
                    <strong>Note:</strong> This message will appear once per browser session. Supports markdown formatting.
                  </p>
                </div>
                
                <div style="margin-bottom: 1.5rem;">
                  <label for="welcome-message-input" style="color: #e0e0e0; font-weight: 500; margin-bottom: 0.5rem; display: block;">
                    Welcome Message
                  </label>
                  <textarea 
                    id="welcome-message-input" 
                    rows="8" 
                    placeholder="Enter your welcome message here. You can use markdown formatting..."
                    style="width: 100%; padding: 0.75rem; border: 1px solid #555; border-radius: 4px; 
                           background: #2d2d2d; color: #e0e0e0; font-family: inherit; resize: vertical;
                           box-sizing: border-box;"
                  ></textarea>
                </div>
                
                <div style="margin-top: 1rem;">
                  <div style="background: #2d2d2d; border: 1px solid #444; border-radius: 4px; padding: 0.75rem;">
                    <div style="color: #7fb069; font-weight: 500; margin-bottom: 0.75rem;">Markdown Formatting</div>
                    <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                      <button onclick="applyMarkdownFormat('bold')" class="markdown-btn" title="Bold (Ctrl+B)">
                        <strong>B</strong>
                      </button>
                      <button onclick="applyMarkdownFormat('italic')" class="markdown-btn" title="Italic (Ctrl+I)">
                        <em>I</em>
                      </button>
                      <button onclick="applyMarkdownFormat('code')" class="markdown-btn" title="Code">
                        <code>&lt;/&gt;</code>
                      </button>
                      <button onclick="applyMarkdownFormat('link')" class="markdown-btn" title="Link">
                        
                      </button>
                      <div style="width: 1px; background: #555; margin: 0 0.25rem;"></div>
                      <button onclick="applyMarkdownFormat('h1')" class="markdown-btn" title="Heading 1">
                        H1
                      </button>
                      <button onclick="applyMarkdownFormat('h2')" class="markdown-btn" title="Heading 2">
                        H2
                      </button>
                      <button onclick="applyMarkdownFormat('h3')" class="markdown-btn" title="Heading 3">
                        H3
                      </button>
                      <div style="width: 1px; background: #555; margin: 0 0.25rem;"></div>
                      <button onclick="applyMarkdownFormat('ul')" class="markdown-btn" title="Bullet List">
                         List
                      </button>
                      <button onclick="applyMarkdownFormat('ol')" class="markdown-btn" title="Numbered List">
                        1. List
                      </button>
                      <button onclick="applyMarkdownFormat('quote')" class="markdown-btn" title="Quote">
                        &ldquo; &rdquo;
                      </button>
                    </div>
                  </div>
                </div>
                
                <div style="margin-top: 1.5rem; display: flex; gap: 1rem; justify-content: flex-end;">
                  <button onclick="clearWelcomeMessage()" class="secondary-btn">
                    Clear Message
                  </button>
                  <button onclick="previewWelcomeMessage()" class="secondary-btn">
                    <span style="margin-right: 0.5rem;"></span>Preview
                  </button>
                  <button onclick="saveWelcomeMessage()" class="primary-btn">
                    <span style="margin-right: 0.5rem;"></span>Save Message
                  </button>
                </div>
              </div>
            </div>
          </div>
          
          <div class="admin-section collapsed" id="user-management-section">
            <div class="admin-section-header" onclick="toggleAdminSection('user-management-section')">
              <div>
                <h3>User Management</h3>
                <p style="color: #999; margin: 0.25rem 0 0 0; font-size: 0.9rem;">View and manage all user accounts</p>
              </div>
              <span class="collapse-icon"></span>
            </div>
            <div class="admin-section-content">
              <div id="user-management-loading" style="text-align: center; padding: 2rem;">
                Loading users...
              </div>
              
              <div id="user-management-content" style="display: none;">
                <div style="margin-bottom: 1rem; display: flex; gap: 0.5rem; align-items: stretch;">
                  <input type="text" id="user-search" placeholder="Search users by name or email..." 
                         style="width: 300px; padding: 0.5rem; border: 1px solid #555; border-radius: 4px; 
                                background: #2d2d2d; color: #e0e0e0;"
                         onkeyup="searchUsers()">
                  <button onclick="refreshUsers()" style="background: transparent; border: none; color: #999; 
                          padding: 0.5rem; cursor: pointer; 
                          display: flex; align-items: center; justify-content: center;
                          transition: all 0.2s; height: 100%;" 
                          onmouseover="this.style.color='#FFD700'; this.style.transform='rotate(180deg)';" 
                          onmouseout="this.style.color='#999'; this.style.transform='rotate(0deg)';"
                          title="Refresh user list">
                    <span style="font-size: 1.25rem;"></span>
                  </button>
                </div>
                
                <table class="admin-table">
                  <thead>
                    <tr>
                      <th>Avatar</th>
                      <th>Name</th>
                      <th>Email</th>
                      <th>XP</th>
                      <th>POIs</th>
                      <th>Status</th>
                      <th>Joined</th>
                      <th>Actions</th>
                    </tr>
                  </thead>
                  <tbody id="users-tbody"></tbody>
                </table>
                
                <!-- Users Pagination -->
                <div id="users-pagination" class="pagination" style="display: none;">
                  <button class="pagination-btn" id="users-prev">Previous</button>
                  <span class="pagination-info" id="users-page-info">Page 1 of 1</span>
                  <button class="pagination-btn" data-action="changeUsersPage" data-args="1" id="users-next">Next</button>
                </div>
              </div>
            </div>
          </div>
          
          <!-- POI Type Management -->
          <div class="admin-section collapsed" id="poi-type-management-section">
            <div class="admin-section-header" onclick="toggleAdminSection('poi-type-management-section')">
              <div>
                <h3>POI Type Management</h3>
                <p style="color: #999; margin: 0.25rem 0 0 0; font-size: 0.9rem;">Manage POI types and their icons</p>
              </div>
              <span class="collapse-icon"></span>
            </div>
            <div class="admin-section-content">
              <div style="margin-bottom: 1rem;">
                <button onclick="showAddPOITypeModal()" class="primary-btn">
                  <span style="margin-right: 0.5rem;"></span>
                  Add POI Type
                </button>
              </div>
              
              <div id="poi-types-loading" style="text-align: center; padding: 2rem;">
                Loading POI types...
              </div>
              
              <div id="poi-types-content" style="display: none;">
                <!-- Pagination info -->
                <div id="poi-types-pagination-info" style="text-align: center; margin-bottom: 1rem; color: #666;"></div>
                
                <table class="admin-table">
                  <thead>
                    <tr>
                      <th width="60">Icon</th>
                      <th>Name</th>
                      <th width="100">Type</th>
                      <th width="80">Default</th>
                      <th width="80">Multi-Mob</th>
                      <th width="60">Order</th>
                      <th width="120">Actions</th>
                    </tr>
                  </thead>
                  <tbody id="poi-types-tbody"></tbody>
                </table>
                
                <!-- Pagination controls -->
                <div id="poi-types-pagination" style="display: none; text-align: center; margin-top: 1.5rem;"></div>
              </div>
            </div>
          </div>
          
          <!-- POI Editor -->
          <div class="admin-section collapsed" id="poi-editor-section">
            <div class="admin-section-header" onclick="toggleAdminSection('poi-editor-section')">
              <div>
                <h3>POI Editor</h3>
                <p style="color: #999; margin: 0.25rem 0 0 0; font-size: 0.9rem;">Edit POI data directly in a grid view</p>
              </div>
              <span class="collapse-icon"></span>
            </div>
            <div class="admin-section-content">
              <div style="margin-bottom: 1rem; display: flex; gap: 1rem; align-items: center; flex-wrap: wrap;">
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                  <label for="poi-map-filter" style="color: #e0e0e0;">Map:</label>
                  <select id="poi-map-filter" style="padding: 0.5rem; border: 1px solid #555; border-radius: 4px; background: #2d2d2d; color: #e0e0e0;" onchange="filterPOIsByMap()">
                    <option value="all">All Maps</option>
                  </select>
                </div>
                <input 
                  type="text" 
                  id="poi-search" 
                  class="poi-editor-search" 
                  placeholder="Search POIs by name, description, or ID..."
                  onkeyup="searchPOIs()"
                />
                <div style="display: flex; gap: 0.5rem; margin-left: auto;">
                  <button onclick="exportPOIsToCSV()" class="export-btn" title="Export filtered POIs to CSV">
                    <span></span>Export CSV
                  </button>
                  <button onclick="reloadPOIEditor()" class="secondary-btn" title="Reload from database">
                    <span style="margin-right: 0.5rem;"></span>Reload
                  </button>
                  <button id="poi-reset-btn" onclick="resetPOIChanges()" class="secondary-btn" disabled title="Undo all unsaved changes">
                    <span style="margin-right: 0.5rem;"></span>Reset
                  </button>
                  <button id="poi-save-btn" onclick="savePOIChanges()" class="primary-btn" disabled title="Save all changes">
                    <span style="margin-right: 0.5rem;"></span>Save Changes (<span id="poi-change-count">0</span>)
                  </button>
                </div>
              </div>
              
              <div class="poi-stats" style="margin-bottom: 1rem;">
                <div class="poi-stat">
                  <span>Total:</span>
                  <span class="poi-stat-value" id="poi-total-count">0</span>
                </div>
                <div class="poi-stat">
                  <span>Filtered:</span>
                  <span class="poi-stat-value" id="poi-filtered-count">0</span>
                </div>
                <div class="poi-stat">
                  <span>Pending Changes:</span>
                  <span class="poi-stat-value" id="poi-pending-count">0</span>
                </div>
              </div>
              
              <div id="poi-editor-loading" style="text-align: center; padding: 2rem;">
                Loading POIs...
              </div>
              
              <div id="poi-editor-content" style="display: none;">
                <!-- Pagination info -->
                <div id="poi-editor-pagination-info" style="text-align: center; margin-bottom: 1rem; color: #666;"></div>
                
                <div class="poi-editor-table-container" style="overflow-x: auto; border: 1px solid #444; border-radius: 8px;">
                  <table class="admin-table poi-editor-table" style="min-width: 1250px;">
                    <thead>
                      <tr>
                        <th style="width: 60px" data-sort="id">ID</th>
                        <th style="width: 200px" data-sort="name">Name</th>
                        <th style="width: 300px" data-sort="description">Description</th>
                        <th style="width: 180px" data-sort="poi_type_name">Type</th>
                        <th style="width: 60px">Icon</th>
                        <th style="width: 100px" data-sort="icon_size">Icon Size</th>
                        <th style="width: 110px" data-sort="npc_id">NPC ID</th>
                        <th style="width: 110px" data-sort="item_id">Item ID</th>
                        <th style="width: 150px" data-sort="created_by_name">Created By</th>
                        <th style="width: 120px" data-sort="map_name">Map</th>
                        <th style="width: 60px">Delete</th>
                      </tr>
                    </thead>
                    <tbody id="poi-editor-tbody"></tbody>
                  </table>
                </div>
                
                <!-- Pagination controls -->
                <div id="poi-editor-pagination" style="display: none; text-align: center; margin-top: 1.5rem;"></div>
              </div>
            </div>
          </div>
          
          <!-- Item Editor -->
          <div class="admin-section collapsed" id="item-editor-section">
            <div class="admin-section-header" onclick="toggleAdminSection('item-editor-section')">
              <div>
                <h3>Item Editor</h3>
                <p style="color: #999; margin: 0.25rem 0 0 0; font-size: 0.9rem;">Manage game items and their stats</p>
              </div>
              <span class="collapse-icon"></span>
            </div>
            <div class="admin-section-content">
              <div style="margin-bottom: 1rem; display: flex; gap: 1rem; align-items: center; flex-wrap: wrap;">
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                  <label for="item-type-filter" style="color: #e0e0e0;">Type:</label>
                  <select id="item-type-filter" style="padding: 0.5rem; border: 1px solid #555; border-radius: 4px; background: #2d2d2d; color: #e0e0e0;" onchange="filterItemsByType()">
                    <option value="all">All Types</option>
                    <option value="weapon">Weapons</option>
                    <option value="armor">Armor</option>
                    <option value="consumable">Consumables</option>
                    <option value="misc">Miscellaneous</option>
                  </select>
                </div>
                <input 
                  type="text" 
                  id="item-search" 
                  class="item-editor-search" 
                  placeholder="Search items by name, description, or ID..."
                  onkeyup="searchItems()"
                  style="flex: 1; padding: 0.5rem; border: 1px solid #555; border-radius: 4px; background: #2d2d2d; color: #e0e0e0;"
                />
                <div style="display: flex; gap: 0.5rem; margin-left: auto;">
                  <button onclick="showBatchImportModal()" class="primary-btn" title="Batch add items">
                    <span style="margin-right: 0.5rem;"></span>Batch Add
                  </button>
                  <button onclick="showAddItemForm()" class="primary-btn" title="Add new item">
                    <span style="margin-right: 0.5rem;"></span>Add Item
                  </button>
                  <button onclick="exportItemsToCSV()" class="export-btn" title="Export items to CSV">
                    <span></span>Export CSV
                  </button>
                  <button onclick="reloadItemEditor()" class="secondary-btn" title="Reload from database">
                    <span style="margin-right: 0.5rem;"></span>Reload
                  </button>
                  <button id="item-reset-btn" onclick="resetItemChanges()" class="secondary-btn" disabled title="Undo all unsaved changes">
                    <span style="margin-right: 0.5rem;"></span>Reset
                  </button>
                  <button id="item-save-btn" onclick="saveItemChanges()" class="primary-btn" disabled title="Save all changes">
                    <span style="margin-right: 0.5rem;"></span>Save Changes (<span id="item-change-count">0</span>)
                  </button>
                </div>
              </div>
              
              <div class="item-stats" style="margin-bottom: 1rem; display: flex; gap: 2rem;">
                <div class="item-stat">
                  <span>Total:</span>
                  <span class="item-stat-value" id="item-total-count">0</span>
                </div>
                <div class="item-stat">
                  <span>Filtered:</span>
                  <span class="item-stat-value" id="item-filtered-count">0</span>
                </div>
              </div>
              
              <div id="item-editor-loading" style="text-align: center; padding: 2rem;">
                Loading items...
              </div>
              
              <div id="item-editor-content" style="display: none;">
                <!-- Pagination info -->
                <div id="item-editor-pagination-info" style="text-align: center; margin-bottom: 1rem; color: #666;"></div>
                
                <div class="item-editor-table-container" style="overflow-x: auto; border: 1px solid #444; border-radius: 8px;">
                  <table class="admin-table item-editor-table" style="min-width: 2460px;">
                    <thead>
                      <tr>
                        <th style="width: 50px" data-sort="id">ID</th>
                        <th style="width: 50px">Icon</th>
                        <th style="width: 150px" data-sort="name">Name</th>
                        <th style="width: 100px" data-sort="item_type">Type</th>
                        <th style="width: 120px" data-sort="slot">Slot(s)</th>
                        <th style="width: 60px" title="Weight">Weight</th>
                        <th style="width: 80px" title="Size">Size</th>
                        <th style="width: 100px" title="Skill">Skill</th>
                        <th style="width: 60px" title="Strength">STR</th>
                        <th style="width: 60px" title="Stamina">STA</th>
                        <th style="width: 60px" title="Agility">AGI</th>
                        <th style="width: 60px" title="Dexterity">DEX</th>
                        <th style="width: 60px" title="Wisdom">WIS</th>
                        <th style="width: 60px" title="Intelligence">INT</th>
                        <th style="width: 60px" title="Charisma">CHA</th>
                        <th style="width: 80px" title="Attack Speed">AS</th>
                        <th style="width: 60px" title="Damage">DMG</th>
                        <th style="width: 60px" title="Delay">Delay</th>
                        <th style="width: 80px" title="Health">HP</th>
                        <th style="width: 80px" title="Mana">MP</th>
                        <th style="width: 60px" title="Armor Class">AC</th>
                        <th style="width: 60px" title="Block">Block</th>
                        <th style="width: 60px" title="Cold Resistance">Cold</th>
                        <th style="width: 60px" title="Corruption Resistance">Corr</th>
                        <th style="width: 60px" title="Disease Resistance">Dis</th>
                        <th style="width: 60px" title="Electricity Resistance">Elec</th>
                        <th style="width: 60px" title="Fire Resistance">Fire</th>
                        <th style="width: 60px" title="Magic Resistance">Magic</th>
                        <th style="width: 60px" title="Poison Resistance">Poison</th>
                        <th style="width: 100px" data-sort="race">Race</th>
                        <th style="width: 100px" data-sort="class">Class</th>
                        <th style="width: 250px" data-sort="description">Description</th>
                        <th style="width: 100px">Actions</th>
                      </tr>
                    </thead>
                    <tbody id="item-editor-tbody"></tbody>
                  </table>
                </div>
                
                <!-- Pagination controls -->
                <div id="item-editor-pagination" style="display: none; text-align: center; margin-top: 1.5rem;"></div>
              </div>
            </div>
          </div>
          
          <!-- NPC Editor -->
          <div class="admin-section collapsed" id="npc-editor-section">
            <div class="admin-section-header" onclick="toggleAdminSection('npc-editor-section')">
              <div>
                <h3>NPC Editor</h3>
                <p style="color: #999; margin: 0.25rem 0 0 0; font-size: 0.9rem;">Manage NPCs, their stats, and loot tables</p>
              </div>
              <span class="collapse-icon"></span>
            </div>
            <div class="admin-section-content">
              <div style="margin-bottom: 1rem; display: flex; gap: 1rem; align-items: center; flex-wrap: wrap;">
                <div style="display: flex; gap: 0.5rem; align-items: center;">
                  <label for="npc-type-filter" style="color: #e0e0e0;">Type:</label>
                  <select id="npc-type-filter" style="padding: 0.5rem; border: 1px solid #555; border-radius: 4px; background: #2d2d2d; color: #e0e0e0;" onchange="filterNPCsByType()">
                    <option value="all">All Types</option>
                    <option value="humanoid">Humanoid</option>
                    <option value="beast">Beast</option>
                    <option value="undead">Undead</option>
                    <option value="elemental">Elemental</option>
                    <option value="dragon">Dragon</option>
                    <option value="demon">Demon</option>
                    <option value="construct">Construct</option>
                    <option value="aberration">Aberration</option>
                    <option value="plant">Plant</option>
                    <option value="fey">Fey</option>
                  </select>
                </div>
                <input 
                  type="text" 
                  id="npc-search" 
                  class="npc-editor-search" 
                  placeholder="Search NPCs by name, description, or ID..."
                  onkeyup="searchNPCs()"
                  style="flex: 1; padding: 0.5rem; border: 1px solid #555; border-radius: 4px; background: #2d2d2d; color: #e0e0e0;"
                />
                <div style="display: flex; gap: 0.5rem; margin-left: auto;">
                  <button onclick="showAddNPCForm()" class="primary-btn" title="Add new NPC">
                    <span style="margin-right: 0.5rem;"></span>Add NPC
                  </button>
                  <button onclick="showBatchNPCImport()" class="primary-btn" title="Batch import NPCs from wiki">
                    <span style="margin-right: 0.5rem;"></span>Batch Add
                  </button>
                  <button onclick="exportNPCsToCSV()" class="export-btn" title="Export NPCs to CSV">
                    <span></span>Export CSV
                  </button>
                  <button onclick="reloadNPCEditor()" class="secondary-btn" title="Reload from database">
                    <span style="margin-right: 0.5rem;"></span>Reload
                  </button>
                  <button id="npc-reset-btn" onclick="resetNPCChanges()" class="secondary-btn" disabled title="Undo all unsaved changes">
                    <span style="margin-right: 0.5rem;"></span>Reset
                  </button>
                  <button id="npc-save-btn" onclick="saveNPCChanges()" class="primary-btn" disabled title="Save all changes">
                    <span style="margin-right: 0.5rem;"></span>Save Changes (<span id="npc-change-count">0</span>)
                  </button>
                </div>
              </div>
              
              <div class="npc-stats" style="margin-bottom: 1rem;">
                <div class="npc-stat">
                  <span>Total:</span>
                  <span class="npc-stat-value" id="npc-total-count">0</span>
                </div>
                <div class="npc-stat">
                  <span>Filtered:</span>
                  <span class="npc-stat-value" id="npc-filtered-count">0</span>
                </div>
                <div class="npc-stat">
                  <span>Pending Changes:</span>
                  <span class="npc-stat-value" id="npc-pending-count">0</span>
                </div>
              </div>
              
              <div id="npc-editor-loading" style="text-align: center; padding: 2rem;">
                Loading NPCs...
              </div>
              
              <div id="npc-editor-content" style="display: none;">
                <!-- Pagination info -->
                <div id="npc-editor-pagination-info" style="text-align: center; margin-bottom: 1rem; color: #666;"></div>
                
                <div class="npc-editor-table-container" style="overflow-x: auto; border: 1px solid #444; border-radius: 8px;">
                  <table class="admin-table npc-editor-table" style="min-width: 2100px;">
                    <thead>
                      <tr>
                        <th style="width: 50px" data-sort="id">ID</th>
                        <th style="width: 80px" data-sort="npcid">NPC ID</th>
                        <th style="width: 120px" data-sort="npc_type">Type</th>
                        <th style="width: 200px" data-sort="name">Name</th>
                        <th style="width: 300px" data-sort="description">Description</th>
                        <th style="width: 200px">Loot</th>
                        <th style="width: 60px" title="Hit Points">HP</th>
                        <th style="width: 60px" title="Mana Points">MP</th>
                        <th style="width: 60px" title="Armor Class">AC</th>
                        <th style="width: 60px" title="Strength">STR</th>
                        <th style="width: 60px" title="Stamina">STA</th>
                        <th style="width: 60px" title="Agility">AGI</th>
                        <th style="width: 60px" title="Dexterity">DEX</th>
                        <th style="width: 60px" title="Wisdom">WIS</th>
                        <th style="width: 60px" title="Intelligence">INT</th>
                        <th style="width: 60px" title="Charisma">CHA</th>
                        <th style="width: 80px" title="Attack Speed">AS</th>
                        <th style="width: 80px" title="Minimum Damage">Min</th>
                        <th style="width: 80px" title="Maximum Damage">Max</th>
                        <th style="width: 60px" data-sort="level">Level</th>
                        <th style="width: 100px">Actions</th>
                      </tr>
                    </thead>
                    <tbody id="npc-editor-tbody"></tbody>
                  </table>
                </div>
                
                <!-- Pagination controls -->
                <div id="npc-editor-pagination" style="display: none; text-align: center; margin-top: 1.5rem;"></div>
              </div>
            </div>
          </div>
          
          <!-- Donation Tiers Management -->
          <div class="admin-section collapsed" id="donation-tiers-section">
            <div class="admin-section-header" onclick="toggleAdminSection('donation-tiers-section')">
              <div>
                <h3>Donation Tiers</h3>
                <p style="color: #999; margin: 0.25rem 0 0 0; font-size: 0.9rem;">Manage donation tiers and badges</p>
              </div>
              <span class="collapse-icon"></span>
            </div>
            <div class="admin-section-content">
              <div id="donation-tiers-loading" style="text-align: center; padding: 2rem;">
                Loading donation tiers...
              </div>
              
              <div id="donation-tiers-content" style="display: none;">
                <!-- Tier Statistics -->
                <div style="background: #3a3a3a; border-radius: 8px; padding: 1.5rem; margin-bottom: 2rem; border: 1px solid #444;">
                  <h4 style="color: #FFD700; margin-bottom: 1rem;">Tier Statistics</h4>
                  <div id="tier-statistics" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem;">
                    <!-- Tier stats will be populated here -->
                  </div>
                </div>
                
                <div style="margin-bottom: 1rem;">
                  <button onclick="showCreateDonationTierModal()" class="primary-btn">
                    <span style="margin-right: 0.5rem;"></span>
                    Add Donation Tier
                  </button>
                  <button onclick="recalculateAllDonationTiers()" class="secondary-btn" style="margin-left: 1rem;">
                    <span style="margin-right: 0.5rem;"></span>
                    Recalculate All User Tiers
                  </button>
                  <button onclick="showTestDonationModal()" class="btn btn-warning" style="margin-left: 1rem; background: #ff6b6b; border-color: #ff5252;">
                    <span style="margin-right: 0.5rem;"></span>
                    Test Donation
                  </button>
                  <button onclick="resetMyDonationStats()" class="btn btn-warning" style="margin-left: 1rem; background: #ff9f40; border-color: #ff6b1a;">
                    <span style="margin-right: 0.5rem;"></span>
                    Fix My Stats
                  </button>
                  <button onclick="simulateKofiWebhook()" class="btn btn-warning" style="margin-left: 1rem; background: #9c27b0; border-color: #7b1fa2;">
                    <span style="margin-right: 0.5rem;"></span>
                    Simulate Webhook
                  </button>
                </div>
                
                <table class="admin-table">
                  <thead>
                    <tr>
                      <th style="width: 40px;">Order</th>
                      <th style="width: 80px;">Badge</th>
                      <th>Name</th>
                      <th>Required Amount</th>
                      <th>Description</th>
                      <th>Users</th>
                      <th>Status</th>
                      <th>Actions</th>
                    </tr>
                  </thead>
                  <tbody id="donation-tiers-tbody"></tbody>
                </table>
              </div>
            </div>
          </div>
          
          <!-- Donations Management -->
          <div class="admin-section collapsed" id="donations-management-section">
            <div class="admin-section-header" onclick="toggleAdminSection('donations-management-section')">
              <div>
                <h3>Donations Management</h3>
                <p style="color: #999; margin: 0.25rem 0 0 0; font-size: 0.9rem;">View and manage Ko-fi donations</p>
              </div>
              <span class="collapse-icon"></span>
            </div>
            <div class="admin-section-content">
              <div id="donations-management-loading" style="text-align: center; padding: 2rem;">
                Loading donations data...
              </div>
              
              <div id="donations-management-content" style="display: none;">
                <!-- Donation Statistics -->
                <div style="background: #3a3a3a; border-radius: 8px; padding: 1.5rem; margin-bottom: 2rem; border: 1px solid #444;">
                  <h4 style="color: #FFD700; margin-bottom: 1rem;">Donation Statistics</h4>
                  <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1.5rem;">
                    <div>
                      <div style="color: #999; font-size: 0.9rem; margin-bottom: 0.25rem;">Total Donations</div>
                      <div style="font-size: 2rem; font-weight: bold; color: #FFD700; font-family: 'Cinzel', serif;">
                        $<span id="total-donation-amount">0.00</span>
                      </div>
                    </div>
                    <div>
                      <div style="color: #999; font-size: 0.9rem; margin-bottom: 0.25rem;">Number of Donations</div>
                      <div style="font-size: 2rem; font-weight: bold; color: #FFA500;">
                        <span id="total-donation-count">0</span>
                      </div>
                    </div>
                    <div>
                      <div style="color: #999; font-size: 0.9rem; margin-bottom: 0.25rem;">Unique Donors</div>
                      <div style="font-size: 2rem; font-weight: bold; color: #4a7c59;">
                        <span id="unique-donors-count">0</span>
                      </div>
                    </div>
                    <div>
                      <div style="color: #999; font-size: 0.9rem; margin-bottom: 0.25rem;">Unmatched Donations</div>
                      <div style="font-size: 2rem; font-weight: bold; color: #dc3545;">
                        <span id="unmatched-donations-count">0</span>
                      </div>
                    </div>
                  </div>
                </div>
                
                <!-- Filters and Search -->
                <div style="margin-bottom: 1.5rem; display: flex; gap: 1rem; flex-wrap: wrap; align-items: flex-end;">
                  <div style="flex: 1; min-width: 200px;">
                    <label style="display: block; color: #e0e0e0; margin-bottom: 0.5rem; font-size: 0.9rem;">Search by Name</label>
                    <input type="text" id="donation-search" placeholder="Search donor name..." 
                           style="width: 100%; padding: 0.5rem; border: 1px solid #555; border-radius: 4px; 
                                  background: #2d2d2d; color: #e0e0e0;">
                  </div>
                  <div>
                    <label style="display: block; color: #e0e0e0; margin-bottom: 0.5rem; font-size: 0.9rem;">Filter Status</label>
                    <select id="donation-filter" style="padding: 0.5rem; border: 1px solid #555; border-radius: 4px; 
                            background: #2d2d2d; color: #e0e0e0;">
                      <option value="all">All Donations</option>
                      <option value="matched">Matched Only</option>
                      <option value="unmatched">Unmatched Only</option>
                    </select>
                  </div>
                  <button onclick="refreshDonations()" style="background: transparent; border: none; color: #999; 
                          padding: 0.5rem; cursor: pointer; 
                          display: flex; align-items: center; justify-content: center;
                          transition: all 0.2s;" 
                          onmouseover="this.style.color='#FFD700'; this.style.transform='rotate(180deg)';" 
                          onmouseout="this.style.color='#999'; this.style.transform='rotate(0deg)';"
                          title="Refresh donations list">
                    <span style="font-size: 1.25rem;"></span>
                  </button>
                </div>
                
                <!-- Donations Table -->
                <div style="overflow-x: auto;">
                  <table class="admin-table">
                    <thead>
                      <tr>
                        <th>Date</th>
                        <th>Donor Name</th>
                        <th>Amount</th>
                        <th>Type</th>
                        <th>Message</th>
                        <th>Matched User</th>
                        <th>Actions</th>
                      </tr>
                    </thead>
                    <tbody id="donations-tbody"></tbody>
                  </table>
                </div>
                
                <!-- Donations Pagination -->
                <div id="donations-pagination" class="pagination" style="display: none; margin-top: 1.5rem;">
                  <button class="pagination-btn" id="donations-prev">Previous</button>
                  <span class="pagination-info" id="donations-page-info">Page 1 of 1</span>
                  <button class="pagination-btn" id="donations-next">Next</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div id="loading" class="loading">
      Loading account information...
    </div>

    <div id="not-authenticated" class="account-container" style="display: none;">
      <div class="account-content">
        <h2>Not Authenticated</h2>
        <p>Please sign in to access your account settings.</p>
        <a href="/" class="btn">Return to Maps</a>
      </div>
    </div>
  </div>

  <!-- Vote Inspect Modal -->

  <!-- XP Adjustment Modal -->
  <div id="xp-adjustment-modal" class="modal" style="display: none; z-index: 1001;">
    <div class="modal-content" style="max-width: 500px;">
      <div class="modal-header">
        <h2>Adjust Experience Points</h2>
        <button class="close-btn" data-action="closeXPModal">&times;</button>
      </div>
      <div class="modal-body">
        <div style="text-align: center; margin-bottom: 1.5rem;">
          <img id="xp-user-avatar" style="width: 60px; height: 60px; border-radius: 50%; border: 3px solid #FFD700; margin-bottom: 0.5rem;">
          <h3 id="xp-user-name" style="margin: 0; color: #FFD700;"></h3>
          <p style="color: #999; margin: 0.5rem 0;">Current XP: <span id="xp-current" style="color: #FFD700; font-weight: bold;"></span></p>
        </div>
        
        <div style="background: #2d2d2d; padding: 1.5rem; border-radius: 8px; margin-bottom: 1rem;">
          <label style="display: block; margin-bottom: 0.5rem; color: #e0e0e0;">New XP Value:</label>
          <input type="number" id="xp-new-value" min="0" style="width: 100%; padding: 0.5rem; border: 1px solid #555; border-radius: 4px; background: #1a1a1a; color: #e0e0e0; font-size: 1.1rem;">
          
          <label style="display: block; margin-top: 1rem; margin-bottom: 0.5rem; color: #e0e0e0;">Reason (optional):</label>
          <input type="text" id="xp-reason" placeholder="e.g., Bonus for exceptional contribution" style="width: 100%; padding: 0.5rem; border: 1px solid #555; border-radius: 4px; background: #1a1a1a; color: #e0e0e0;">
        </div>
        
        <div style="display: flex; gap: 0.5rem; justify-content: flex-end;">
          <button class="btn secondary-btn" data-action="closeXPModal">Cancel</button>
          <button class="btn" data-action="updateUserXP" style="background: #FFD700; color: #2a1810;">Update XP</button>
        </div>
      </div>
    </div>
  </div>

  <!-- User Detail Modal -->
  <div id="user-detail-modal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 900px;">
      <div class="modal-header" style="background: linear-gradient(135deg, #2d2d2d 0%, #3a3a3a 100%); border-bottom: 2px solid #4a7c59;">
        <h2 style="font-family: 'Cinzel', serif; background: linear-gradient(135deg, #FFD700, #FFA500); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">User Details</h2>
        <button class="close-btn" data-action="closeUserModal">&times;</button>
      </div>
      <div class="modal-body" style="padding: 1.5rem;">
        <!-- User Header Section -->
        <div style="background: linear-gradient(135deg, #2d2d2d 0%, #1a1a1a 100%); padding: 1.5rem; border-radius: 12px; margin-bottom: 1.5rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);">
          <div style="display: flex; align-items: center; gap: 1.5rem;">
            <div style="position: relative;">
              <img id="detail-user-avatar" style="width: 100px; height: 100px; border-radius: 50%; border: 4px solid #4a7c59; box-shadow: 0 0 20px rgba(74, 124, 89, 0.5); cursor: pointer;" onclick="editUserField('avatar')" title="Click to edit avatar">
              <div id="detail-user-level" style="position: absolute; bottom: -5px; right: -5px; background: #FFD700; color: #1a1a1a; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 0.9rem; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);"></div>
              <button class="edit-btn" onclick="editUserField('avatar')" style="position: absolute; top: -5px; right: -5px; background: #4a7c59; border: 2px solid #2d2d2d; color: white; cursor: pointer; padding: 0.3rem; border-radius: 50%; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);" title="Edit avatar">
                
              </button>
            </div>
            <div style="flex: 1;">
              <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                <h3 id="detail-user-name" style="margin: 0; color: #FFD700; font-size: 1.5rem; font-weight: 600;"></h3>
                <button class="edit-btn" onclick="editUserField('name')" style="background: none; border: none; color: #7fb069; cursor: pointer; padding: 0.2rem; opacity: 0.7; transition: opacity 0.2s;" title="Edit name">
                  
                </button>
              </div>
              <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                <p id="detail-user-email" style="margin: 0; color: #999; font-size: 0.95rem;"></p>
                <button class="edit-btn" onclick="editUserField('email')" style="background: none; border: none; color: #7fb069; cursor: pointer; padding: 0.2rem; opacity: 0.7; transition: opacity 0.2s;" title="Edit email">
                  
                </button>
              </div>
              <div style="display: flex; gap: 0.5rem; align-items: center;">
                <span id="detail-user-status" style="display: inline-block; padding: 0.25rem 0.75rem; border-radius: 20px; font-size: 0.85rem; font-weight: 500;"></span>
                <span id="detail-user-tier" style="display: inline-block; padding: 0.25rem 0.75rem; border-radius: 20px; font-size: 0.85rem; font-weight: 500;"></span>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Main Content Grid -->
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1.5rem; margin-bottom: 1.5rem;">
          <!-- Account Information -->
          <div class="detail-card" style="background: #2d2d2d; padding: 1.25rem; border-radius: 10px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); border: 1px solid #3a3a3a;">
            <h4 style="color: #FFD700; margin-top: 0; margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
              <span style="font-size: 1.2rem;"></span> Account Information
            </h4>
            <div class="info-row" style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0; border-bottom: 1px solid #3a3a3a;">
              <strong style="color: #999;">User ID:</strong>
              <span id="detail-user-id" style="color: #e0e0e0; font-family: monospace;"></span>
            </div>
            <div class="info-row" style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0; border-bottom: 1px solid #3a3a3a;">
              <strong style="color: #999;">Nickname:</strong>
              <div style="display: flex; align-items: center; gap: 0.5rem;">
                <span id="detail-user-nickname" style="color: #e0e0e0;"></span>
                <button class="edit-btn" onclick="editUserField('nickname')" style="background: none; border: none; color: #7fb069; cursor: pointer; padding: 0.2rem; opacity: 0.7; transition: opacity 0.2s;" title="Edit nickname">
                  
                </button>
              </div>
            </div>
            <div class="info-row" style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0; border-bottom: 1px solid #3a3a3a;">
              <strong style="color: #999;">Joined:</strong>
              <span id="detail-user-joined" style="color: #e0e0e0;"></span>
            </div>
            <div class="info-row" style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0; border-bottom: 1px solid #3a3a3a;">
              <strong style="color: #999;">Last Active:</strong>
              <span id="detail-user-last-active" style="color: #e0e0e0;"></span>
            </div>
            <div class="info-row" style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0;">
              <strong style="color: #999;">Experience:</strong>
              <div style="display: flex; align-items: center; gap: 0.5rem;">
                <span id="detail-user-xp" style="color: #FFD700; font-weight: bold; font-size: 1.1rem;"></span>
                <button class="small-btn" data-action="showXPAdjustment" style="padding: 0.2rem 0.5rem; font-size: 0.75rem; background: linear-gradient(135deg, #FFD700, #FFA500); color: #1a1a1a; border: none; border-radius: 4px; cursor: pointer;">
                  <span class="btn-icon"></span>Edit
                </button>
              </div>
            </div>
          </div>
          
          <!-- Activity Statistics -->
          <div class="detail-card" style="background: #2d2d2d; padding: 1.25rem; border-radius: 10px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); border: 1px solid #3a3a3a;">
            <h4 style="color: #FFD700; margin-top: 0; margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
              <span style="font-size: 1.2rem;"></span> Activity Statistics
            </h4>
            <div class="stat-row" style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; background: #1a1a1a; border-radius: 6px; margin-bottom: 0.5rem;">
              <span style="color: #999;">POIs Created</span>
              <span id="detail-user-total-pois" style="color: #4ade80; font-weight: bold; font-size: 1.2rem;"></span>
            </div>
            <div class="stat-row" style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; background: #1a1a1a; border-radius: 6px; margin-bottom: 0.5rem;">
              <span style="color: #999;">Published POIs</span>
              <span id="detail-user-published-pois" style="color: #60a5fa; font-weight: bold; font-size: 1.2rem;"></span>
            </div>
            <div class="stat-row" style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem; background: #1a1a1a; border-radius: 6px;">
              <span style="color: #999;">Votes Cast</span>
              <span id="detail-user-votes" style="color: #f59e0b; font-weight: bold; font-size: 1.2rem;"></span>
            </div>
          </div>
        </div>
        
        <!-- Admin Actions -->
        <div class="detail-card" style="background: #2d2d2d; padding: 1.25rem; border-radius: 10px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); border: 1px solid #3a3a3a;">
          <h4 style="color: #FFD700; margin-top: 0; margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
            <span style="font-size: 1.2rem;"></span> Admin Actions
          </h4>
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 0.75rem;">
            <button id="ban-user-btn" class="admin-action-btn danger" data-action="banUser">
              <span class="btn-icon"></span>
              <span>Ban User</span>
            </button>
            <button id="unban-user-btn" class="admin-action-btn success" data-action="unbanUser" style="display: none;">
              <span class="btn-icon"></span>
              <span>Unban User</span>
            </button>
            <button class="admin-action-btn warning" data-action="warnUser">
              <span class="btn-icon"></span>
              <span>Warn User</span>
            </button>
            <button class="admin-action-btn secondary" data-action="logoutUser">
              <span class="btn-icon"></span>
              <span>Force Logout</span>
            </button>
            <button class="admin-action-btn info" data-action="viewUserPois">
              <span class="btn-icon"></span>
              <span>View POIs</span>
            </button>
            <button id="toggle-admin-btn" class="admin-action-btn special" data-action="toggleAdminStatus">
              <span class="btn-icon"></span>
              <span id="toggle-admin-text">Make Admin</span>
            </button>
            <button id="toggle-visibility-btn" class="admin-action-btn secondary" data-action="toggleVisibility">
              <span class="btn-icon"></span>
              <span id="toggle-visibility-text">Hide User</span>
            </button>
          </div>
        </div>
        
        <!-- Warnings and Ban History (Hidden by default) -->
        <div id="user-warnings-section" style="display: none; margin-top: 1.5rem;">
          <div class="detail-card" style="background: #2d2d2d; padding: 1.25rem; border-radius: 10px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); border: 1px solid #3a3a3a;">
            <h4 style="color: #FFD700; margin-top: 0; margin-bottom: 1rem;"> Previous Warnings</h4>
            <div id="user-warnings-list" style="max-height: 200px; overflow-y: auto;"></div>
          </div>
        </div>
        
        <div id="user-ban-history-section" style="display: none; margin-top: 1.5rem;">
          <div class="detail-card" style="background: #2d2d2d; padding: 1.25rem; border-radius: 10px; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); border: 1px solid #3a3a3a;">
            <h4 style="color: #FFD700; margin-top: 0; margin-bottom: 1rem;"> Ban History</h4>
            <div id="user-ban-history-list" style="max-height: 200px; overflow-y: auto;"></div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <style>
    /* Admin Action Button Styles */
    .admin-action-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.25rem;
      padding: 0.75rem 1rem;
      border: none;
      border-radius: 8px;
      font-size: 0.85rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: center;
    }
    
    .admin-action-btn .btn-icon {
      font-size: 1.25rem;
    }
    
    .admin-action-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }
    
    .admin-action-btn.danger {
      background: linear-gradient(135deg, #dc3545, #c82333);
      color: white;
    }
    
    .admin-action-btn.success {
      background: linear-gradient(135deg, #28a745, #218838);
      color: white;
    }
    
    .admin-action-btn.warning {
      background: linear-gradient(135deg, #ffc107, #e0a800);
      color: #212529;
    }
    
    .admin-action-btn.info {
      background: linear-gradient(135deg, #17a2b8, #138496);
      color: white;
    }
    
    .admin-action-btn.secondary {
      background: linear-gradient(135deg, #6c757d, #5a6268);
      color: white;
    }
    
    .admin-action-btn.special {
      background: linear-gradient(135deg, #FFD700, #FFA500);
      color: #1a1a1a;
    }
    
    .edit-btn:hover {
      opacity: 1 !important;
    }
    
    /* Info row hover effect */
    .info-row:hover {
      background: rgba(74, 124, 89, 0.1);
      margin: 0 -0.5rem;
      padding-left: 0.5rem;
      padding-right: 0.5rem;
    }
  </style>
  
  <script>
    // Wait for DOM to be ready
    document.addEventListener('DOMContentLoaded', function() {
    
    // Edit user field function
    window.editUserField = async function(field) {
      const userId = document.getElementById('detail-user-id').textContent;
      let currentValue = '';
      let promptText = '';
      
      switch(field) {
        case 'name':
          currentValue = document.getElementById('detail-user-name').textContent;
          promptText = 'Enter new name:';
          break;
        case 'email':
          currentValue = document.getElementById('detail-user-email').textContent;
          promptText = 'Enter new email address:';
          break;
        case 'nickname':
          currentValue = document.getElementById('detail-user-nickname')?.textContent || '';
          promptText = 'Enter new nickname (leave empty to remove):';
          break;
        case 'avatar':
          // Handle avatar editing differently
          showAvatarEditModal(userId);
          return;
        default:
          return;
      }
      
      const newValue = prompt(promptText, currentValue);
      if (newValue === null) return; // User cancelled
      
      try {
        const response = await window.csrfHelper.fetchWithCSRF(`/api/admin/users/${userId}/update-field`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ field, value: newValue })
        });
        
        if (response.ok) {
          showMessage(`${field.charAt(0).toUpperCase() + field.slice(1)} updated successfully`, 'success');
          // Refresh user details
          viewUserDetails(userId);
        } else {
          const error = await response.json();
          showMessage(error.error || `Failed to update ${field}`, 'error');
        }
      } catch (error) {
        showMessage(`Failed to update ${field}`, 'error');
      }
    };
    
    // Show avatar edit modal
    window.showAvatarEditModal = function(userId) {
      // Create modal for avatar editing
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.style.cssText = 'display: flex; position: fixed; z-index: 2000; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); align-items: center; justify-content: center;';
      
      const modalContent = document.createElement('div');
      modalContent.className = 'modal-content';
      modalContent.style.cssText = 'max-width: 500px; background: #2d2d2d; border-radius: 12px; overflow: hidden;';
      
      modalContent.innerHTML = `
        <div class="modal-header" style="background: linear-gradient(135deg, #2d2d2d 0%, #3a3a3a 100%); border-bottom: 2px solid #4a7c59;">
          <h2>Edit User Avatar</h2>
          <button class="close-btn" onclick="this.closest('.modal').remove()">&times;</button>
        </div>
        <div class="modal-body" style="padding: 1.5rem;">
          <div style="text-align: center; margin-bottom: 1.5rem;">
            <img id="edit-avatar-preview" src="${document.getElementById('detail-user-avatar').src}" 
                 style="width: 120px; height: 120px; border-radius: 50%; border: 4px solid #4a7c59; 
                        box-shadow: 0 0 20px rgba(74, 124, 89, 0.5); margin-bottom: 1rem;">
            <p style="color: #999; margin: 0;">Current Avatar</p>
          </div>
          
          <div style="margin-bottom: 1.5rem;">
            <label class="btn primary-btn" style="display: block; text-align: center; cursor: pointer;">
              <input type="file" accept="image/*" onchange="handleAdminAvatarUpload(event, '${userId}')" 
                     style="display: none;">
              <span> Upload New Avatar</span>
            </label>
          </div>
          
          <div style="margin-bottom: 1.5rem;">
            <button class="btn secondary-btn" onclick="resetUserAvatar('${userId}')" style="width: 100%;">
              <span> Reset to Google Avatar</span>
            </button>
          </div>
          
          <div id="avatar-upload-progress" style="display: none; margin-top: 1rem;">
            <div style="background: #1a1a1a; border-radius: 8px; overflow: hidden; height: 8px;">
              <div id="avatar-progress-bar" style="height: 100%; background: linear-gradient(90deg, #4a7c59, #5fa772); 
                   width: 0%; transition: width 0.3s ease;"></div>
            </div>
            <p id="avatar-upload-status" style="text-align: center; color: #999; margin-top: 0.5rem;"></p>
          </div>
        </div>
      `;
      
      modal.appendChild(modalContent);
      document.body.appendChild(modal);
    };
    
    // Handle admin avatar upload
    window.handleAdminAvatarUpload = async function(event, userId) {
      const file = event.target.files[0];
      if (!file) return;
      
      // Validate file size
      if (file.size > 5 * 1024 * 1024) {
        showMessage('File size must be less than 5MB', 'error');
        return;
      }
      
      const progressDiv = document.getElementById('avatar-upload-progress');
      const progressBar = document.getElementById('avatar-progress-bar');
      const statusText = document.getElementById('avatar-upload-status');
      
      progressDiv.style.display = 'block';
      progressBar.style.width = '0%';
      statusText.textContent = 'Uploading...';
      
      const formData = new FormData();
      formData.append('avatar', file);
      
      try {
        // Create XMLHttpRequest for progress tracking
        const xhr = new XMLHttpRequest();
        
        xhr.upload.addEventListener('progress', (e) => {
          if (e.lengthComputable) {
            const percentComplete = Math.round((e.loaded / e.total) * 100);
            progressBar.style.width = percentComplete + '%';
          }
        });
        
        const uploadPromise = new Promise((resolve, reject) => {
          xhr.onload = () => {
            if (xhr.status >= 200 && xhr.status < 300) {
              resolve(JSON.parse(xhr.responseText));
            } else {
              reject(new Error(xhr.responseText));
            }
          };
          xhr.onerror = () => reject(new Error('Network error'));
        });
        
        // Get CSRF token
        const csrfToken = await window.getCSRFToken();
        
        xhr.open('POST', `/api/admin/users/${userId}/avatar`);
        xhr.setRequestHeader('X-CSRF-Token', csrfToken);
        xhr.send(formData);
        
        const result = await uploadPromise;
        
        statusText.textContent = 'Upload complete!';
        progressBar.style.width = '100%';
        
        // Update preview
        document.getElementById('edit-avatar-preview').src = result.avatarUrl + '?t=' + Date.now();
        
        showMessage('Avatar updated successfully', 'success');
        
        // Refresh user details after a short delay
        setTimeout(() => {
          document.querySelector('.modal').remove();
          viewUserDetails(userId);
        }, 1000);
        
      } catch (error) {
        progressDiv.style.display = 'none';
        showMessage('Failed to upload avatar: ' + error.message, 'error');
      }
    };
    
    // Reset user avatar to Google
    window.resetUserAvatar = async function(userId) {
      if (!confirm('Reset this user\'s avatar to their Google profile picture?')) return;
      
      try {
        const response = await window.csrfHelper.fetchWithCSRF(`/api/admin/users/${userId}/avatar/reset`, {
          method: 'POST'
        });
        
        if (response.ok) {
          showMessage('Avatar reset to Google picture', 'success');
          document.querySelector('.modal').remove();
          viewUserDetails(userId);
        } else {
          const error = await response.json();
          showMessage(error.error || 'Failed to reset avatar', 'error');
        }
      } catch (error) {
        showMessage('Failed to reset avatar', 'error');
      }
    };
    
    // Toggle user visibility function
    window.toggleUserVisibility = async function(userId) {
      try {
        // Use the local CSRF helper function
        const csrfToken = await getCSRFToken();
        const response = await fetch(`/api/admin/users/${userId}/visibility`, {
          method: 'PATCH',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRF-Token': csrfToken
          }
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to toggle visibility');
        }
        
        const result = await response.json();
        
        if (typeof showMessage === 'function') {
          showMessage(result.message, 'success');
        }
        
        // Update the UI to reflect the new visibility status
        const toggleBtn = document.getElementById('toggle-visibility-btn');
        if (toggleBtn) {
          const newText = result.visible ? 'Hide User' : 'Show User';
          const newIcon = result.visible ? '' : '';
          toggleBtn.innerHTML = `<span class="btn-icon">${newIcon}</span><span id="toggle-visibility-text">${newText}</span>`;
        }
        
        // Update the status display if the user is hidden
        updateUserStatusDisplay(userId, result.visible);
        
        // Refresh the user list if we're on the admin tab
        if (document.getElementById('admin-tab').classList.contains('active')) {
          // Refresh users list
          if (typeof loadUsers === 'function') {
            loadUsers();
          }
        }
      } catch (error) {
        console.error('Error toggling user visibility:', error);
        if (typeof showMessage === 'function') {
          showMessage(error.message || 'Failed to toggle user visibility', 'error');
        } else {
          alert(error.message || 'Failed to toggle user visibility');
        }
      }
    }
    
    // Create wrapper function for the existing event handler
    window.toggleVisibility = function() {
      // Get userId from the modal
      const userIdElement = document.getElementById('detail-user-id');
      if (userIdElement && userIdElement.textContent) {
        window.toggleUserVisibility(userIdElement.textContent);
      } else {
        console.error('Cannot find user ID for visibility toggle');
      }
    };
    
    // Update user status display to show if hidden
    function updateUserStatusDisplay(userId, isVisible) {
      const statusElement = document.getElementById('detail-user-status');
      if (!statusElement) return;
      
      // Get current user data to check other status
      const userRow = document.querySelector(`tr[data-user-id="${userId}"]`);
      if (!userRow) return;
      
      const isBanned = userRow.querySelector('.ban-status')?.textContent.includes('Banned');
      const isAdmin = userRow.querySelector('.admin-badge')?.style.display !== 'none';
      
      let statusHTML = '';
      if (isBanned) {
        statusHTML = '<span style="background: #dc3545; color: white; padding: 0.25rem 0.5rem; border-radius: 4px;"> Banned</span>';
      } else if (!isVisible) {
        statusHTML = '<span style="background: #6c757d; color: white; padding: 0.25rem 0.5rem; border-radius: 4px;"> Hidden</span>';
      } else if (isAdmin) {
        statusHTML = '<span style="background: #ffc107; color: #212529; padding: 0.25rem 0.5rem; border-radius: 4px;"> Admin</span>';
      } else {
        statusHTML = '<span style="background: #28a745; color: white; padding: 0.25rem 0.5rem; border-radius: 4px;"> Active</span>';
      }
      
      statusElement.innerHTML = statusHTML;
    }
    
    }); // End of DOMContentLoaded
    
    // Override showUserDetails after page load to ensure it exists
    window.addEventListener('load', function() {
      const originalShowUserDetails = window.showUserDetails;
      
      window.showUserDetails = async function(userOrId) {
        let user = userOrId;
        
        // Always fetch fresh user data to ensure we have the latest visibility status
        const userId = (typeof userOrId === 'object' && userOrId.id) ? userOrId.id : userOrId;
        try {
          const response = await fetch(`/api/users/${userId}`);
          if (response.ok) {
            user = await response.json();
          } else {
            console.error('Failed to fetch user details');
            if (originalShowUserDetails) {
              originalShowUserDetails(userOrId);
            }
            return;
          }
        } catch (error) {
          console.error('Error fetching user:', error);
          if (originalShowUserDetails) {
            originalShowUserDetails(userOrId);
          }
          return;
        }
        
        // Store user data for other functions
        window.currentUserDetails = user;
        
        // Call original function if it exists
        if (typeof originalShowUserDetails === 'function') {
          originalShowUserDetails(user);
        }
        
        // Update visibility button
        const toggleBtn = document.getElementById('toggle-visibility-btn');
        if (toggleBtn) {
          // Handle null as true (default visible)
          const isVisible = user.visible === null || user.visible === true;
          const buttonText = isVisible ? 'Hide User' : 'Show User';
          const buttonIcon = isVisible ? '' : '';
          toggleBtn.innerHTML = `<span class="btn-icon">${buttonIcon}</span><span id="toggle-visibility-text">${buttonText}</span>`;
          
          // Update status display
          updateUserStatusDisplay(user.id, isVisible);
        }
        
        // Show the modal if it's not already visible
        const modal = document.getElementById('user-detail-modal');
        if (modal && modal.style.display === 'none') {
          modal.style.display = 'block';
        }
      };
      
    });
    
    // Also watch for when the modal is shown to update visibility button
    window.addEventListener('load', function() {
      const modal = document.getElementById('user-detail-modal');
      if (!modal) {
        return;
      }
      
      // Create observer to watch for modal display changes
      const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
          if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
            if (modal.style.display !== 'none' && modal.style.display !== '') {
              // Get user ID from modal
              const userIdElement = document.getElementById('detail-user-id');
              if (userIdElement && userIdElement.textContent) {
                const userId = userIdElement.textContent.trim();
                
                // Fetch user data and update visibility button
                fetch(`/api/users/${userId}`)
                  .then(response => response.json())
                  .then(user => {
                    // Update visibility button
                    const toggleBtn = document.getElementById('toggle-visibility-btn');
                    if (toggleBtn) {
                      const isVisible = user.visible === null || user.visible === true;
                      const buttonText = isVisible ? 'Hide User' : 'Show User';
                      const buttonIcon = isVisible ? '' : '';
                      toggleBtn.innerHTML = `<span class="btn-icon">${buttonIcon}</span><span id="toggle-visibility-text">${buttonText}</span>`;
                    }
                  })
                  .catch(error => {
                    console.error('Error fetching user for visibility button:', error);
                  });
              }
            }
          }
        });
      });
      
      // Start observing
      observer.observe(modal, { attributes: true });
    });
  </script>

  <!-- POI Type Modal -->
  <div id="poi-type-modal" class="modal" style="display: none;">
    <div class="modal-content">
      <div class="modal-header">
        <h2 id="poi-type-modal-title">Add POI Type</h2>
        <button class="close-btn" onclick="closePOITypeModal()">&times;</button>
      </div>
      <div class="modal-body">
        <form id="poi-type-form" onsubmit="savePOIType(event)">
          <div class="form-group">
            <label for="poi-type-name">Name *</label>
            <input type="text" id="poi-type-name" required placeholder="e.g., Tavern, Quest Giver, Dungeon">
          </div>
          
          <div class="form-group">
            <label>Icon Type *</label>
            <div class="radio-group">
              <label>
                <input type="radio" name="icon-type" value="emoji" checked onchange="updateIconTypeDisplay()">
                Emoji
              </label>
              <label>
                <input type="radio" name="icon-type" value="iconify" onchange="updateIconTypeDisplay()">
                Icon Library
              </label>
              <label>
                <input type="radio" name="icon-type" value="upload" onchange="updateIconTypeDisplay()">
                Upload Image
              </label>
            </div>
          </div>
          
          <!-- Emoji Input -->
          <div id="emoji-input-group" class="form-group">
            <label for="poi-type-emoji">Emoji *</label>
            <div style="display: flex; gap: 0.5rem;">
              <input type="text" id="poi-type-emoji" placeholder="Enter emoji or click to select" maxlength="4">
              <button type="button" onclick="togglePOITypeEmojiPicker()" class="secondary-btn"></button>
            </div>
            
            <div id="emoji-picker" style="display: none;">
              <div style="display: flex; gap: 0.5rem; padding: 0.75rem; border-bottom: 1px solid #555; flex-wrap: wrap; background: #232323; border-radius: 8px 8px 0 0;">
                <button type="button" onclick="selectEmojiCategory('harvest')" class="emoji-category-btn active" title="Harvesting/Materials"></button>
                <button type="button" onclick="selectEmojiCategory('plants')" class="emoji-category-btn" title="Plants/Herbs"></button>
                <button type="button" onclick="selectEmojiCategory('rpg')" class="emoji-category-btn" title="RPG/Weapons"></button>
                <button type="button" onclick="selectEmojiCategory('locations')" class="emoji-category-btn" title="Locations/Buildings"></button>
                <button type="button" onclick="selectEmojiCategory('map')" class="emoji-category-btn" title="Map/Navigation"></button>
                <button type="button" onclick="selectEmojiCategory('creatures')" class="emoji-category-btn" title="Creatures/Monsters"></button>
                <button type="button" onclick="selectEmojiCategory('weather')" class="emoji-category-btn" title="Weather/Environment"></button>
                <button type="button" onclick="selectEmojiCategory('items')" class="emoji-category-btn" title="Items/Treasures"></button>
                <button type="button" onclick="selectEmojiCategory('food')" class="emoji-category-btn" title="Food/Consumables"></button>
                <button type="button" onclick="selectEmojiCategory('symbols')" class="emoji-category-btn" title="Symbols/UI"></button>
              </div>
              <div id="emoji-grid">
                <!-- Emojis will be populated here -->
              </div>
              <div style="padding: 0.75rem; border-top: 1px solid #555; text-align: center; background: #232323; border-radius: 0 0 8px 8px;">
                <a href="https://emojipedia.org/" target="_blank" style="color: #FFD700; text-decoration: none; font-size: 0.9rem; font-weight: 500;">
                   Browse more emojis on Emojipedia 
                </a>
              </div>
            </div>
          </div>
          
          <!-- Iconify Input -->
          <div id="iconify-input-group" class="form-group" style="display: none;">
            <label for="poi-type-iconify">Icon *</label>
            <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
              <input type="text" id="poi-type-iconify" placeholder="Search for icons..." onkeyup="searchIconifyIcons(this.value)">
              <input type="hidden" id="poi-type-iconify-value" value="">
              <div id="selected-iconify-preview" style="width: 40px; height: 40px; border: 1px solid #555; border-radius: 4px; display: flex; align-items: center; justify-content: center; background: #2d2d2d;">
                <span style="color: #666;">?</span>
              </div>
            </div>
            
            <!-- Popular icon sets -->
            <div style="margin-bottom: 1rem;">
              <label style="font-size: 0.85rem; color: #999;">Popular icon sets:</label>
              <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; margin-top: 0.5rem;">
                <button type="button" class="icon-set-btn" onclick="loadIconifySet('game-icons')"> Game Icons (RPG)</button>
                <button type="button" class="icon-set-btn" onclick="loadIconifySet('mdi')">Material Design</button>
                <button type="button" class="icon-set-btn" onclick="loadIconifySet('tabler')">Tabler Icons</button>
                <button type="button" class="icon-set-btn" onclick="loadIconifySet('lucide')">Lucide</button>
                <button type="button" class="icon-set-btn" onclick="loadIconifySet('ri')">Remix Icons</button>
                <button type="button" class="icon-set-btn" onclick="loadIconifySet('heroicons')">Hero Icons</button>
              </div>
            </div>
            
            <div id="iconify-picker" style="border: 1px solid #555; border-radius: 4px; background: #2d2d2d; max-height: 300px; overflow-y: auto; display: none;">
              <div id="iconify-search-results" style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 0.5rem; padding: 1rem;">
                <!-- Icons will be populated here -->
              </div>
            </div>
            
            <p class="help-text">Search for RPG-related terms like "sword", "potion", "dragon", etc. Game Icons set has thousands of colored RPG icons! Over 200,000 free icons available.</p>
          </div>
          
          <!-- Upload Input -->
          <div id="upload-input-group" class="form-group" style="display: none;">
            <label for="poi-type-upload">Icon Image *</label>
            <input type="file" id="poi-type-upload" accept="image/*">
            <p class="help-text">Max size: 1MB. Supported formats: PNG, JPG, GIF, SVG</p>
            <div id="icon-preview" style="margin-top: 1rem; text-align: center;"></div>
          </div>
          
          <!-- Multi-Mob Checkbox -->
          <div class="form-group">
            <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
              <input type="checkbox" id="poi-type-multi-mob" style="width: auto; margin: 0;">
              <span>Multi-Mob Spawn Point</span>
            </label>
            <p class="help-text" style="margin-top: 0.5rem;">When enabled, POIs of this type can have multiple NPCs associated with them (e.g., spawn points with rotating mobs)</p>
          </div>
          
          <div class="modal-actions">
            <button type="button" onclick="closePOITypeModal()" class="secondary-btn">Cancel</button>
            <button type="submit" class="primary-btn">Save</button>
          </div>
        </form>
      </div>
    </div>
  </div>

  <!-- Item Modal removed - using inline editing -->
  <script>
    let currentUser = null;
    let preferences = {};
    
    // Use the global CSRF helper from csrf-helper.js
    // Note: fetchWithCSRF and getCSRFToken are available via window.csrfHelper

    // Helper functions for safe table cell creation
    function createTextCell(text) {
      const td = document.createElement('td');
      td.textContent = text;
      return td;
    }
    
    function createImageCell(src, alt) {
      const td = document.createElement('td');
      td.style.textAlign = 'center';
      const img = document.createElement('img');
      img.src = src;
      img.alt = alt;
      img.style.width = '32px';
      img.style.height = '32px';
      img.style.borderRadius = '50%';
      img.style.objectFit = 'cover';
      img.style.display = 'block';
      img.style.margin = '0 auto';
      td.appendChild(img);
      return td;
    }
    
    function createXPCell(xp) {
      const td = document.createElement('td');
      td.style.color = '#FFD700';
      td.style.fontWeight = 'bold';
      td.textContent = xp;
      return td;
    }
    
    function createHTMLCell(html) {
      const td = document.createElement('td');
      if (window.safeHTML) {
        td.innerHTML = window.safeHTML(html);
      } else {
        td.textContent = html.replace(/<[^>]*>/g, ''); // Strip HTML if no sanitizer
      }
      return td;
    }
    
    function createButtonCell(userId, buttonText = 'Details', iconText = '') {
      const td = document.createElement('td');
      const btn = document.createElement('button');
      btn.className = 'small-btn info-btn';
      btn.onclick = () => viewUserDetails(userId);
      const icon = document.createElement('span');
      icon.className = 'btn-icon';
      icon.textContent = iconText;
      btn.appendChild(icon);
      btn.appendChild(document.createTextNode(buttonText));
      td.appendChild(btn);
      return td;
    }
    
    // Helper functions for POI table cells
    function createPOIRow(poi, actions, isOwner = true) {
      const row = document.createElement('tr');
      
      // Icon cell
      const iconCell = document.createElement('td');
      iconCell.style.textAlign = 'center';
      iconCell.style.fontSize = '1.5rem';
      iconCell.textContent = poi.icon;
      row.appendChild(iconCell);
      
      // Name cell
      row.appendChild(createTextCell(poi.name));
      
      // Map name cell
      row.appendChild(createTextCell(poi.map_name));
      
      if (isOwner) {
        // Created date cell
        row.appendChild(createTextCell(new Date(poi.created_at).toLocaleDateString()));
        
        // Status cell
        const statusCell = document.createElement('td');
        if (window.safeHTML) {
          statusCell.innerHTML = window.safeHTML(getStatusBadge(poi.status));
        } else {
          statusCell.textContent = poi.status;
        }
        row.appendChild(statusCell);
        
        // Shared count cell
        const sharedCell = document.createElement('td');
        const sharedCount = poi.shared_count || 0;
        
        const sharedLink = document.createElement('a');
        sharedLink.href = '#';
        sharedLink.style.color = sharedCount > 0 ? '#4dff4d' : '#999';
        sharedLink.style.textDecoration = 'none';
        sharedLink.style.cursor = 'pointer';
        sharedLink.style.transition = 'all 0.2s';
        sharedLink.textContent = `${sharedCount} user${sharedCount !== 1 ? 's' : ''}`;
        
        // Add glow effect for counts > 0
        if (sharedCount > 0) {
          sharedLink.style.textShadow = '0 0 8px rgba(77, 255, 77, 0.6), 0 0 12px rgba(77, 255, 77, 0.4)';
        }
        
        sharedLink.onmouseover = () => {
          sharedLink.style.textDecoration = 'underline';
          if (sharedCount > 0) {
            sharedLink.style.textShadow = '0 0 10px rgba(77, 255, 77, 0.8), 0 0 15px rgba(77, 255, 77, 0.6)';
          }
        };
        sharedLink.onmouseout = () => {
          sharedLink.style.textDecoration = 'none';
          if (sharedCount > 0) {
            sharedLink.style.textShadow = '0 0 8px rgba(77, 255, 77, 0.6), 0 0 12px rgba(77, 255, 77, 0.4)';
          }
        };
        sharedLink.onclick = (e) => {
          e.preventDefault();
          viewSharedUsers(poi.id);
        };
        sharedCell.appendChild(sharedLink);
        row.appendChild(sharedCell);
      } else {
        // Shared by cell
        row.appendChild(createTextCell(poi.shared_by_name || 'Unknown'));
      }
      
      // Actions cell
      const actionsCell = document.createElement('td');
      if (window.safeHTML) {
        actionsCell.innerHTML = window.safeHTML(actions);
      } else {
        actionsCell.textContent = 'Actions';
      }
      row.appendChild(actionsCell);
      
      return row;
    }

    // Check ban status and redirect if banned
    async function checkBanStatus() {
      try {
        const response = await fetch('/api/auth/status');
        const data = await response.json();
        
        if (data.banned) {
          // Log them out and redirect to main page
          await fetch('/api/auth/logout', { method: 'POST' });
          window.location.href = '/';
          return true; // User is banned
        }
        return false; // User is not banned
      } catch (error) {
        console.error('Error checking ban status:', error);
        return false;
      }
    }
    
    // Wrap any action to check ban status first
    async function withBanCheck(action) {
      const isBanned = await checkBanStatus();
      if (!isBanned && typeof action === 'function') {
        return action();
      }
    }
    
    // Check authentication status
    async function checkAuth() {
      try {
        const response = await fetch('/api/auth/status');
        const data = await response.json();
        
        document.getElementById('loading').style.display = 'none';
        
        // Check if user is banned
        if (data.banned) {
          // Log them out and redirect to main page
          await fetch('/api/auth/logout', { method: 'POST' });
          window.location.href = '/';
          return;
        }
        
        if (data.authenticated) {
          currentUser = data.user;
          document.getElementById('account-content').style.display = 'flex';
          loadUserData();
          loadPreferences();
          
          // Handle URL parameters for navigation
          const urlParams = new URLSearchParams(window.location.search);
          const tab = urlParams.get('tab');
          const section = urlParams.get('section');
          
          // Navigate to specified tab
          if (tab === 'admin' && currentUser.is_admin) {
            showTab('admin');
            
            // Open specific section if specified
            if (section === 'poi-editor') {
              setTimeout(() => {
                const poiEditorSection = document.getElementById('poi-editor-section');
                if (poiEditorSection) {
                  poiEditorSection.classList.remove('collapsed');
                  
                  // Set the highlight ID from URL parameters
                  const urlParams = new URLSearchParams(window.location.search);
                  const highlightId = urlParams.get('highlight');
                  if (highlightId) {
                    window.poiEditorHighlightId = highlightId;
                  }
                  
                  loadPOIEditor();
                }
              }, 100);
            }
          }
        } else {
          document.getElementById('not-authenticated').style.display = 'block';
        }
      } catch (error) {
        document.getElementById('loading').innerHTML = 'Error loading account information';
      }
    }

    function loadUserData() {
      // Use display name (nickname or real name)
      const displayName = currentUser.displayName || currentUser.name;
      document.getElementById('user-name').textContent = displayName;
      document.getElementById('user-email').textContent = currentUser.email;
      
      
      // Use picture from server (auth/status already returns the correct avatar URL)
      const userAvatar = document.getElementById('user-avatar');
      userAvatar.src = currentUser.picture;
      userAvatar.alt = displayName;
      
      // Add error handler for avatar fallback
      userAvatar.onerror = async function() {
        
        // Try to get the Google picture from the API
        try {
          const response = await fetch('/api/user/google-picture');
          if (response.ok) {
            const data = await response.json();
            if (data.picture && this.src !== data.picture) {
              this.src = data.picture;
              return;
            }
          }
        } catch (error) {
          // Silently fail
        }
        
        // If all else fails, hide the image
        this.style.display = 'none';
      };
      
      // Initialize preferences tab
      const previewAvatar = document.getElementById('preview-avatar');
      previewAvatar.src = currentUser.picture;
      previewAvatar.onerror = userAvatar.onerror;
      
      document.getElementById('nickname-input').value = currentUser.nickname || '';
      
      // Show/hide reset avatar button based on avatar_filename
      if (currentUser.avatar_filename) {
        document.getElementById('reset-avatar-btn').style.display = 'inline-block';
      }
      
      if (currentUser.is_admin) {
        document.getElementById('admin-badge').style.display = 'inline-block';
        document.getElementById('admin-tab-btn').style.display = 'block';
      }
      
      // Load XP and level information
      loadProfileStats();
    }
    
    async function loadProfileStats() {
      try {
        // Get user XP and calculate level
        const userXP = currentUser.xp || 0;
        const xpProgress = getXPProgress(userXP);
        
        // Update level display
        document.getElementById('user-level').textContent = xpProgress.level;
        document.getElementById('user-current-xp').textContent = xpProgress.xpIntoLevel;
        document.getElementById('user-next-level-xp').textContent = xpProgress.level * xpProgress.level * 100;
        document.getElementById('user-xp-bar').style.width = xpProgress.progressPercent + '%';
        
        // Load stats
        const [statsResponse, rankResponse] = await Promise.all([
          fetch('/api/user/stats'),
          fetch('/api/user/rank')
        ]);
        
        if (statsResponse.ok) {
          const stats = await statsResponse.json();
          document.getElementById('total-pois').textContent = stats.totalPois || 0;
          document.getElementById('approved-pois').textContent = stats.approvedPois || 0;
          document.getElementById('total-votes').textContent = stats.totalVotes || 0;
        }
        
        if (rankResponse.ok) {
          const rankData = await rankResponse.json();
          document.getElementById('user-rank').textContent = `Rank: #${rankData.rank}`;
        }
        
        // Load user donations
        if (typeof loadUserDonations === 'function') {
          loadUserDonations();
        }
        
      } catch (error) {
        console.error('Error loading profile stats:', error);
      }
    }
    
    function getXPProgress(totalXP) {
      // Calculate level from total XP
      let level = 1;
      let xpForNextLevel = 0;
      
      // Calculate which level the user is at
      while (xpForNextLevel <= totalXP) {
        xpForNextLevel += level * level * 100;
        if (xpForNextLevel <= totalXP) {
          level++;
        }
      }
      
      // Calculate XP needed for current level and progress
      const xpForCurrentLevel = level > 1 ? (level - 1) * (level - 1) * 100 * level / 2 : 0;
      const xpIntoLevel = totalXP - xpForCurrentLevel;
      const xpNeededForNextLevel = level * level * 100;
      const progressPercent = Math.min(100, (xpIntoLevel / xpNeededForNextLevel) * 100);
      
      return {
        level,
        xpIntoLevel,
        xpNeededForNextLevel,
        progressPercent,
        totalXP
      };
    }

    async function loadPreferences() {
      // Preferences are coming soon
    }

    function showTab(tabName, skipNavUpdate = false) {
      // Hide all tabs
      document.querySelectorAll('.tab-content').forEach(tab => {
        tab.classList.remove('active');
      });
      
      // Remove active class from all nav items
      document.querySelectorAll('.nav-item').forEach(item => {
        item.classList.remove('active');
      });
      
      // Reset container width when leaving admin tab
      if (tabName !== 'admin') {
        const accountContent = document.querySelector('.account-content');
        accountContent.classList.remove('editor-active', 'both-editors-active');
      }
      
      // Show selected tab
      document.getElementById(tabName + '-tab').classList.add('active');
      
      // Add active class to the corresponding nav item
      if (!skipNavUpdate) {
        if (event && event.target) {
          event.target.classList.add('active');
        } else {
          // Find the nav item by its content or ID
          const navItems = {
            'profile': ' Profile',
            'preferences': ' Preferences',
            'privacy': ' Privacy & Security',
            'custom-pois': ' Custom POIs',
            'voting': ' Voting',
            'admin': ' Admin'
          };
          
          document.querySelectorAll('.nav-item').forEach(item => {
            if (item.textContent.includes(navItems[tabName])) {
              item.classList.add('active');
            }
          });
        }
      }
      
      // Load admin data when admin tab is shown
      if (tabName === 'admin' && currentUser?.is_admin) {
        if (typeof loadAdminData === 'function') {
          loadAdminData();
        }
      }
      
      // Load voting data when voting tab is shown
      if (tabName === 'voting') {
        if (typeof loadVotingData === 'function') {
          loadVotingData();
        }
      }
      
      // Load user donations when profile tab is shown
      if (tabName === 'profile') {
        // Always refresh if flag is set, or if we're coming from admin tab
        const previousActiveTab = document.querySelector('.tab-content.active');
        const comingFromAdmin = previousActiveTab && previousActiveTab.id === 'admin-tab';
        
        if (donationDataNeedsRefresh || comingFromAdmin) {
          loadUserDonations();
          donationDataNeedsRefresh = false;
        }
      }
    }

    function toggleAdminSection(sectionId) {
      const section = document.getElementById(sectionId);
      section.classList.toggle('collapsed');
      
      // Load data when sections are expanded
      if (!section.classList.contains('collapsed')) {
        switch(sectionId) {
          case 'donation-tiers-section':
            loadDonationTiers();
            break;
          case 'donations-management-section':
            if (window.loadDonationsManagement) {
              loadDonationsManagement();
            }
            break;
          // Add other cases as needed
        }
      }
      
      // Update container width based on open editors
      updateContainerWidth();
    }
    
    function updateContainerWidth() {
      const accountContent = document.querySelector('.account-content');
      if (!accountContent) return;
      
      const poiEditorSection = document.getElementById('poi-editor-section');
      const itemEditorSection = document.getElementById('item-editor-section');
      const npcEditorSection = document.getElementById('npc-editor-section');
      
      const poiEditorOpen = poiEditorSection && !poiEditorSection.classList.contains('collapsed');
      const itemEditorOpen = itemEditorSection && !itemEditorSection.classList.contains('collapsed');
      const npcEditorOpen = npcEditorSection && !npcEditorSection.classList.contains('collapsed');
      
      // Remove all width classes first
      accountContent.classList.remove('editor-active', 'both-editors-active');
      
      // Count open editors
      const openEditors = [poiEditorOpen, itemEditorOpen, npcEditorOpen].filter(Boolean).length;
      
      // Add appropriate class based on number of open editors
      if (openEditors >= 2) {
        accountContent.classList.add('both-editors-active');
      } else if (openEditors === 1) {
        accountContent.classList.add('editor-active');
      }
    }

    async function updatePreference(key, value) {
      // Preferences are coming soon
    }


    async function deleteAccount() {
      if (!confirm('Are you sure you want to delete your account? This action cannot be undone.')) {
        return;
      }
      
      try {
        const response = await window.csrfHelper.fetchWithCSRF('/api/user/account', {
          method: 'DELETE'
        });
        
        if (response.ok) {
          window.location.href = '/';
        }
      } catch (error) {
        showMessage('Failed to delete account', 'error');
      }
    }

    async function logoutAll() {
      try {
        const response = await window.csrfHelper.fetchWithCSRF('/api/auth/logout-all', {
          method: 'POST'
        });
        
        if (response.ok) {
          window.location.href = '/';
        }
      } catch (error) {
        showMessage('Failed to logout from all devices', 'error');
      }
    }

    // Custom confirmation dialog
    function showConfirmDialog(message, onConfirm) {
      const dialog = document.getElementById('confirmDialog');
      const messageEl = dialog.querySelector('.confirm-dialog-message');
      const confirmBtn = dialog.querySelector('.confirm-dialog-btn-confirm');
      const cancelBtn = dialog.querySelector('.confirm-dialog-btn-cancel');
      
      messageEl.textContent = message;
      dialog.style.display = 'flex';
      
      // Remove any existing event listeners
      const newConfirmBtn = confirmBtn.cloneNode(true);
      const newCancelBtn = cancelBtn.cloneNode(true);
      confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
      cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
      
      // Add new event listeners
      newConfirmBtn.addEventListener('click', () => {
        dialog.style.display = 'none';
        onConfirm();
      });
      
      newCancelBtn.addEventListener('click', () => {
        dialog.style.display = 'none';
      });
      
      // Also close on overlay click
      dialog.addEventListener('click', (e) => {
        if (e.target === dialog) {
          dialog.style.display = 'none';
        }
      });
    }
    
    function showMessage(text, type) {
      // Create a floating toast notification
      const toast = document.createElement('div');
      toast.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        padding: 1rem 2rem;
        border-radius: 8px;
        font-weight: bold;
        z-index: 10000;
        animation: slideIn 0.3s ease-out;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      `;
      
      // Style based on type
      if (type === 'success') {
        toast.style.backgroundColor = '#4a7c59';
        toast.style.color = '#fff';
        toast.style.border = '1px solid #5fa772';
      } else if (type === 'error') {
        toast.style.backgroundColor = '#8b2635';
        toast.style.color = '#fff';
        toast.style.border = '1px solid #a94442';
      } else {
        toast.style.backgroundColor = '#4a6fa5';
        toast.style.color = '#fff';
        toast.style.border = '1px solid #5c7cfa';
      }
      
      toast.textContent = text;
      document.body.appendChild(toast);
      
      // Remove after 3 seconds
      setTimeout(() => {
        toast.style.animation = 'fadeOut 0.3s ease-out';
        setTimeout(() => {
          document.body.removeChild(toast);
        }, 300);
      }, 3000);
    }

    // Custom POIs functionality
    let customPois = [];
    let myPoisCurrentPage = 1;
    let sharedPoisCurrentPage = 1;
    const ITEMS_PER_PAGE = 10;

    async function loadCustomPois() {
      try {
        const response = await fetch('/api/custom-pois');
        if (response.ok) {
          customPois = await response.json();
          displayCustomPois();
        }
      } catch (error) {
        console.error('Error loading custom POIs:', error);
      }
    }

    function displayCustomPois() {
      document.getElementById('custom-pois-loading').style.display = 'none';
      document.getElementById('custom-pois-content').style.display = 'block';
      
      // Separate owned POIs from shared POIs
      const ownedPois = customPois.filter(poi => poi.is_owner);
      const sharedPois = customPois.filter(poi => !poi.is_owner);
      
      // Display owned POIs with pagination
      displayMyPois(ownedPois);
      
      // Display shared POIs with pagination
      displaySharedPois(sharedPois);
    }
    
    function displayMyPois(ownedPois) {
      const totalPages = Math.ceil(ownedPois.length / ITEMS_PER_PAGE);
      myPoisCurrentPage = Math.max(1, Math.min(myPoisCurrentPage, totalPages || 1));
      
      // Table is always visible
      document.getElementById('custom-pois-table').style.display = 'table';
      
      const tbody = document.getElementById('custom-pois-tbody');
      tbody.innerHTML = '';
      
      if (ownedPois.length === 0) {
        // Show empty message in table
        document.getElementById('my-pois-pagination').style.display = 'none';
        const row = document.createElement('tr');
        row.innerHTML = `
          <td colspan="7" style="text-align: center; color: #666; padding: 2rem;">
            <p style="margin-bottom: 0.5rem;">You haven't created any custom POIs yet.</p>
            <p style="font-size: 0.9rem; color: #999;">Right-click on any map to create your first custom POI!</p>
          </td>
        `;
        tbody.appendChild(row);
      } else {
        // Only show pagination if there's more than one page
        document.getElementById('my-pois-pagination').style.display = totalPages > 1 ? 'flex' : 'none';
        
        // Calculate pagination
        const startIndex = (myPoisCurrentPage - 1) * ITEMS_PER_PAGE;
        const endIndex = startIndex + ITEMS_PER_PAGE;
        const pageItems = ownedPois.slice(startIndex, endIndex);
        
        pageItems.forEach(poi => {
          const row = document.createElement('tr');
          
          // Icon cell
          const iconCell = document.createElement('td');
          iconCell.style.textAlign = 'center';
          iconCell.style.fontSize = '1.5rem';
          iconCell.textContent = poi.icon;
          row.appendChild(iconCell);
          
          // Name cell
          const nameCell = document.createElement('td');
          nameCell.textContent = poi.name;
          row.appendChild(nameCell);
          
          // Map cell
          const mapCell = document.createElement('td');
          mapCell.textContent = poi.map_name;
          row.appendChild(mapCell);
          
          // Date cell
          const dateCell = document.createElement('td');
          dateCell.textContent = new Date(poi.created_at).toLocaleDateString();
          row.appendChild(dateCell);
          
          // Status cell
          const statusCell = document.createElement('td');
          const statusBadge = getStatusBadge(poi.status);
          if (window.safeHTML) {
            statusCell.innerHTML = window.safeHTML(statusBadge);
          } else {
            statusCell.innerHTML = statusBadge; // Safe - our generated HTML
          }
          row.appendChild(statusCell);
          
          // Share cell
          const shareCell = document.createElement('td');
          const shareCount = poi.share_count || 0;
          
          const shareLink = document.createElement('a');
          shareLink.href = '#';
          shareLink.style.color = shareCount > 0 ? '#4dff4d' : '#999';
          shareLink.style.textDecoration = 'none';
          shareLink.style.cursor = 'pointer';
          shareLink.style.transition = 'all 0.2s';
          shareLink.textContent = `${shareCount} user${shareCount !== 1 ? 's' : ''}`;
          
          // Add glow effect for counts > 0
          if (shareCount > 0) {
            shareLink.style.textShadow = '0 0 8px rgba(77, 255, 77, 0.6), 0 0 12px rgba(77, 255, 77, 0.4)';
          }
          
          shareLink.onmouseover = () => {
            shareLink.style.textDecoration = 'underline';
            if (shareCount > 0) {
              shareLink.style.textShadow = '0 0 10px rgba(77, 255, 77, 0.8), 0 0 15px rgba(77, 255, 77, 0.6)';
            }
          };
          shareLink.onmouseout = () => {
            shareLink.style.textDecoration = 'none';
            if (shareCount > 0) {
              shareLink.style.textShadow = '0 0 8px rgba(77, 255, 77, 0.6), 0 0 12px rgba(77, 255, 77, 0.4)';
            }
          };
          shareLink.onclick = (e) => {
            e.preventDefault();
            viewSharedUsers(poi.id);
          };
          shareCell.appendChild(shareLink);
          row.appendChild(shareCell);
          
          // Actions cell
          const actionCell = document.createElement('td');
          actionCell.appendChild(createPoiActionButtons(poi));
          row.appendChild(actionCell);
          
          tbody.appendChild(row);
        });
        
        // Update pagination controls
        document.getElementById('my-pois-page-info').textContent = `Page ${myPoisCurrentPage} of ${totalPages}`;
        document.getElementById('my-pois-prev').disabled = myPoisCurrentPage === 1;
        document.getElementById('my-pois-next').disabled = myPoisCurrentPage === totalPages;
      }
    }
    
    function displaySharedPois(sharedPois) {
      // Always display shared POIs section
      document.getElementById('shared-pois-section').style.display = 'block';
      
      const totalPages = Math.ceil(sharedPois.length / ITEMS_PER_PAGE);
      sharedPoisCurrentPage = Math.max(1, Math.min(sharedPoisCurrentPage, totalPages || 1));
      
      const sharedTbody = document.getElementById('shared-pois-tbody');
      sharedTbody.innerHTML = '';
      
      if (sharedPois.length > 0) {
        // Only show pagination if there's more than one page
        document.getElementById('shared-pois-pagination').style.display = totalPages > 1 ? 'flex' : 'none';
        
        // Calculate pagination
        const startIndex = (sharedPoisCurrentPage - 1) * ITEMS_PER_PAGE;
        const endIndex = startIndex + ITEMS_PER_PAGE;
        const pageItems = sharedPois.slice(startIndex, endIndex);
        
        pageItems.forEach(poi => {
          const row = document.createElement('tr');
          const isActive = poi.is_shared_active !== false; // Default to active if not specified
          
          // If revoked, add a visual indicator to the row
          if (!isActive) {
            row.style.opacity = '0.6';
          }
          
          // Icon cell
          const iconCell = document.createElement('td');
          iconCell.style.textAlign = 'center';
          iconCell.style.fontSize = '1.5rem';
          iconCell.textContent = poi.icon;
          row.appendChild(iconCell);
          
          // Name cell
          row.appendChild(createTextCell(poi.name));
          
          // Map cell
          row.appendChild(createTextCell(poi.map_name));
          
          // Owner cell
          row.appendChild(createTextCell(poi.owner_name));
          
          // Status cell
          const statusCell = document.createElement('td');
          if (!isActive && poi.invalidation_reason === 'published') {
            // Source custom POI was deleted (published) - show as Invalidated
            const invalidatedSpan = document.createElement('span');
            invalidatedSpan.style.background = '#ffc107';
            invalidatedSpan.style.color = '#2a1810';
            invalidatedSpan.style.padding = '0.2rem 0.5rem';
            invalidatedSpan.style.borderRadius = '4px';
            invalidatedSpan.style.fontSize = '0.8rem';
            invalidatedSpan.style.fontWeight = 'bold';
            invalidatedSpan.textContent = 'Invalidated';
            invalidatedSpan.title = 'The source POI has been published and is now public. You can remove this share.';
            statusCell.appendChild(invalidatedSpan);
          } else if (poi.status === 'published') {
            const publishedSpan = document.createElement('span');
            publishedSpan.style.background = '#FFD700';
            publishedSpan.style.color = '#2a1810';
            publishedSpan.style.padding = '0.2rem 0.5rem';
            publishedSpan.style.borderRadius = '4px';
            publishedSpan.style.fontSize = '0.8rem';
            publishedSpan.style.fontWeight = 'bold';
            publishedSpan.textContent = 'Published';
            publishedSpan.title = 'This POI has been approved and is now public!';
            statusCell.appendChild(publishedSpan);
          } else if (isActive) {
            const activeSpan = document.createElement('span');
            activeSpan.style.background = '#28a745';
            activeSpan.style.color = 'white';
            activeSpan.style.padding = '0.2rem 0.5rem';
            activeSpan.style.borderRadius = '4px';
            activeSpan.style.fontSize = '0.8rem';
            activeSpan.textContent = 'Active';
            statusCell.appendChild(activeSpan);
          } else {
            const revokedSpan = document.createElement('span');
            revokedSpan.style.background = '#dc3545';
            revokedSpan.style.color = 'white';
            revokedSpan.style.padding = '0.2rem 0.5rem';
            revokedSpan.style.borderRadius = '4px';
            revokedSpan.style.fontSize = '0.8rem';
            revokedSpan.textContent = 'Revoked';
            statusCell.appendChild(revokedSpan);
          }
          row.appendChild(statusCell);
          
          // Actions cell
          const actionsCell = document.createElement('td');
          const actionsDiv = document.createElement('div');
          actionsDiv.className = 'action-buttons';
          
          // View button - disabled for revoked POIs
          const viewBtn = document.createElement('button');
          viewBtn.className = 'small-btn info-btn';
          if (isActive) {
            viewBtn.onclick = () => goToPoi(poi.id, poi.map_id, poi.x, poi.y);
          } else {
            viewBtn.disabled = true;
            viewBtn.style.opacity = '0.5';
            viewBtn.style.cursor = 'not-allowed';
            viewBtn.title = 'This POI has been revoked';
          }
          const viewIcon = document.createElement('span');
          viewIcon.className = 'btn-icon';
          viewIcon.textContent = '';
          viewBtn.appendChild(viewIcon);
          viewBtn.appendChild(document.createTextNode('View'));
          
          // Remove button
          const removeBtn = document.createElement('button');
          removeBtn.className = 'small-btn danger-btn';
          removeBtn.onclick = () => removeSharedPoi(poi.id);
          const removeIcon = document.createElement('span');
          removeIcon.className = 'btn-icon';
          removeIcon.textContent = '';
          removeBtn.appendChild(removeIcon);
          removeBtn.appendChild(document.createTextNode('Remove'));
          
          actionsDiv.appendChild(viewBtn);
          actionsDiv.appendChild(removeBtn);
          actionsCell.appendChild(actionsDiv);
          row.appendChild(actionsCell);
          
          sharedTbody.appendChild(row);
        });
        
        // Update pagination controls
        document.getElementById('shared-pois-page-info').textContent = `Page ${sharedPoisCurrentPage} of ${totalPages}`;
        document.getElementById('shared-pois-prev').disabled = sharedPoisCurrentPage === 1;
        document.getElementById('shared-pois-next').disabled = sharedPoisCurrentPage === totalPages;
      } else {
        document.getElementById('shared-pois-pagination').style.display = 'none';
        const row = document.createElement('tr');
        row.innerHTML = `
          <td colspan="6" style="text-align: center; color: #666; padding: 2rem;">
            No POIs have been shared with you yet. When someone shares a POI with you, it will appear here.
          </td>
        `;
        sharedTbody.appendChild(row);
      }
    }

    function goToPoi(poiId, mapId, x, y) {
      // Store POI location in sessionStorage to highlight it when the map loads
      sessionStorage.setItem('highlightCustomPoi', JSON.stringify({ id: poiId, mapId, x, y }));
      window.open('/', '_blank');
    }

    async function sharePoi(poiId) {
      try {
        const response = await window.csrfHelper.fetchWithCSRF(`/api/custom-pois/${poiId}/share`, {
          method: 'POST'
        });
        
        if (response.ok) {
          const data = await response.json();
          showShareCodeModal(data.shareCode, poiId);
        } else {
          const error = await response.json();
          showMessage(error.error || 'Failed to create share code', 'error');
        }
      } catch (error) {
        console.error('Error in sharePoi:', error);
        showMessage('Failed to create share code', 'error');
      }
    }

    async function deletePoi(poiId) {
      if (!confirm('Are you sure you want to delete this custom POI? This will also remove it from anyone you shared it with and from pending community approval if applicable.')) {
        return;
      }
      
      try {
        const response = await window.csrfHelper.fetchWithCSRF(`/api/custom-pois/${poiId}`, {
          method: 'DELETE'
        });
        
        if (response.ok) {
          showMessage('Custom POI deleted', 'success');
          loadCustomPois(); // Reload the list
          // loadPendingPois(); // Removed - pending POIs system no longer used
        } else {
          const error = await response.json();
          showMessage(error.error || 'Failed to delete custom POI', 'error');
        }
      } catch (error) {
        console.error('Error in deletePoi:', error);
        showMessage('Failed to delete custom POI', 'error');
      }
    }

    async function removeSharedPoi(poiId) {
      if (!confirm('Are you sure you want to remove this shared POI? You will no longer have access to it.')) {
        return;
      }
      
      try {
        const response = await window.csrfHelper.fetchWithCSRF(`/api/custom-pois/${poiId}/unshare`, {
          method: 'DELETE'
        });
        
        if (response.ok) {
          showMessage('Shared POI removed', 'success');
          loadCustomPois(); // Reload the list
        }
      } catch (error) {
        showMessage('Failed to remove shared POI', 'error');
      }
    }
    
    // Helper functions for POI display
    function getStatusBadge(status) {
      switch(status) {
        case 'private':
          return '<span style="color: #999;">Private</span>';
        case 'pending':
          return '<span style="color: #FFA500;">Pending</span>';
        case 'published':
          return '<span style="color: #4CAF50;">Published</span>';
        case 'rejected':
          return '<span style="color: #f44336;">Rejected</span>';
        default:
          return '<span style="color: #999;">Private</span>';
      }
    }
    
    function createPoiActionButtons(poi) {
      const container = document.createElement('div');
      container.className = 'action-buttons';
      
      // Primary actions group
      const primaryGroup = document.createElement('div');
      primaryGroup.className = 'action-group';
      
      // View button
      const viewBtn = document.createElement('button');
      viewBtn.className = 'small-btn info-btn';
      viewBtn.setAttribute('data-action', 'goToPoi');
      viewBtn.setAttribute('data-args', `${poi.id}, ${poi.map_id}, ${poi.x}, ${poi.y}`);
      
      const viewIcon = document.createElement('span');
      viewIcon.className = 'btn-icon';
      viewIcon.textContent = '';
      viewBtn.appendChild(viewIcon);
      viewBtn.appendChild(document.createTextNode('View'));
      
      primaryGroup.appendChild(viewBtn);
      
      // Publish button (if applicable)
      if (poi.status === 'private' || poi.status === 'rejected' || poi.status === null || !poi.status) {
        const publishBtn = document.createElement('button');
        publishBtn.className = 'small-btn warning-btn';
        publishBtn.setAttribute('data-action', 'publishPoi');
        publishBtn.setAttribute('data-args', poi.id.toString());
        
        const publishIcon = document.createElement('span');
        publishIcon.className = 'btn-icon';
        publishIcon.textContent = '';
        publishBtn.appendChild(publishIcon);
        publishBtn.appendChild(document.createTextNode('Publish'));
        
        primaryGroup.appendChild(publishBtn);
      }
      
      container.appendChild(primaryGroup);
      
      // Secondary actions group (if not published)
      if (poi.status !== 'published') {
        const secondaryGroup = document.createElement('div');
        secondaryGroup.className = 'action-group';
        
        // Share button
        const shareBtn = document.createElement('button');
        shareBtn.className = 'small-btn secondary-btn';
        shareBtn.setAttribute('data-action', 'sharePoi');
        shareBtn.setAttribute('data-args', poi.id.toString());
        
        const shareIcon = document.createElement('span');
        shareIcon.className = 'btn-icon';
        shareIcon.textContent = '';
        shareBtn.appendChild(shareIcon);
        shareBtn.appendChild(document.createTextNode('Share'));
        
        secondaryGroup.appendChild(shareBtn);
        
        // Delete button
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'small-btn danger-btn';
        deleteBtn.setAttribute('data-action', 'deletePoi');
        deleteBtn.setAttribute('data-args', poi.id.toString());
        
        const deleteIcon = document.createElement('span');
        deleteIcon.className = 'btn-icon';
        deleteIcon.textContent = '';
        deleteBtn.appendChild(deleteIcon);
        deleteBtn.appendChild(document.createTextNode('Delete'));
        
        secondaryGroup.appendChild(deleteBtn);
        
        container.appendChild(secondaryGroup);
      }
      
      
      return container;
    }
    
    // Publish POI function
    async function publishPoi(poiId) {
      if (!confirm('Are you sure you want to submit this POI for community approval? Once approved, it will become a permanent part of the map.')) {
        return;
      }
      
      try {
        const response = await window.csrfHelper.fetchWithCSRF(`/api/custom-pois/${poiId}/publish`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          }
        });
        
        if (response.ok) {
          showMessage('POI submitted for approval!', 'success');
          loadCustomPois(); // Reload the list
          // loadPendingPois(); // Removed - pending POIs system no longer used
        } else {
          const error = await response.json();
          showMessage(error.error || 'Failed to publish POI', 'error');
        }
      } catch (error) {
        showMessage('Failed to publish POI', 'error');
      }
    }
    
    // Pagination functions
    function changeMyPoisPage(direction) {
      const ownedPois = customPois.filter(poi => poi.is_owner);
      const totalPages = Math.ceil(ownedPois.length / ITEMS_PER_PAGE);
      
      myPoisCurrentPage += direction;
      myPoisCurrentPage = Math.max(1, Math.min(myPoisCurrentPage, totalPages));
      
      displayMyPois(ownedPois);
    }
    
    function changeSharedPoisPage(direction) {
      const sharedPois = customPois.filter(poi => !poi.is_owner);
      const totalPages = Math.ceil(sharedPois.length / ITEMS_PER_PAGE);
      
      sharedPoisCurrentPage += direction;
      sharedPoisCurrentPage = Math.max(1, Math.min(sharedPoisCurrentPage, totalPages));
      
      displaySharedPois(sharedPois);
    }
    
    // Pending POIs functionality - DEPRECATED (replaced by change proposals system)
    /*
    async function loadPendingPois() {
      document.getElementById('pending-pois-loading').style.display = 'block';
      
      try {
        const response = await fetch('/api/pending-pois');
        if (response.ok) {
          pendingPois = await response.json();
          displayPendingPois();
        }
      } catch (error) {
        console.error('Error loading pending POIs:', error);
      } finally {
        document.getElementById('pending-pois-loading').style.display = 'none';
      }
    }
    */
    
    function displayPendingPois() {
      const totalPages = Math.ceil(pendingPois.length / ITEMS_PER_PAGE);
      pendingPoisCurrentPage = Math.max(1, Math.min(pendingPoisCurrentPage, totalPages || 1));
      
      const tbody = document.getElementById('pending-pois-tbody');
      tbody.innerHTML = '';
      
      if (pendingPois.length === 0) {
        document.getElementById('pending-pois-pagination').style.display = 'none';
        const row = document.createElement('tr');
        row.innerHTML = `
          <td colspan="7" style="text-align: center; color: #666; padding: 2rem;">
            No POIs are currently pending community approval.
          </td>
        `;
        tbody.appendChild(row);
      } else {
        // Only show pagination if there's more than one page
        document.getElementById('pending-pois-pagination').style.display = totalPages > 1 ? 'flex' : 'none';
        
        // Calculate pagination
        const startIndex = (pendingPoisCurrentPage - 1) * ITEMS_PER_PAGE;
        const endIndex = startIndex + ITEMS_PER_PAGE;
        const pageItems = pendingPois.slice(startIndex, endIndex);
        
        pageItems.forEach(poi => {
          const row = document.createElement('tr');
          row.className = 'poi-data-row';
          const voteButtonsElement = createVoteButtons(poi);
          
          // Build row using DOM methods for safety
          // Icon cell
          const iconCell = document.createElement('td');
          iconCell.style.textAlign = 'center';
          iconCell.style.fontSize = '1.5rem';
          iconCell.textContent = poi.icon;
          row.appendChild(iconCell);
          
          // Name cell
          row.appendChild(createTextCell(poi.name));
          
          // Map cell
          row.appendChild(createTextCell(poi.map_name));
          
          // Creator cell
          row.appendChild(createTextCell(poi.creator_name));
          
          // Vote score cell
          const voteScoreCell = document.createElement('td');
          voteScoreCell.className = 'vote-score';
          voteScoreCell.textContent = (poi.vote_score > 0 ? '+' : '') + poi.vote_score;
          row.appendChild(voteScoreCell);
          
          // Vote buttons cell
          const voteBtnCell = document.createElement('td');
          voteBtnCell.appendChild(voteButtonsElement);
          row.appendChild(voteBtnCell);
          
          // Actions cell
          const actionsCell = document.createElement('td');
          const actionsDiv = document.createElement('div');
          actionsDiv.className = 'action-buttons';
          
          // Action group
          const actionGroup = document.createElement('div');
          actionGroup.className = 'action-group';
          
          // View button
          const viewBtn = document.createElement('button');
          viewBtn.className = 'small-btn info-btn';
          viewBtn.onclick = () => goToPoi(poi.custom_poi_id, poi.map_id, poi.x, poi.y);
          const viewIcon = document.createElement('span');
          viewIcon.className = 'btn-icon';
          viewIcon.textContent = '';
          viewBtn.appendChild(viewIcon);
          viewBtn.appendChild(document.createTextNode('View'));
          actionGroup.appendChild(viewBtn);
          
          // Inspect button (admin only)
          if (currentUser && currentUser.is_admin) {
            const inspectBtn = document.createElement('button');
            inspectBtn.className = 'small-btn secondary-btn';
            inspectBtn.onclick = () => inspectVotes(poi.id, poi.name);
            const inspectIcon = document.createElement('span');
            inspectIcon.className = 'btn-icon';
            inspectIcon.textContent = '';
            inspectBtn.appendChild(inspectIcon);
            inspectBtn.appendChild(document.createTextNode('Inspect'));
            actionGroup.appendChild(inspectBtn);
          }
          
          actionsDiv.appendChild(actionGroup);
          
          // Admin actions
          if (currentUser && currentUser.is_admin) {
            const adminGroup = document.createElement('div');
            adminGroup.className = 'action-group admin-actions';
            
            // Approve button
            const approveBtn = document.createElement('button');
            approveBtn.className = 'small-btn success-btn';
            approveBtn.onclick = () => forcePublishPoi(poi.id);
            const approveIcon = document.createElement('span');
            approveIcon.className = 'btn-icon';
            approveIcon.textContent = '';
            approveBtn.appendChild(approveIcon);
            approveBtn.appendChild(document.createTextNode('Approve'));
            adminGroup.appendChild(approveBtn);
            
            // Reject button
            const rejectBtn = document.createElement('button');
            rejectBtn.className = 'small-btn danger-btn';
            rejectBtn.onclick = () => forceRejectPoi(poi.id);
            const rejectIcon = document.createElement('span');
            rejectIcon.className = 'btn-icon';
            rejectIcon.textContent = '';
            rejectBtn.appendChild(rejectIcon);
            rejectBtn.appendChild(document.createTextNode('Reject'));
            adminGroup.appendChild(rejectBtn);
            
            actionsDiv.appendChild(adminGroup);
          }
          
          actionsCell.appendChild(actionsDiv);
          row.appendChild(actionsCell);
          tbody.appendChild(row);
          
          // Add status bar row
          const statusRow = document.createElement('tr');
          statusRow.className = 'vote-status-row';
          statusRow.innerHTML = `
            <td colspan="7" style="padding: 0;">
              <div class="vote-status-bar">
                <div class="vote-bar-track">
                  <span class="vote-label reject">Rejected (-10)</span>
                  <div class="vote-bar-container">
                    <div class="vote-bar-fill" style="left: ${poi.vote_score < 0 ? 50 + (poi.vote_score * 5) : 50}%; width: ${Math.abs(poi.vote_score * 5)}%; background-color: ${poi.vote_score >= 0 ? '#28a745' : '#dc3545'};"></div>
                    <div class="vote-bar-center"></div>
                  </div>
                  <span class="vote-label approve">Approved (+10)</span>
                </div>
              </div>
            </td>
          `;
          tbody.appendChild(statusRow);
        });
        
        // Update pagination controls
        document.getElementById('pending-pois-page-info').textContent = `Page ${pendingPoisCurrentPage} of ${totalPages}`;
        document.getElementById('pending-pois-prev').disabled = pendingPoisCurrentPage === 1;
        document.getElementById('pending-pois-next').disabled = pendingPoisCurrentPage === totalPages;
      }
    }
    
    function createVoteButtons(poi) {
      const container = document.createElement('div');
      container.className = 'vote-buttons';
      
      // Upvote button
      const upvoteBtn = document.createElement('button');
      upvoteBtn.className = 'vote-btn upvote' + (poi.user_vote === 1 ? ' active' : '');
      upvoteBtn.setAttribute('data-action', 'votePoi');
      upvoteBtn.setAttribute('data-args', `${poi.id},1,${poi.is_creator ? 'true' : 'false'}`);
      upvoteBtn.setAttribute('title', 'Upvote');
      upvoteBtn.textContent = '';
      container.appendChild(upvoteBtn);
      
      // Downvote button
      const downvoteBtn = document.createElement('button');
      downvoteBtn.className = 'vote-btn downvote' + (poi.user_vote === -1 ? ' active' : '');
      downvoteBtn.setAttribute('data-action', 'votePoi');
      downvoteBtn.setAttribute('data-args', `${poi.id},-1,${poi.is_creator ? 'true' : 'false'}`);
      downvoteBtn.setAttribute('title', poi.is_creator ? 'Withdraw from voting' : 'Downvote');
      downvoteBtn.textContent = '';
      container.appendChild(downvoteBtn);
      
      return container;
    }
    
    async function votePoi(poiId, vote, isCreator = false) {
      
      // Convert string 'true'/'false' to boolean
      const isCreatorBool = isCreator === true || isCreator === 'true';
      
      // Check if creator is downvoting their own POI
      if (isCreatorBool && vote === -1) {
        if (!confirm('Are you sure you want to withdraw your POI from community voting? This will remove it from the pending list and return it to private status.')) {
          return;
        }
      }
      
      try {
        const response = await window.csrfHelper.fetchWithCSRF(`/api/pending-pois/${poiId}/vote`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ vote })
        });
        
        if (response.ok) {
          const result = await response.json();
          if (result.approved) {
            showMessage('POI approved and published!', 'success');
          } else if (result.rejected) {
            showMessage('POI rejected', 'info');
          } else if (result.withdrawn) {
            showMessage('POI withdrawn from community voting', 'success');
          }
          // loadPendingPois(); // Removed - pending POIs system no longer used
          loadCustomPois(); // Also reload custom POIs if withdrawn
        } else {
          const error = await response.json();
          console.error('Vote failed:', error);
          showMessage(error.error || 'Failed to vote', 'error');
        }
      } catch (error) {
        console.error('Vote error:', error);
        showMessage('Failed to vote', 'error');
      }
    }
    
    async function forcePublishPoi(poiId) {
      if (!confirm('Are you sure you want to force-publish this POI? This will bypass the normal voting process.')) {
        return;
      }
      
      try {
        const response = await window.csrfHelper.fetchWithCSRF(`/api/pending-pois/${poiId}/force-publish`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          }
        });
        
        if (response.ok) {
          showMessage('POI approved and published! It will now appear on the map.', 'success');
          // loadPendingPois(); // Removed - pending POIs system no longer used
          loadCustomPois(); // Reload My POIs to show updated status
        } else {
          const error = await response.json();
          showMessage(error.error || 'Failed to force-publish POI', 'error');
        }
      } catch (error) {
        showMessage('Failed to force-publish POI', 'error');
      }
    }
    
    async function forceRejectPoi(poiId) {
      if (!confirm('Are you sure you want to force-reject this POI? This will bypass the normal voting process and remove XP from the creator.')) {
        return;
      }
      
      try {
        const response = await window.csrfHelper.fetchWithCSRF(`/api/pending-pois/${poiId}/force-reject`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          }
        });
        
        if (response.ok) {
          showMessage('POI rejected and returned to creator with "Rejected" status.', 'success');
          // loadPendingPois(); // Removed - pending POIs system no longer used
          loadCustomPois(); // Reload My POIs to show updated status
        } else {
          const error = await response.json();
          showMessage(error.error || 'Failed to force-reject POI', 'error');
        }
      } catch (error) {
        showMessage('Failed to force-reject POI', 'error');
      }
    }
    
    // Modal functions
    async function inspectVotes(poiId, poiName) {
      try {
        const response = await fetch(`/api/pending-pois/${poiId}/votes`);
        if (response.ok) {
          const votes = await response.json();
          displayVoteModal(poiName, votes);
        } else {
          showMessage('Failed to load vote details', 'error');
        }
      } catch (error) {
        showMessage('Failed to load vote details', 'error');
      }
    }
    
    function displayVoteModal(poiName, votes) {
      document.getElementById('inspect-poi-name').textContent = poiName;
      
      // Calculate vote stats
      const upvotes = votes.filter(v => v.vote === 1).length;
      const downvotes = votes.filter(v => v.vote === -1).length;
      const totalScore = upvotes - downvotes;
      
      document.getElementById('inspect-poi-stats').textContent = 
        `Total Score: ${totalScore > 0 ? '+' : ''}${totalScore} (${upvotes} upvotes, ${downvotes} downvotes)`;
      
      // Populate vote table
      const tbody = document.getElementById('vote-details-tbody');
      tbody.innerHTML = '';
      
      if (votes.length === 0) {
        tbody.innerHTML = '<tr><td colspan="3" style="text-align: center; color: #666;">No votes yet</td></tr>';
      } else {
        votes.forEach(vote => {
          const row = document.createElement('tr');
          const voteIcon = vote.vote === 1 ? '' : '';
          const voteClass = vote.vote === 1 ? 'color: #4CAF50;' : 'color: #f44336;';
          
          row.innerHTML = `
            <td>${vote.voter_name} <span style="color: #666; font-size: 0.85rem;">(${vote.voter_email})</span></td>
            <td style="text-align: center; ${voteClass} font-size: 1.2rem;">${voteIcon}</td>
            <td>${new Date(vote.created_at).toLocaleString()}</td>
          `;
          tbody.appendChild(row);
        });
      }
      
      // Show modal
      document.getElementById('vote-inspect-modal').style.display = 'block';
    }
    
    function closeVoteModal() {
      document.getElementById('vote-inspect-modal').style.display = 'none';
    }
    
    // Close modal when clicking outside
    window.onclick = function(event) {
      const modal = document.getElementById('vote-inspect-modal');
      if (event.target === modal) {
        closeVoteModal();
      }
    }

    // Update showTab to load custom POIs when tab is clicked
    const originalShowTab = showTab;
    showTab = function(tabName) {
      originalShowTab(tabName);
      
      if (tabName === 'custom-pois') {
        // Always reload to get fresh data
        loadCustomPois();
      } else if (tabName === 'admin' && currentUser?.is_admin) {
        loadXPConfig();
        loadWelcomeMessage();
        loadUsers();
      }
    };

    // Item Editor Functions
    let gameItems = [];
    let filteredGameItems = [];
    let currentGameItemPage = 0;
    const GAME_ITEMS_PER_PAGE = 20;
    let editingGameItem = null;
    let currentItemEmojiCategory = 'harvest';
    let itemChanges = new Map(); // Track staged changes for items
    
    async function loadItemEditor() {
      const loading = document.getElementById('item-editor-loading');
      const content = document.getElementById('item-editor-content');
      
      try {
        const response = await fetch('/api/items');
        if (response.ok) {
          gameItems = await response.json();
          filterItemsByType();
          loading.style.display = 'none';
          content.style.display = 'block';
        } else if (response.status === 404) {
          loading.innerHTML = '<p style="color: #dc3545;">Items API not found. Please implement /api/items endpoint.</p>';
        } else {
          loading.innerHTML = '<p style="color: #dc3545;">Failed to load items. Server returned: ' + response.status + '</p>';
        }
      } catch (error) {
        console.error('Error loading items:', error);
        loading.innerHTML = '<p style="color: #dc3545;">Failed to load items. The /api/items endpoint needs to be implemented.</p>';
      }
    }
    
    function filterItemsByType() {
      const typeFilter = document.getElementById('item-type-filter').value;
      const searchTerm = document.getElementById('item-search').value.toLowerCase();
      
      filteredGameItems = gameItems.filter(item => {
        const matchesType = typeFilter === 'all' || item.item_type === typeFilter;
        const matchesSearch = !searchTerm || 
          item.name.toLowerCase().includes(searchTerm) ||
          (item.description && item.description.toLowerCase().includes(searchTerm)) ||
          item.id.toString().includes(searchTerm);
        
        return matchesType && matchesSearch;
      });
      
      currentGameItemPage = 0;
      displayItems();
    }
    
    function searchItems() {
      filterItemsByType();
    }
    
    function displayItems() {
      const tbody = document.getElementById('item-editor-tbody');
      tbody.innerHTML = '';
      
      const totalPages = Math.ceil(filteredGameItems.length / GAME_ITEMS_PER_PAGE);
      const startIndex = currentGameItemPage * GAME_ITEMS_PER_PAGE;
      const endIndex = Math.min(startIndex + GAME_ITEMS_PER_PAGE, filteredGameItems.length);
      const pageItems = filteredGameItems.slice(startIndex, endIndex);
      
      // Update counts
      document.getElementById('item-total-count').textContent = gameItems.length;
      document.getElementById('item-filtered-count').textContent = filteredGameItems.length;
      
      // Update pagination info
      const paginationInfo = document.getElementById('item-editor-pagination-info');
      if (filteredGameItems.length > 0) {
        paginationInfo.textContent = `Showing ${startIndex + 1}-${endIndex} of ${filteredGameItems.length} items`;
      } else {
        paginationInfo.textContent = 'No items found';
      }
      
      pageItems.forEach(item => {
        const row = createItemEditorRow(item);
        tbody.appendChild(row);
      });
      
      // Update pagination
      displayItemPagination();
      updateItemChangeButtons();
    }
    
    function createItemEditorRow(item) {
      const row = document.createElement('tr');
      row.id = `item-row-${item.id}`;
      
      // ID
      const idCell = document.createElement('td');
      idCell.textContent = item.id;
      row.appendChild(idCell);
      
      // Icon
      const iconCell = document.createElement('td');
      iconCell.style.textAlign = 'center';
      iconCell.style.cursor = 'pointer';
      iconCell.onclick = () => showItemIconPicker(item.id);
      if (item.icon_type === 'emoji') {
        iconCell.style.fontSize = '1.5rem';
        iconCell.textContent = item.icon_value;
      } else if (item.icon_type === 'iconify') {
        iconCell.innerHTML = `<iconify-icon icon="${item.icon_value}" width="24" height="24"></iconify-icon>`;
      } else if (item.icon_type === 'upload') {
        const img = document.createElement('img');
        img.src = item.icon_value;
        img.style.width = '32px';
        img.style.height = '32px';
        img.style.objectFit = 'contain';
        iconCell.appendChild(img);
      }
      iconCell.title = 'Click to change icon';
      row.appendChild(iconCell);
      
      // Name
      const nameCell = document.createElement('td');
      const nameInput = document.createElement('input');
      nameInput.type = 'text';
      nameInput.value = item.name;
      nameInput.className = 'inline-edit';
      nameInput.style.width = '100%';
      nameInput.style.fontWeight = 'bold';
      nameInput.dataset.field = 'name';
      nameInput.dataset.original = item.name;
      nameInput.onblur = () => stageItemChange(item.id, 'name', nameInput.value);
      nameInput.onkeypress = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          nameInput.blur();
        }
      };
      nameCell.appendChild(nameInput);
      row.appendChild(nameCell);
      
      // Type
      const typeCell = document.createElement('td');
      const typeSelect = document.createElement('select');
      typeSelect.className = 'inline-edit';
      typeSelect.style.width = '100%';
      typeSelect.dataset.field = 'item_type';
      typeSelect.dataset.original = item.item_type || '';
      ['', 'weapon', 'armor', 'consumable', 'material', 'jewelry', 'misc'].forEach(type => {
        const option = document.createElement('option');
        option.value = type;
        option.textContent = type || '-';
        if (type === (item.item_type || '')) option.selected = true;
        typeSelect.appendChild(option);
      });
      typeSelect.onchange = () => stageItemChange(item.id, 'item_type', typeSelect.value);
      typeCell.appendChild(typeSelect);
      row.appendChild(typeCell);
      
      // Slot(s) - Multi-select
      const slotCell = document.createElement('td');
      slotCell.style.position = 'relative';
      
      // Create display div for selected slots
      const slotDisplay = document.createElement('div');
      slotDisplay.className = 'slot-display';
      slotDisplay.style.cssText = 'cursor: pointer; padding: 4px; background: #2d2d2d; border: 1px solid #555; border-radius: 4px; min-height: 28px; font-size: 0.85rem;';
      
      // Convert slots array or single slot to display text
      const currentSlots = item.slots || (item.slot ? [item.slot] : []);
      slotDisplay.textContent = currentSlots.length > 0 ? 
        currentSlots.map(s => {
          const slot = [
            { value: 'main_hand', label: 'Main Hand' },
            { value: 'off_hand', label: 'Off Hand' },
            { value: 'two_hand', label: 'Two Hand' },
            { value: 'head', label: 'Head' },
            { value: 'chest', label: 'Chest' },
            { value: 'legs', label: 'Legs' },
            { value: 'feet', label: 'Feet' },
            { value: 'hands', label: 'Hands' },
            { value: 'neck', label: 'Neck' },
            { value: 'ring', label: 'Ring' },
            { value: 'trinket', label: 'Trinket' }
          ].find(slot => slot.value === s);
          return slot ? slot.label : s;
        }).join(', ') : 'None';
      
      slotDisplay.onclick = () => {
        // Create multi-select dropdown
        const dropdown = document.createElement('div');
        dropdown.style.cssText = `
          position: absolute;
          top: 100%;
          left: 0;
          right: 0;
          background: #2d2d2d;
          border: 1px solid #666;
          border-radius: 4px;
          box-shadow: 0 4px 12px rgba(0,0,0,0.5);
          z-index: 1000;
          max-height: 300px;
          overflow-y: auto;
          margin-top: 2px;
        `;
        
        const selectedSlots = new Set(currentSlots);
        
        const slotOptions = [
          { value: 'main_hand', label: 'Main Hand' },
          { value: 'off_hand', label: 'Off Hand' },
          { value: 'two_hand', label: 'Two Hand' },
          { value: 'head', label: 'Head' },
          { value: 'chest', label: 'Chest' },
          { value: 'legs', label: 'Legs' },
          { value: 'feet', label: 'Feet' },
          { value: 'hands', label: 'Hands' },
          { value: 'neck', label: 'Neck' },
          { value: 'ring', label: 'Ring' },
          { value: 'trinket', label: 'Trinket' }
        ];
        
        slotOptions.forEach(slot => {
          const option = document.createElement('div');
          option.style.cssText = 'padding: 8px; cursor: pointer; display: flex; align-items: center; gap: 8px;';
          option.onmouseover = () => option.style.background = '#444';
          option.onmouseout = () => option.style.background = 'transparent';
          
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.checked = selectedSlots.has(slot.value);
          checkbox.onchange = (e) => {
            e.stopPropagation();
            if (checkbox.checked) {
              selectedSlots.add(slot.value);
            } else {
              selectedSlots.delete(slot.value);
            }
            
            // Update display
            const newSlots = Array.from(selectedSlots);
            slotDisplay.textContent = newSlots.length > 0 ?
              newSlots.map(s => slotOptions.find(opt => opt.value === s)?.label || s).join(', ') : 'None';
            
            // Stage the change
            stageItemChange(item.id, 'slots', newSlots);
            stageItemChange(item.id, 'slot', newSlots[0] || ''); // Keep backward compatibility
          };
          
          const label = document.createElement('label');
          label.textContent = slot.label;
          label.style.cursor = 'pointer';
          label.style.flex = '1';
          
          option.appendChild(checkbox);
          option.appendChild(label);
          option.onclick = (e) => {
            if (e.target !== checkbox) {
              checkbox.checked = !checkbox.checked;
              checkbox.onchange(e);
            }
          };
          
          dropdown.appendChild(option);
        });
        
        // Close on click outside
        const closeDropdown = (e) => {
          if (!dropdown.contains(e.target) && e.target !== slotDisplay) {
            dropdown.remove();
            document.removeEventListener('click', closeDropdown);
          }
        };
        
        slotCell.appendChild(dropdown);
        setTimeout(() => document.addEventListener('click', closeDropdown), 0);
      };
      
      slotCell.appendChild(slotDisplay);
      row.appendChild(slotCell);
      
      // Weight
      const weightCell = document.createElement('td');
      const weightInput = document.createElement('input');
      weightInput.type = 'number';
      weightInput.value = item.weight || 0;
      weightInput.className = 'inline-edit';
      weightInput.style.textAlign = 'center';
      weightInput.style.width = '100%';
      weightInput.min = '0';
      weightInput.max = '9999.99';
      weightInput.step = '0.01';
      weightInput.dataset.field = 'weight';
      weightInput.dataset.original = item.weight || 0;
      weightInput.onblur = () => stageItemChange(item.id, 'weight', parseFloat(weightInput.value) || 0);
      weightInput.onkeypress = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          weightInput.blur();
        }
      };
      weightCell.appendChild(weightInput);
      row.appendChild(weightCell);
      
      // Size
      const sizeCell = document.createElement('td');
      const sizeSelect = document.createElement('select');
      sizeSelect.className = 'inline-edit';
      sizeSelect.style.width = '100%';
      sizeSelect.dataset.field = 'size';
      sizeSelect.dataset.original = item.size || 'Medium';
      ['Small', 'Medium', 'Large', 'Giant'].forEach(size => {
        const option = document.createElement('option');
        option.value = size;
        option.textContent = size;
        if (size === (item.size || 'Medium')) option.selected = true;
        sizeSelect.appendChild(option);
      });
      sizeSelect.onchange = () => stageItemChange(item.id, 'size', sizeSelect.value);
      sizeCell.appendChild(sizeSelect);
      row.appendChild(sizeCell);
      
      // Skill
      const skillCell = document.createElement('td');
      const skillSelect = document.createElement('select');
      skillSelect.className = 'inline-edit';
      skillSelect.style.width = '100%';
      skillSelect.dataset.field = 'skill';
      skillSelect.dataset.original = item.skill || '';
      
      // Add empty option
      const emptyOption = document.createElement('option');
      emptyOption.value = '';
      emptyOption.textContent = 'None';
      skillSelect.appendChild(emptyOption);
      
      // Add skill options
      ['Archery', 'Slashing', 'Bludgeoning', 'Piercing', 'Throwing', 
       'Brass', 'Percussion', 'Stringed', 'Wind', 'Singing'].forEach(skill => {
        const option = document.createElement('option');
        option.value = skill;
        option.textContent = skill;
        if (skill === item.skill) option.selected = true;
        skillSelect.appendChild(option);
      });
      skillSelect.onchange = () => stageItemChange(item.id, 'skill', skillSelect.value || null);
      skillCell.appendChild(skillSelect);
      row.appendChild(skillCell);
      
      // Stats
      ['str', 'sta', 'agi', 'dex', 'wis', 'int', 'cha'].forEach(stat => {
        const statCell = document.createElement('td');
        const statInput = document.createElement('input');
        statInput.type = 'number';
        statInput.value = item[stat] || 0;
        statInput.className = 'inline-edit stat-input';
        statInput.style.textAlign = 'center';
        statInput.min = '-999';
        statInput.max = '999';
        statInput.dataset.field = stat;
        statInput.dataset.original = item[stat] || 0;
        statInput.onblur = () => stageItemChange(item.id, stat, parseInt(statInput.value) || 0);
        statInput.onkeypress = (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            statInput.blur();
          }
        };
        updateStatInputColor(statInput);
        statCell.appendChild(statInput);
        row.appendChild(statCell);
      });
      
      // Attack Speed
      const asCell = document.createElement('td');
      const asInput = document.createElement('input');
      asInput.type = 'number';
      asInput.value = item.attack_speed || 0;
      asInput.className = 'inline-edit';
      asInput.style.textAlign = 'center';
      asInput.min = '0';
      asInput.max = '99.9';
      asInput.step = '0.1';
      asInput.dataset.field = 'attack_speed';
      asInput.dataset.original = item.attack_speed || 0;
      asInput.onblur = () => stageItemChange(item.id, 'attack_speed', parseFloat(asInput.value) || 0);
      asInput.onkeypress = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          asInput.blur();
        }
      };
      asCell.appendChild(asInput);
      row.appendChild(asCell);
      
      // Damage
      const damageCell = document.createElement('td');
      const damageInput = document.createElement('input');
      damageInput.type = 'number';
      damageInput.value = item.damage || 0;
      damageInput.className = 'inline-edit stat-input';
      damageInput.style.textAlign = 'center';
      damageInput.min = '0';
      damageInput.max = '9999';
      damageInput.dataset.field = 'damage';
      damageInput.dataset.original = item.damage || 0;
      damageInput.onblur = () => stageItemChange(item.id, 'damage', parseInt(damageInput.value) || 0);
      damageInput.onkeypress = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          damageInput.blur();
        }
      };
      damageCell.appendChild(damageInput);
      row.appendChild(damageCell);
      
      // Delay
      const delayCell = document.createElement('td');
      const delayInput = document.createElement('input');
      delayInput.type = 'number';
      delayInput.value = item.delay || 0;
      delayInput.className = 'inline-edit stat-input';
      delayInput.style.textAlign = 'center';
      delayInput.min = '0';
      delayInput.max = '9999';
      delayInput.dataset.field = 'delay';
      delayInput.dataset.original = item.delay || 0;
      delayInput.onblur = () => stageItemChange(item.id, 'delay', parseInt(delayInput.value) || 0);
      delayInput.onkeypress = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          delayInput.blur();
        }
      };
      delayCell.appendChild(delayInput);
      row.appendChild(delayCell);
      
      // Health
      const hpCell = document.createElement('td');
      const hpInput = document.createElement('input');
      hpInput.type = 'number';
      hpInput.value = item.health || 0;
      hpInput.className = 'inline-edit stat-input';
      hpInput.style.textAlign = 'center';
      hpInput.min = '-9999';
      hpInput.max = '9999';
      hpInput.dataset.field = 'health';
      hpInput.dataset.original = item.health || 0;
      hpInput.onblur = () => stageItemChange(item.id, 'health', parseInt(hpInput.value) || 0);
      hpInput.onkeypress = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          hpInput.blur();
        }
      };
      updateStatInputColor(hpInput);
      hpCell.appendChild(hpInput);
      row.appendChild(hpCell);
      
      // Mana
      const mpCell = document.createElement('td');
      const mpInput = document.createElement('input');
      mpInput.type = 'number';
      mpInput.value = item.mana || 0;
      mpInput.className = 'inline-edit stat-input';
      mpInput.style.textAlign = 'center';
      mpInput.min = '-9999';
      mpInput.max = '9999';
      mpInput.dataset.field = 'mana';
      mpInput.dataset.original = item.mana || 0;
      mpInput.onblur = () => stageItemChange(item.id, 'mana', parseInt(mpInput.value) || 0);
      mpInput.onkeypress = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          mpInput.blur();
        }
      };
      updateStatInputColor(mpInput);
      mpCell.appendChild(mpInput);
      row.appendChild(mpCell);
      
      // AC
      const acCell = document.createElement('td');
      const acInput = document.createElement('input');
      acInput.type = 'number';
      acInput.value = item.ac || 0;
      acInput.className = 'inline-edit stat-input';
      acInput.style.textAlign = 'center';
      acInput.min = '-50';
      acInput.max = '50';
      acInput.dataset.field = 'ac';
      acInput.dataset.original = item.ac || 0;
      acInput.onblur = () => stageItemChange(item.id, 'ac', parseInt(acInput.value) || 0);
      acInput.onkeypress = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          acInput.blur();
        }
      };
      updateStatInputColor(acInput);
      acCell.appendChild(acInput);
      row.appendChild(acCell);
      
      // Block
      const blockCell = document.createElement('td');
      const blockInput = document.createElement('input');
      blockInput.type = 'number';
      blockInput.value = item.block || 0;
      blockInput.className = 'inline-edit stat-input';
      blockInput.style.textAlign = 'center';
      blockInput.min = '0';
      blockInput.max = '100';
      blockInput.dataset.field = 'block';
      blockInput.dataset.original = item.block || 0;
      blockInput.onblur = () => stageItemChange(item.id, 'block', parseInt(blockInput.value) || 0);
      blockInput.onkeypress = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          blockInput.blur();
        }
      };
      updateStatInputColor(blockInput);
      blockCell.appendChild(blockInput);
      row.appendChild(blockCell);
      
      // Resistances
      const resistances = [
        { field: 'resist_cold', name: 'Cold' },
        { field: 'resist_corruption', name: 'Corruption' },
        { field: 'resist_disease', name: 'Disease' },
        { field: 'resist_electricity', name: 'Electricity' },
        { field: 'resist_fire', name: 'Fire' },
        { field: 'resist_magic', name: 'Magic' },
        { field: 'resist_poison', name: 'Poison' }
      ];
      
      resistances.forEach(resist => {
        const resistCell = document.createElement('td');
        const resistInput = document.createElement('input');
        resistInput.type = 'number';
        resistInput.value = item[resist.field] || 0;
        resistInput.className = 'inline-edit stat-input';
        resistInput.style.textAlign = 'center';
        resistInput.style.width = '100%';
        resistInput.min = '-999';
        resistInput.max = '999';
        resistInput.dataset.field = resist.field;
        resistInput.dataset.original = item[resist.field] || 0;
        resistInput.title = `${resist.name} Resistance`;
        resistInput.onblur = () => stageItemChange(item.id, resist.field, parseInt(resistInput.value) || 0);
        resistInput.onkeypress = (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            resistInput.blur();
          }
        };
        updateStatInputColor(resistInput);
        resistCell.appendChild(resistInput);
        row.appendChild(resistCell);
      });
      
      // Race - Multi-select
      const raceCell = document.createElement('td');
      raceCell.style.position = 'relative';
      
      // Create display div for selected races
      const raceDisplay = document.createElement('div');
      raceDisplay.className = 'race-display';
      raceDisplay.style.cssText = 'cursor: pointer; padding: 4px; background: #2d2d2d; border: 1px solid #555; border-radius: 4px; min-height: 28px; font-size: 0.85rem;';
      
      // Parse current races
      const currentRaces = item.race ? item.race.split(' ').filter(r => r) : [];
      const isAllRaces = !item.race || item.race === 'ALL' || currentRaces.includes('ALL');
      
      // Display selected races
      if (isAllRaces) {
        raceDisplay.textContent = 'All Races';
      } else if (currentRaces.length > 3) {
        raceDisplay.textContent = `${currentRaces.length} races selected`;
        raceDisplay.title = currentRaces.map(code => RACE_ABBREVIATIONS[code] || code).join(', ');
      } else {
        raceDisplay.textContent = currentRaces.map(code => RACE_ABBREVIATIONS[code] || code).join(', ') || 'All Races';
        raceDisplay.title = '';
      }
      
      raceDisplay.onclick = () => {
        openRaceClassModal('race', item, raceDisplay);
      };
      
      raceCell.appendChild(raceDisplay);
      row.appendChild(raceCell);
      
      // Class - Multi-select
      const classCell = document.createElement('td');
      classCell.style.position = 'relative';
      
      // Create display div for selected classes
      const classDisplay = document.createElement('div');
      classDisplay.className = 'class-display';
      classDisplay.style.cssText = 'cursor: pointer; padding: 4px; background: #2d2d2d; border: 1px solid #555; border-radius: 4px; min-height: 28px; font-size: 0.85rem;';
      
      // Parse current classes
      const currentClasses = item.class ? item.class.split(' ').filter(c => c) : [];
      const isAllClasses = !item.class || item.class === 'ALL' || currentClasses.includes('ALL');
      
      // Display selected classes
      if (isAllClasses) {
        classDisplay.textContent = 'All Classes';
      } else if (currentClasses.length > 3) {
        classDisplay.textContent = `${currentClasses.length} classes selected`;
        classDisplay.title = currentClasses.map(code => CLASS_ABBREVIATIONS[code] || code).join(', ');
      } else {
        classDisplay.textContent = currentClasses.map(code => CLASS_ABBREVIATIONS[code] || code).join(', ') || 'All Classes';
        classDisplay.title = '';
      }
      
      classDisplay.onclick = () => {
        openRaceClassModal('class', item, classDisplay);
      };
      
      classCell.appendChild(classDisplay);
      row.appendChild(classCell);
      
      // Description
      const descCell = document.createElement('td');
      const descTextarea = document.createElement('textarea');
      descTextarea.value = item.description || '';
      descTextarea.className = 'inline-edit';
      descTextarea.style.width = '100%';
      descTextarea.style.minHeight = '50px';
      descTextarea.style.resize = 'vertical';
      descTextarea.rows = 2;
      descTextarea.dataset.field = 'description';
      descTextarea.dataset.original = item.description || '';
      descTextarea.onblur = () => stageItemChange(item.id, 'description', descTextarea.value);
      descTextarea.onkeydown = (e) => {
        // Allow Enter for new lines in textarea
        if (e.key === 'Tab') {
          e.preventDefault();
          descTextarea.blur();
        }
      };
      descCell.appendChild(descTextarea);
      row.appendChild(descCell);
      
      // Actions
      const actionsCell = document.createElement('td');
      const actionsDiv = document.createElement('div');
      actionsDiv.style.display = 'flex';
      actionsDiv.style.gap = '0.5rem';
      actionsDiv.style.justifyContent = 'center';
      
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'small-btn danger-btn';
      deleteBtn.innerHTML = '';
      deleteBtn.title = 'Delete';
      deleteBtn.onclick = () => markItemForDeletion(item.id);
      actionsDiv.appendChild(deleteBtn);
      
      actionsCell.appendChild(actionsDiv);
      row.appendChild(actionsCell);
      
      return row;
    }
    
    function displayItemPagination() {
      const totalPages = Math.ceil(filteredGameItems.length / GAME_ITEMS_PER_PAGE);
      if (totalPages <= 1) return;
      const paginationDiv = document.getElementById('item-editor-pagination');
      
      if (totalPages <= 1) {
        paginationDiv.style.display = 'none';
        return;
      }
      
      paginationDiv.style.display = 'block';
      paginationDiv.innerHTML = '';
      
      // Previous button
      const prevBtn = document.createElement('button');
      prevBtn.className = 'pagination-btn';
      prevBtn.textContent = 'Previous';
      prevBtn.disabled = currentGameItemPage === 0;
      prevBtn.onclick = () => {
        currentGameItemPage--;
        displayItems();
      };
      paginationDiv.appendChild(prevBtn);
      
      // Page info
      const pageInfo = document.createElement('span');
      pageInfo.className = 'pagination-info';
      pageInfo.textContent = `Page ${currentGameItemPage + 1} of ${totalPages}`;
      paginationDiv.appendChild(pageInfo);
      
      // Next button
      const nextBtn = document.createElement('button');
      nextBtn.className = 'pagination-btn';
      nextBtn.textContent = 'Next';
      nextBtn.disabled = currentGameItemPage === totalPages - 1;
      nextBtn.onclick = () => {
        currentGameItemPage++;
        displayItems();
      };
      paginationDiv.appendChild(nextBtn);
    }
    
    function showAddItemModal() {
      editingGameItem = null;
      document.getElementById('item-modal-title').textContent = 'Add Item';
      document.getElementById('item-form').reset();
      document.getElementById('item-emoji-input-group').style.display = 'block';
      document.getElementById('item-modal').style.display = 'flex';
      
      // Initialize emoji picker
      populateItemEmojiPicker('harvest');
      
      // Initialize modal events and preview
      initializeItemModalEvents();
      updateSlotOptions();
    }
    
    /* Old editItem function - no longer needed with inline editing
    function editItem(id) {
      const item = gameItems.find(i => i.id === id);
      if (!item) return;
      
      editingGameItem = item;
      document.getElementById('item-modal-title').textContent = 'Edit Item';
      
      // Populate form
      document.getElementById('item-name').value = item.name || '';
      document.getElementById('item-type').value = item.item_type || '';
      document.getElementById('item-slot').value = item.slot || '';
      document.getElementById('item-description').value = item.description || '';
      
      // Set icon
      document.querySelector(`input[name="item-icon-type"][value="${item.icon_type}"]`).checked = true;
      updateItemIconTypeDisplay();
      
      if (item.icon_type === 'emoji') {
        document.getElementById('item-emoji').value = item.icon_value;
      }
      
      // Set stats
      document.getElementById('item-str').value = item.str || 0;
      document.getElementById('item-sta').value = item.sta || 0;
      document.getElementById('item-agi').value = item.agi || 0;
      document.getElementById('item-dex').value = item.dex || 0;
      document.getElementById('item-wis').value = item.wis || 0;
      document.getElementById('item-int').value = item.int || 0;
      document.getElementById('item-cha').value = item.cha || 0;
      
      // Set combat stats
      document.getElementById('item-attack-speed').value = item.attack_speed || 0;
      document.getElementById('item-health').value = item.health || 0;
      document.getElementById('item-mana').value = item.mana || 0;
      
      // Set additional properties
      document.getElementById('item-ac').value = item.ac || 0;
      
      document.getElementById('item-modal').style.display = 'flex';
      
      // Initialize modal events and preview
      initializeItemModalEvents();
      updateSlotOptions();
    }
    */
    
    /* Old modal functions - commented out as we now use inline editing
    async function saveItem(event) {
      event.preventDefault();
      
      const formData = {
        name: document.getElementById('item-name').value.trim(),
        item_type: document.getElementById('item-type').value,
        slot: document.getElementById('item-slot').value,
        description: document.getElementById('item-description').value.trim(),
        icon_type: document.querySelector('input[name="item-icon-type"]:checked').value,
        icon_value: document.getElementById('item-emoji').value, // TODO: Handle other icon types
        str: parseInt(document.getElementById('item-str').value) || 0,
        sta: parseInt(document.getElementById('item-sta').value) || 0,
        agi: parseInt(document.getElementById('item-agi').value) || 0,
        dex: parseInt(document.getElementById('item-dex').value) || 0,
        wis: parseInt(document.getElementById('item-wis').value) || 0,
        int: parseInt(document.getElementById('item-int').value) || 0,
        cha: parseInt(document.getElementById('item-cha').value) || 0,
        attack_speed: parseFloat(document.getElementById('item-attack-speed').value) || 0,
        health: parseInt(document.getElementById('item-health').value) || 0,
        mana: parseInt(document.getElementById('item-mana').value) || 0,
        ac: parseInt(document.getElementById('item-ac').value) || 0
      };
      
      try {
        const url = editingGameItem ? `/api/items/${editingGameItem.id}` : '/api/items';
        const method = editingGameItem ? 'PUT' : 'POST';
        
        const response = await window.csrfHelper.fetchWithCSRF(url, {
          method: method,
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(formData)
        });
        
        if (!response.ok) {
          const data = await response.json();
          throw new Error(data.error || 'Failed to save item');
        }
        
        showMessage(editingGameItem ? 'Item updated' : 'Item added', 'success');
        closeItemModal();
        await loadItemEditor();
      } catch (error) {
        showMessage(error.message, 'error');
      }
    }
    
    // Commented out old modal-based delete function - now using staged deletion
    /*
    async function deleteItem(id) {
      const item = gameItems.find(i => i.id === id);
      if (!item) return;
      
      if (!confirm(`Delete item "${item.name}"? This cannot be undone.`)) return;
      
      try {
        const response = await window.csrfHelper.fetchWithCSRF(`/api/items/${id}`, {
          method: 'DELETE'
        });
        
        if (!response.ok) {
          const data = await response.json();
          throw new Error(data.error || 'Failed to delete item');
        }
        
        showMessage('Item deleted', 'success');
        await loadItemEditor();
      } catch (error) {
        showMessage(error.message, 'error');
      }
    }
    
    function closeItemModal() {
      document.getElementById('item-modal').style.display = 'none';
      document.getElementById('item-form').reset();
      editingGameItem = null;
    }
    */ // End of old modal functions
    
    /* These emoji picker functions will be updated for inline editing
    function updateItemIconTypeDisplay() {
      const iconType = document.querySelector('input[name="item-icon-type"]:checked').value;
      document.getElementById('item-emoji-input-group').style.display = iconType === 'emoji' ? 'block' : 'none';
      // TODO: Add other icon type displays
    }
    
    function toggleItemEmojiPicker() {
      const picker = document.getElementById('item-emoji-picker');
      picker.style.display = picker.style.display === 'none' ? 'block' : 'none';
      
      if (picker.style.display === 'block') {
        populateItemEmojiPicker(currentItemEmojiCategory);
      }
    }
    
    function selectItemEmojiCategory(category) {
      currentItemEmojiCategory = category;
      
      // Update active button
      document.querySelectorAll('#item-emoji-picker .emoji-category-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      event.target.classList.add('active');
      
      populateItemEmojiPicker(category);
    }
    
    function populateItemEmojiPicker(category) {
      const grid = document.getElementById('item-emoji-grid');
      grid.innerHTML = '';
      grid.className = 'emoji-grid';
      grid.style.display = 'grid';
      grid.style.gridTemplateColumns = 'repeat(auto-fill, minmax(50px, 1fr))';
      grid.style.gap = '0.5rem';
      grid.style.padding = '1rem';
      grid.style.maxHeight = '300px';
      grid.style.overflowY = 'auto';
      grid.style.background = '#1a1a1a';
      
      const emojis = emojiCategories[category] || [];
      emojis.forEach(emoji => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.style.fontSize = '1.75rem';
        btn.style.padding = '0.5rem';
        btn.style.border = '1px solid transparent';
        btn.style.background = '#2d2d2d';
        btn.style.cursor = 'pointer';
        btn.style.borderRadius = '6px';
        btn.style.minWidth = '45px';
        btn.style.minHeight = '45px';
        btn.style.display = 'flex';
        btn.style.alignItems = 'center';
        btn.style.justifyContent = 'center';
        btn.style.transition = 'all 0.2s ease';
        btn.textContent = emoji;
        
        btn.onmouseover = () => {
          btn.style.background = '#3d3d3d';
          btn.style.border = '1px solid #FFD700';
          btn.style.transform = 'scale(1.1)';
        };
        
        btn.onmouseout = () => {
          btn.style.background = '#2d2d2d';
          btn.style.border = '1px solid transparent';
          btn.style.transform = 'scale(1)';
        };
        
        btn.onclick = () => {
          document.getElementById('item-emoji').value = emoji;
          document.getElementById('item-emoji-picker').style.display = 'none';
          updateItemPreview();
        };
        
        grid.appendChild(btn);
      });
    }
    */ // End of emoji picker functions to be updated
    
    async function exportItemsToCSV() {
      const headers = ['ID', 'Name', 'Type', 'Slot', 'STR', 'STA', 'AGI', 'DEX', 'WIS', 'INT', 'CHA', 'Attack Speed', 'Health', 'Mana', 'AC', 'Block', 'Description'];
      const rows = [headers];
      
      filteredGameItems.forEach(item => {
        rows.push([
          item.id,
          item.name,
          item.item_type || '',
          item.slot || '',
          item.str || 0,
          item.sta || 0,
          item.agi || 0,
          item.dex || 0,
          item.wis || 0,
          item.int || 0,
          item.cha || 0,
          item.attack_speed || 0,
          item.health || 0,
          item.mana || 0,
          item.ac || 0,
          item.block || 0,
          item.description || ''
        ]);
      });
      
      const csv = rows.map(row => row.map(cell => {
        const str = String(cell).replace(/"/g, '""');
        return str.includes(',') || str.includes('"') || str.includes('\n') ? `"${str}"` : str;
      }).join(',')).join('\n');
      
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `items_export_${new Date().toISOString().split('T')[0]}.csv`;
      a.click();
      URL.revokeObjectURL(url);
    }
    
    // Batch Import Functions
    let batchImportItems = [];
    let batchImportSelectedItems = new Set();
    
    // Race and Class abbreviations
    const RACE_ABBREVIATIONS = {
      'DDF': 'Deep Dwarf',
      'DEF': 'Deep Elf', 
      'DGN': 'Deep Gnome',
      'DWF': 'Dwarf',
      'GNM': 'Gnome',
      'GOB': 'Goblin',
      'HFL': 'Halfling',
      'HIE': 'High Elf',
      'HUM': 'Human',
      'OGR': 'Ogre',
      'TRL': 'Troll',
      'ELF': 'Wood Elf',
      'ALL': 'All Races'
    };
    
    const CLASS_ABBREVIATIONS = {
      'ARC': 'Archer',
      'BRD': 'Bard',
      'BST': 'Beastmaster',
      'CLR': 'Cleric',
      'DRU': 'Druid',
      'ELE': 'Elementalist',
      'ENC': 'Enchanter',
      'FTR': 'Fighter',
      'INQ': 'Inquisitor',
      'MAG': 'Magician',
      'MNK': 'Monk',
      'NEC': 'Necromancer',
      'PAL': 'Paladin',
      'RNG': 'Ranger',
      'ROG': 'Rogue',
      'SHA': 'Shaman',
      'SHD': 'Shadow Knight',
      'SHM': 'Shaman',
      'SPB': 'Spellblade',
      'WAR': 'Warrior',
      'WIZ': 'Wizard',
      'ALL': 'All Classes'
    };
    
    // Function to validate and normalize race/class strings
    function normalizeRaceClassString(str, type) {
      if (!str || str.trim() === '' || str === '-') return 'ALL';
      
      const abbreviations = type === 'race' ? RACE_ABBREVIATIONS : CLASS_ABBREVIATIONS;
      const parts = str.toUpperCase().split(/[,\s]+/).filter(p => p);
      const normalized = [];
      
      for (const part of parts) {
        if (part === 'ALL' || abbreviations[part]) {
          normalized.push(part);
        }
      }
      
      return normalized.length > 0 ? normalized.join(' ') : 'ALL';
    }
    
    function showBatchImportModal() {
      // Reset all state before showing modal
      // Don't clear items if we're coming from extraction
      if (!window.extractionCompleted && !window.isExtractingItems) {
        batchImportItems = [];
        batchImportSelectedItems.clear();
        inspectorTreeData = {};
        inspectorNodeId = 0;
        window.isExtractingItems = false;
        window.extractionCompleted = false;
      }
      window.updatingExclusions = false;
      
      // Reset UI elements
      const textarea = document.getElementById('batch-import-textarea');
      textarea.value = '';
      textarea.disabled = false;
      
      // Reset step visibility - ensure step1 is visible
      const step1 = document.getElementById('batch-import-step1');
      const step2 = document.getElementById('batch-import-items-step2');
      if (step1) {
        step1.style.display = 'block';
        step1.style.padding = '30px'; // Ensure proper padding
        // Ensure the grid layout is properly set
        const gridContainer = step1.querySelector('div[style*="grid-template-columns"]');
        if (gridContainer) {
          gridContainer.style.display = 'grid';
          gridContainer.style.gridTemplateColumns = '1fr 1fr';
        }
      }
      if (step2) step2.style.display = 'none';
      
      // Clear inspector tree
      const treeContainer = document.getElementById('inspector-tree');
      if (treeContainer) treeContainer.innerHTML = '';
      
      // Reset inspector - hide the entire inspector results div
      const resultsDiv = document.getElementById('inspector-results');
      if (resultsDiv) resultsDiv.style.display = 'none';
      
      // Also hide the data inspector status
      const statusDiv = document.getElementById('inspector-status');
      if (statusDiv) statusDiv.style.display = 'block';
      
      // Clear table
      const tbody = document.getElementById('batch-import-tbody');
      if (tbody) tbody.innerHTML = '';
      
      // Reset buttons
      const pasteBtn = document.getElementById('batch-paste-mode-btn');
      if (pasteBtn) {
        pasteBtn.style.display = 'inline-flex';
        pasteBtn.querySelector('span:last-child').textContent = 'Click here or press Ctrl+V to paste';
      }
      
      const analyzeBtn = document.getElementById('batch-analyze-btn');
      if (analyzeBtn) analyzeBtn.style.display = 'none';
      
      const clearBtn = document.getElementById('batch-clear-btn');
      if (clearBtn) clearBtn.style.display = 'none';
      
      const insertBtn = document.getElementById('batch-insert-btn');
      if (insertBtn) {
        insertBtn.disabled = true;
        insertBtn.textContent = 'Insert New Items';
      }
      
      // Show modal
      const modal = document.getElementById('batch-import-modal');
      modal.style.display = 'flex';
      
      // Save current scroll position and prevent body scroll
      document.body.dataset.scrollY = window.scrollY;
      document.body.style.position = 'fixed';
      document.body.style.top = `-${window.scrollY}px`;
      document.body.style.width = '100%';
      document.body.style.overflow = 'hidden';
      
      // Ensure the textarea is visible and focused
      setTimeout(() => {
        // Double-check textarea visibility after modal is shown
        if (textarea) {
          textarea.style.display = 'block';
          textarea.focus();
        }
        // Also ensure the left column is visible
        const leftColumn = step1?.querySelector('div[style*="flex-direction: column"]');
        if (leftColumn) {
          leftColumn.style.display = 'flex';
        }
      }, 100);
      
      updateBatchImportCount();
      
      // Initialize keyboard navigation (handles both focus trap and table nav)
      initBatchTableKeyboardNav();
    }
    
    function closeBatchImportModal() {
      if (batchImportItems.length > 0 && !confirm('Close without saving? All progress will be lost.')) {
        return;
      }
      
      const modal = document.getElementById('batch-import-modal');
      modal.style.display = 'none';
      
      // Restore body scroll
      const scrollY = document.body.dataset.scrollY || '0';
      document.body.style.position = '';
      document.body.style.top = '';
      document.body.style.width = '';
      document.body.style.overflow = '';
      window.scrollTo(0, parseInt(scrollY));
      delete document.body.dataset.scrollY;
      
      // Remove event listeners
      document.removeEventListener('keydown', handleBatchTableKeyNav);
      modal.removeEventListener('keydown', handleBatchTableKeyNav);
      
      // Clear extraction flags when closing modal
      window.isExtractingItems = false;
      window.extractionCompleted = false;
      
      clearBatchImport();
    }
    
    function clearBatchImport() {
      document.getElementById('batch-import-textarea').value = '';
      // Don't clear items if we're in the middle of extraction or have completed extraction
      if (!window.isExtractingItems && !window.extractionCompleted) {
        batchImportItems = [];
        batchImportSelectedItems.clear();
      }
      document.getElementById('batch-import-step1').style.display = 'block';
      
      // Clear extraction flags only if we're not actively extracting
      if (!window.isExtractingItems) {
        window.isExtractingItems = false;
        window.extractionCompleted = false;
      }
      document.getElementById('batch-import-step1').style.padding = '30px'; // Reset padding
      document.getElementById('batch-import-items-step2').style.display = 'none';
      updateBatchImportCount();
      
      // Hide single item controls
      const singleControlsDiv = document.getElementById('single-item-controls');
      if (singleControlsDiv) {
        singleControlsDiv.style.display = 'none';
      }
      
      // Hide batch mode controls
      const batchControlsDiv = document.getElementById('batch-mode-controls');
      if (batchControlsDiv) {
        batchControlsDiv.style.display = 'none';
      }
      
      // Reset step 2 title
      const step2Title = document.querySelector('#batch-import-step2 h3');
      if (step2Title) {
        step2Title.innerHTML = 'Step 2: Review and Edit Items';
      }
      
      // Clear stored navigation position
      window.batchCurrentRow = -1;
      window.batchCurrentCol = -1;
    }
    
    async function checkUrlTypes(urls) {
      const formatIndicator = document.getElementById('batch-import-format');
      if (!formatIndicator) return;
      
      let listUrls = 0;
      let itemUrls = 0;
      let npcUrls = 0;
      let unknownUrls = 0;
      
      formatIndicator.innerHTML = `<span style="margin-right: 0.5rem;"></span>Analyzing URLs... (may take a moment due to rate limits)`;
      
      for (const url of urls) {
        if (url.includes('/wiki/')) {
          try {
            const proxyUrl = 'https://api.allorigins.win/get?url=' + encodeURIComponent(url);
            const response = await fetch(proxyUrl);
            
            if (response.ok) {
              const data = await response.json();
              
              // Parse the page to determine its type
              const parser = new DOMParser();
              const doc = parser.parseFromString(data.contents, 'text/html');
              const pageText = doc.body ? doc.body.textContent.toLowerCase() : '';
              const h1 = doc.querySelector('h1');
              const pageTitle = h1 ? h1.textContent.trim() : '';
              
              // Check for NPC indicators FIRST
              const hasNPCStats = (pageText.includes('level:') || pageText.includes('race:') || pageText.includes('type:')) && 
                                 (pageText.includes('health:') || pageText.includes('damage:') || pageText.includes('spawn'));
              const hasLootSections = pageText.includes('unique loot') || pageText.includes('common loot') || 
                                     pageText.includes('loot') || pageText.includes('drops');
              const looksLikeNPCName = /^[A-Z][a-z]+ [A-Z]/.test(pageTitle) || // First Last name pattern
                                      /^(Lord|Lady|Sir|Captain|Lieutenant|Sergeant|General|Colonel|Major|Corporal|Private|Master|Keeper|Guard|Merchant|Trader|Vendor|Shopkeeper|Innkeeper|Barkeep|Smith|Blacksmith|Weaponsmith|Armorsmith|Tailor|Alchemist|Enchanter|Wizard|Cleric|Priest|Priestess|Bishop|Cardinal|Monk|Brother|Sister|Elder|Chief|Shaman|Oracle|Seer|Scout|Ranger|Hunter|Assassin|Thief|Rogue|Warrior|Knight|Paladin|Champion|Hero|Veteran|Recruit|Apprentice|Journeyman|Expert|Grandmaster|King|Queen|Prince|Princess|Duke|Duchess|Baron|Baroness|Count|Countess|Mayor|Councilor|Ambassador|Emissary|Messenger|Courier|Guide|Trainer|Teacher|Scholar|Sage|Librarian|Scribe|Historian|Archaeologist|Explorer|Adventurer|Wanderer|Traveler|Pilgrim|Hermit|Mystic|Druid|Necromancer|Warlock|Sorcerer|Mage|Elementalist|Summoner|Conjurer|Illusionist|Diviner|Abjurer|Transmuter|Evoker)\s+/i.test(pageTitle) ||
                                      pageTitle.toLowerCase().includes('master') ||
                                      pageTitle.toLowerCase().includes('keeper') ||
                                      pageTitle.toLowerCase().includes('guard') ||
                                      pageTitle.toLowerCase().includes('merchant');
              const hasNPCSections = pageText.includes('spawn location') || pageText.includes('respawn time') ||
                                    pageText.includes('faction:') || pageText.includes('aggro radius');
              
              // More lenient NPC detection - doesn't require loot if has strong NPC indicators
              const isNPCPage = (hasNPCStats && (hasLootSections || hasNPCSections)) || 
                               (looksLikeNPCName && (hasNPCStats || hasNPCSections || hasLootSections));
              
              if (isNPCPage) {
                npcUrls++;
              } else {
                // Not an NPC page, check if it's a list page
                const itemLinks = parseItemListPage(data.contents, url);
                
                if (itemLinks.length > 0) {
                  listUrls++;
                } else {
                  // Check if it's a single item page by looking for item data patterns
                  const hasItemData = data.contents.match(/Weapon\s+DMG:|Weight:|Size:|Class:|Race:|Slot:/i);
                  if (hasItemData) {
                    itemUrls++;
                  } else {
                    unknownUrls++;
                  }
                }
              }
            } else {
              unknownUrls++;
            }
          } catch (error) {
            console.error('Error checking URL type:', error);
            unknownUrls++;
          }
        } else {
          unknownUrls++;
        }
      }
      
      // Update format indicator with results
      let resultText = '';
      let resultIcon = '';
      let buttonText = 'Fetch Items';
      
      if (npcUrls > 0) {
        resultIcon = '';
        if (npcUrls === urls.length) {
          resultText = `${npcUrls} NPC${npcUrls > 1 ? 's' : ''} (will extract loot)`;
          buttonText = 'Extract Loot & Fetch Items';
        } else {
          // Mixed types
          const parts = [];
          if (npcUrls > 0) parts.push(`${npcUrls} NPC${npcUrls > 1 ? 's' : ''}`);
          if (listUrls > 0) parts.push(`${listUrls} List${listUrls > 1 ? 's' : ''}`);
          if (itemUrls > 0) parts.push(`${itemUrls} Item${itemUrls > 1 ? 's' : ''}`);
          resultText = parts.join(', ');
          buttonText = 'Process All URLs';
        }
      } else if (listUrls > 0 && itemUrls === 0) {
        resultIcon = '';
        resultText = `${listUrls} Item List${listUrls > 1 ? 's' : ''}`;
        buttonText = 'Expand Lists & Fetch Items';
      } else if (itemUrls > 0 && listUrls === 0) {
        resultIcon = '';
        resultText = `${itemUrls} Item${itemUrls > 1 ? 's' : ''}`;
        buttonText = 'Fetch Items';
      } else if (listUrls > 0 && itemUrls > 0) {
        resultIcon = '';
        resultText = `${listUrls} List${listUrls > 1 ? 's' : ''}, ${itemUrls} Item${itemUrls > 1 ? 's' : ''}`;
        buttonText = 'Expand Lists & Fetch Items';
      } else {
        resultIcon = '';
        resultText = `${urls.length} URL${urls.length > 1 ? 's' : ''}`;
        buttonText = 'Fetch Items';
      }
      
      formatIndicator.innerHTML = `<span style="margin-right: 0.5rem;">${resultIcon}</span>${resultText}`;
      
      // Update button text
      const processBtn = document.getElementById('batch-import-process-btn');
      processBtn.innerHTML = buttonText;
    }
    
    function updateBatchImportCount() {
      const textarea = document.getElementById('batch-import-textarea');
      const lines = textarea.value.split('\n').filter(line => line.trim());
      const currentTextCount = lines.length;
      
      // Count only selected items if any are selected, otherwise count all non-excluded items
      const selectedItemCount = batchImportSelectedItems.size > 0 
        ? batchImportItems.filter(item => !item.excluded && batchImportSelectedItems.has(item.tempId)).length
        : batchImportItems.filter(item => !item.excluded).length;
      
      const totalCount = selectedItemCount + currentTextCount;
      
      // Don't update inspector if we're in the middle of extraction
      const isExtracting = textarea.disabled === true;
      
      // Detect data format and validate
      let dataFormat = 'none';
      let formatIcon = '';
      let formatText = '';
      let isValid = true;
      let errorMessage = '';
      
      if (lines.length === 0) {
        dataFormat = 'none';
        // Only clear inspector if not extracting
        if (!window.isExtractingItems) {
          updateDataInspector(dataFormat, lines);
        }
      } else if (lines.every(line => /^https?:\/\/.+/i.test(line.trim()))) {
        // All lines are URLs
        dataFormat = 'urls';
        formatIcon = '';
        formatText = `${lines.length} URL${lines.length > 1 ? 's' : ''} detected`;
        
        // Clear any existing timeout
        if (window.urlCheckTimeout) {
          clearTimeout(window.urlCheckTimeout);
        }
        
        // Just show the URL count, don't start analysis yet
        // Don't update inspector if we're extracting items or updating exclusions
        if (!window.isExtractingItems && !(batchImportItems && batchImportItems.length > 0) && !window.updatingExclusions) {
          updateDataInspector(dataFormat, lines, false); // false = don't analyze yet
        }
        
        // Hide the paste box and show analyze/clear options
        showUrlAnalysisMode(lines);
      } else if (lines.some(line => /^(Slot|Class|Race|Weapon\s+DMG|Weight|Size|STR|STA|AGI|DEX|WIS|INT|CHA|AC|HP|MANA):/i.test(line))) {
        dataFormat = 'single-item-data';
        formatIcon = '';
        formatText = 'Single Item with Properties';
        updateDataInspector(dataFormat, lines);
      } else if (lines.some(line => line.includes('\t') || line.includes('  '))) {
        dataFormat = 'table';
        formatIcon = '';
        formatText = 'Table Format';
        updateDataInspector(dataFormat, lines);
        
        // Validate table format
        const firstLine = lines[0];
        const columnCount = firstLine.split(/\t|  +/).length;
        
        // Check if all lines have consistent column count
        for (let i = 1; i < lines.length; i++) {
          const cols = lines[i].split(/\t|  +/).length;
          if (cols !== columnCount && cols !== 1) { // Allow single column for empty rows
            isValid = false;
            errorMessage = `Inconsistent columns: Line ${i + 1} has ${cols} columns, expected ${columnCount}`;
            break;
          }
        }
      } else if (lines.length === 1) {
        dataFormat = 'single-item';
        formatIcon = '';
        formatText = 'Single Item';
        updateDataInspector(dataFormat, lines);
        
        // Validate single item
        if (lines[0].length > 100) {
          isValid = false;
          errorMessage = 'Item name is too long (max 100 characters)';
        } else if (!/^[a-zA-Z0-9\s\-',.()&+/]+$/.test(lines[0])) {
          isValid = false;
          errorMessage = 'Item name contains invalid characters';
        }
      } else {
        dataFormat = 'list';
        formatIcon = '';
        formatText = 'Item List';
        updateDataInspector(dataFormat, lines);
        
        // Check for potentially invalid data
        const suspiciousLines = lines.filter(line => {
          // Check for lines that look like code or JSON
          return /^[{}\[\]]|function|const|var|let|=>|console\.|import|export|class\s+\w+|def\s+|print\(/.test(line) ||
                 // Check for lines with too many special characters
                 (line.match(/[^a-zA-Z0-9\s\-',.()&+/]/g) || []).length > line.length * 0.3;
        });
        
        if (suspiciousLines.length > 0) {
          isValid = false;
          errorMessage = 'Data appears to contain code or invalid format. Please paste item names only.';
        }
        
        // Check for excessively long lines
        const longLines = lines.filter(line => line.length > 100);
        if (longLines.length > 0) {
          isValid = false;
          errorMessage = `Found ${longLines.length} item(s) with names longer than 100 characters`;
        }
      }
      
      // Update count display
      const countElement = document.getElementById('batch-import-count');
      if (batchImportItems.length > 0) {
        countElement.textContent = `${currentTextCount} (${totalCount} total)`;
      } else {
        countElement.textContent = currentTextCount;
      }
      
      // Update or create format indicator
      let formatIndicator = document.getElementById('batch-import-format');
      if (!formatIndicator) {
        formatIndicator = document.createElement('div');
        formatIndicator.id = 'batch-import-format';
        formatIndicator.style.cssText = 'display: inline-block; background: rgba(255, 215, 0, 0.1); border: 1px solid rgba(255, 215, 0, 0.3); border-radius: 4px; padding: 0.25rem 0.75rem; color: #FFD700; font-size: 0.9rem; margin-left: 1rem;';
        countElement.parentNode.appendChild(formatIndicator);
      }
      
      // Update or create error message element
      let errorElement = document.getElementById('batch-import-error');
      if (!errorElement) {
        errorElement = document.createElement('div');
        errorElement.id = 'batch-import-error';
        errorElement.style.cssText = 'color: #f44336; font-size: 0.9rem; margin-top: 0.5rem; padding: 0.5rem; background: rgba(244, 67, 54, 0.1); border: 1px solid rgba(244, 67, 54, 0.3); border-radius: 4px; display: none;';
        const textareaContainer = textarea.parentNode;
        textareaContainer.insertBefore(errorElement, textarea.nextSibling);
      }
      
      const processBtn = document.getElementById('batch-import-process-btn');
      
      if (!isValid) {
        // Show error state
        formatIndicator.style.background = 'rgba(244, 67, 54, 0.1)';
        formatIndicator.style.borderColor = 'rgba(244, 67, 54, 0.3)';
        formatIndicator.style.color = '#f44336';
        formatIndicator.innerHTML = `<span style="margin-right: 0.5rem;"></span>Invalid Data Format`;
        formatIndicator.style.display = 'inline';
        
        errorElement.textContent = errorMessage;
        errorElement.style.display = 'block';
        
        processBtn.style.background = '#d32f2f';
        processBtn.style.borderColor = '#d32f2f';
        processBtn.disabled = true;
        processBtn.innerHTML = 'Invalid Data';
      } else if (dataFormat !== 'none') {
        // Show valid format
        formatIndicator.style.background = 'rgba(255, 215, 0, 0.1)';
        formatIndicator.style.borderColor = 'rgba(255, 215, 0, 0.3)';
        formatIndicator.style.color = '#FFD700';
        formatIndicator.innerHTML = `<span style="margin-right: 0.5rem;">${formatIcon}</span>${formatText}`;
        formatIndicator.style.display = 'inline';
        
        errorElement.style.display = 'none';
        
        // Reset button style
        processBtn.style.background = '';
        processBtn.style.borderColor = '';
        processBtn.disabled = false;
        
        // Update button text based on format
        if (dataFormat === 'single-item' || dataFormat === 'single-item-data') {
          processBtn.innerHTML = 'Add to Batch';
          processBtn.title = 'Add this item to the batch (can add more before proceeding)';
        } else if (dataFormat === 'urls') {
          processBtn.innerHTML = 'Fetch & Add Items';
          processBtn.title = 'Fetch item data from URLs and add to batch';
        } else {
          processBtn.innerHTML = 'Process Items ';
          processBtn.title = 'Process all items and continue to step 2';
        }
      } else {
        formatIndicator.style.display = 'none';
        errorElement.style.display = 'none';
        processBtn.style.background = '';
        processBtn.style.borderColor = '';
        processBtn.disabled = true;
      }
    }
    
    // Global state for inspector
    let inspectorTreeData = {};
    
    // Debug wrapper to track tree data changes
    const originalTreeData = inspectorTreeData;
    Object.defineProperty(window, 'inspectorTreeDataDebug', {
      get() {
        return inspectorTreeData;
      },
      set(value) {
        const oldCount = Object.keys(inspectorTreeData).length;
        const newCount = Object.keys(value).length;
        if (oldCount > 0 && newCount === 0) {
          console.warn('Inspector tree data being cleared!', {
            oldCount,
            newCount,
            stack: new Error().stack
          });
        }
        inspectorTreeData = value;
      }
    });
    let inspectorNodeId = 0;
    let inspectorAnalysisQueue = [];
    let inspectorIsAnalyzing = false;
    let urlMappingsCache = {};
    let urlPatterns = { prefixes: {}, suffixes: {} };
    let contextMenuNode = null;
    
    function countAllItemsRecursively(node) {
      let count = 0;
      
      if (node.type === 'item') {
        count = 1;
      }
      
      if (node.children && node.children.length > 0) {
        node.children.forEach(childId => {
          const childNode = inspectorTreeData[childId];
          if (childNode) {
            count += countAllItemsRecursively(childNode);
          }
        });
      }
      
      return count;
    }
    
    function updateParentNodeStatus(childNode) {
      if (!childNode.parent) return;
      
      const parentNode = inspectorTreeData[childNode.parent];
      if (!parentNode) return;
      
      // Check if all children are extracted
      const allChildrenExtracted = parentNode.children.every(childId => {
        const child = inspectorTreeData[childId];
        return child && (child.status === 'extracted' || child.status === 'error');
      });
      
      if (allChildrenExtracted) {
        // Count successful extractions
        const successCount = parentNode.children.filter(childId => {
          const child = inspectorTreeData[childId];
          return child && child.status === 'extracted';
        }).length;
        
        if (successCount === parentNode.children.length) {
          // All children successfully extracted
          parentNode.icon = '';
          parentNode.status = 'extracted';
        } else if (successCount > 0) {
          // Some children extracted
          parentNode.icon = '';
          parentNode.status = 'partial';
        } else {
          // No children extracted
          parentNode.icon = '';
          parentNode.status = 'error';
        }
        
        updateTreeNode(parentNode.id);
        
        // Recursively update grandparent if applicable
        updateParentNodeStatus(parentNode);
      }
    }
    
    function showUrlAnalysisMode(urls) {
      // Don't hide the paste box, just hide it visually by making it smaller
      const textarea = document.getElementById('batch-import-textarea');
      if (textarea) {
        textarea.style.display = 'none';
      }
      
      // Update the title and description
      const step1Title = document.querySelector('#batch-import-step1 h3');
      const step1Desc = document.querySelector('#batch-import-step1 p');
      if (step1Title) step1Title.textContent = 'Step 1: Analyze URLs';
      if (step1Desc) step1Desc.textContent = `${urls.length} URL${urls.length > 1 ? 's' : ''} detected. Click "Analyze URLs" to begin.`;
      
      // Show URL analysis actions
      document.getElementById('batch-import-actions').style.display = 'none';
      document.getElementById('url-analysis-actions').style.display = 'flex';
      
      // Store URLs for later use
      window.currentAnalysisUrls = urls;
    }
    
    function clearUrlAnalysis() {
      // Show the textarea again
      const textarea = document.getElementById('batch-import-textarea');
      if (textarea) {
        textarea.style.display = 'block';
      }
      
      // Reset the title and description
      const step1Title = document.querySelector('#batch-import-step1 h3');
      const step1Desc = document.querySelector('#batch-import-step1 p');
      if (step1Title) step1Title.textContent = 'Step 1: Paste Item Data';
      if (step1Desc) step1Desc.textContent = 'Paste your item data below. Supports multiple formats.';
      
      // Show normal actions
      document.getElementById('batch-import-actions').style.display = 'flex';
      document.getElementById('url-analysis-actions').style.display = 'none';
      
      // Clear the textarea and reset state
      clearBatchImport();
    }
    
    async function analyzeUrls() {
      // Start the data inspector analysis
      const urls = window.currentAnalysisUrls || [];
      if (urls.length === 0) return;
      
      // Update the data inspector to show we're starting analysis
      // This will initialize the tree and start the analysis
      updateDataInspector('urls', urls, true); // true = start analysis
    }
    
    async function addItemsToNPC() {
      // Find the NPC node in the tree
      const npcNode = Object.values(inspectorTreeData).find(node => node.type === 'npc');
      
      if (!npcNode) {
        showMessage('No NPC found in the inspector tree', 'warning');
        return;
      }
      
      const npcUrl = npcNode.url;
      
      // Get all non-excluded item nodes
      const itemNodes = Object.values(inspectorTreeData).filter(node => 
        node.type === 'item' && !node.excluded
      );
      
      if (itemNodes.length === 0) {
        showMessage('No items to add (all items are excluded or none found)', 'warning');
        return;
      }
      
      try {
        // Load NPCs if not already loaded
        if (!npcs || npcs.length === 0) {
          showMessage('Loading NPCs...', 'info');
          const response = await window.csrfHelper.fetchWithCSRF('/api/npcs');
          if (!response.ok) throw new Error('Failed to load NPCs');
          npcs = await response.json();
        }
        
        // Find NPC with matching URL in description
        let matchingNPC = npcs.find(npc => {
          const description = npc.description || '';
          return description.includes(npcUrl);
        });
        
        if (!matchingNPC) {
          // Create the NPC if it doesn't exist
          const npcName = npcNode.title || 'Unknown NPC';
          
          if (!confirm(`NPC "${npcName}" does not exist. Create it with ${itemNodes.length} items?`)) {
            return;
          }
          
          // Create new NPC with minimal data
          const createResponse = await window.csrfHelper.fetchWithCSRF('/api/npcs', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              name: npcName,
              description: npcUrl,
              npc_type: 'humanoid',
              hp: 0,
              mp: 0,
              ac: 0,
              str: 0,
              sta: 0,
              agi: 0,
              dex: 0,
              wis: 0,
              int: 0,
              cha: 0,
              attack_speed: 0,
              min_dmg: 0,
              max_dmg: 0,
              level: 1,
              loot: []
            })
          });
          
          if (!createResponse.ok) {
            const errorData = await createResponse.json();
            console.error('Failed to create NPC:', errorData);
            throw new Error(errorData.error || 'Failed to create NPC');
          }
          
          matchingNPC = await createResponse.json();
          showMessage(`Created NPC "${npcName}"`, 'success');
          
          // Add to local npcs array
          npcs.push(matchingNPC);
        }
        
        // Extract item names from the tree
        const itemNames = itemNodes.map(node => node.title);
        
        // Check which items exist in the database
        const response = await window.csrfHelper.fetchWithCSRF('/api/items/check-existing', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ names: itemNames })
        });
        
        if (!response.ok) {
          throw new Error('Failed to check existing items');
        }
        
        const existingItems = await response.json();
        const foundItems = [];
        const missingItems = [];
        
        itemNames.forEach(itemName => {
          const existingItem = existingItems[itemName.toLowerCase()];
          if (existingItem) {
            foundItems.push(existingItem);
          } else {
            missingItems.push(itemName);
          }
        });
        
        if (foundItems.length === 0) {
          showMessage(`Found ${itemNames.length} items but none exist in database`, 'warning');
          return;
        }
        
        // Confirm if NPC already has loot
        if (matchingNPC.loot && matchingNPC.loot.length > 0) {
          if (!confirm(`${matchingNPC.name} already has ${matchingNPC.loot.length} items. Replace with ${foundItems.length} new items?`)) {
            return;
          }
        }
        
        // Clear current loot and set new loot list - ensure IDs are integers
        const newLootIds = foundItems.map(item => parseInt(item.id));
        
        // Update NPC via API - use individual NPC update endpoint
        const updateResponse = await window.csrfHelper.fetchWithCSRF(`/api/npcs/${matchingNPC.id}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            ...matchingNPC,
            loot: newLootIds
          })
        });
        
        if (!updateResponse.ok) {
          const errorData = await updateResponse.json();
          throw new Error(errorData.error || 'Failed to update NPC loot');
        }
        
        // Get the updated NPC data from response
        const updatedNPC = await updateResponse.json();
        
        // Update the local NPC data
        matchingNPC.loot = updatedNPC.loot || newLootIds;
        matchingNPC.loot_items = updatedNPC.loot_items || [];
        const npcIndex = npcs.findIndex(n => n.id === matchingNPC.id);
        if (npcIndex !== -1) {
          npcs[npcIndex] = matchingNPC;
        }
        
        let message = `Updated ${matchingNPC.name} with ${foundItems.length} loot items`;
        if (missingItems.length > 0) {
          const displayCount = Math.min(5, missingItems.length);
          message += `. ${missingItems.length} items not in database: ${missingItems.slice(0, displayCount).join(', ')}${missingItems.length > displayCount ? '...' : ''}`;
        }
        showMessage(message, 'success');
        
        // If NPC editor is open, reload it to show the new loot
        if (document.getElementById('npc-editor-section') && 
            !document.getElementById('npc-editor-section').classList.contains('collapsed')) {
          await loadNPCEditor();
        }
        
      } catch (error) {
        console.error('Error adding items to NPC:', error);
        showMessage(`Error adding items to NPC: ${error.message}`, 'error');
      }
    }
    
    async function extractFromInspector() {
      // Prevent double extraction
      if (window.isExtractingItems) {
        console.warn('Extraction already in progress, ignoring duplicate call');
        return;
      }
      
      // Clear any stale extraction state
      if (window.extractionCompleted && batchImportItems.length === 0) {
        window.extractionCompleted = false;
      }
      
      // Extract all item URLs from the inspector tree
      const itemUrls = [];
      const processedNodes = new Set();
      
      // Recursively collect all item URLs
      function collectItemUrls(node) {
        if (!node || processedNodes.has(node.id)) return;
        processedNodes.add(node.id);
        
        if (node.type === 'item' && !node.excluded) {
          itemUrls.push(node.url);
        }
        
        if (node.children && node.children.length > 0) {
          node.children.forEach(childId => {
            const childNode = inspectorTreeData[childId];
            if (childNode) {
              collectItemUrls(childNode);
            }
          });
        }
      }
      
      // Debug logging
      
      // Count items before collection
      const itemNodes = Object.values(inspectorTreeData).filter(node => node.type === 'item');
      
      // Debug excluded items
      const excludedItems = itemNodes.filter(node => node.excluded);
      const nonExcludedItems = itemNodes.filter(node => !node.excluded);
      
      // Collect from all root nodes
      Object.values(inspectorTreeData).forEach(node => {
        if (!node.parent) {
          collectItemUrls(node);
        }
      });
      
      
      // If no items found from root traversal, try collecting all item nodes directly
      if (itemUrls.length === 0) {
        Object.values(inspectorTreeData).forEach(node => {
          if (node.type === 'item' && !node.excluded && !itemUrls.includes(node.url)) {
            itemUrls.push(node.url);
          }
        });
      }
      
      if (itemUrls.length === 0) {
        console.error('No items found to extract. Tree data:', inspectorTreeData);
        console.error('Item nodes:', Object.values(inspectorTreeData).filter(n => n.type === 'item'));
        
        // Check if all items are excluded
        const allItemNodes = Object.values(inspectorTreeData).filter(n => n.type === 'item');
        const allExcluded = allItemNodes.length > 0 && allItemNodes.every(n => n.excluded);
        
        if (allExcluded) {
          showMessage('No items to process (all items are excluded)', 'warning');
        } else {
          showMessage('No items found to extract', 'warning');
        }
        return;
      }
      
      // Start fetching item data
      showMessage(`Extracting ${itemUrls.length} items...`, 'info');
      
      // Process the URLs as items
      await processUrlsAsItems(itemUrls);
    }
    
    function updateDataInspector(dataFormat, lines, shouldAnalyze = true) {
      const statusDiv = document.getElementById('inspector-status');
      const resultsDiv = document.getElementById('inspector-results');
      const formatDetectorDiv = document.getElementById('format-detector');
      const liveIndicator = document.getElementById('inspector-live-indicator');
      
      if (!lines || lines.length === 0) {
        // Don't reset if we're currently extracting items or if we have extracted items ready for Step 2
        if (window.isExtractingItems || window.extractionCompleted || (batchImportItems && batchImportItems.length > 0)) {
          return;
        }
        
        // Also don't reset if we have tree data with items
        const hasItemsInTree = Object.values(inspectorTreeData).some(node => node.type === 'item');
        if (hasItemsInTree) {
          return;
        }
        
        // Reset to initial state
        statusDiv.style.display = 'block';
        resultsDiv.style.display = 'none';
        formatDetectorDiv.style.display = 'none';
        liveIndicator.style.display = 'none';
        inspectorTreeData = {};
        
        // Reset status text
        const statusIcon = document.getElementById('inspector-status-icon');
        const statusText = document.getElementById('inspector-status-text');
        const statusSubtext = document.getElementById('inspector-status-subtext');
        if (statusIcon) statusIcon.innerHTML = '';
        if (statusText) statusText.textContent = 'Paste URLs to analyze';
        if (statusSubtext) statusSubtext.textContent = 'The inspector will show what data will be fetched';
        return;
      }
      
      // For URLs that aren't being analyzed yet, show the tree but not live indicator
      if (dataFormat === 'urls' && !shouldAnalyze) {
        statusDiv.style.display = 'none';
        resultsDiv.style.display = 'block';
        // Continue to show the tree, just without analysis
      }
      
      // Hide status and show results for actual analysis
      statusDiv.style.display = 'none';
      resultsDiv.style.display = 'block';
      
      switch (dataFormat) {
        case 'urls':
          if (shouldAnalyze) {
            liveIndicator.style.display = 'inline-flex';
            // Show structure-based detection indicator
            const detectionMode = document.getElementById('inspector-detection-mode');
            if (detectionMode) detectionMode.style.display = 'inline-flex';
          } else {
            liveIndicator.style.display = 'none';
            const detectionMode = document.getElementById('inspector-detection-mode');
            if (detectionMode) detectionMode.style.display = 'none';
          }
          formatDetectorDiv.style.display = 'none';
          // Initialize tree structure for URLs
          initializeUrlTree(lines, shouldAnalyze);
          break;
          
        case 'table':
          liveIndicator.style.display = 'none';
          formatDetectorDiv.style.display = 'block';
          analyzeTableFormat(lines);
          updateInspectorSummaryForTable(lines);
          break;
          
        case 'single-item-data':
          liveIndicator.style.display = 'none';
          formatDetectorDiv.style.display = 'block';
          analyzeSingleItemFormat(lines);
          updateInspectorSummaryForSingleItem();
          break;
          
        case 'single-item':
        case 'list':
          liveIndicator.style.display = 'none';
          formatDetectorDiv.style.display = 'none';
          updateInspectorSummaryForList(lines);
          break;
      }
    }
    
    async function initializeUrlTree(urls, shouldAnalyze = false) {
      // Don't reinitialize if we're extracting items or have extracted items
      if (window.isExtractingItems || (batchImportItems && batchImportItems.length > 0)) {
        return;
      }
      
      inspectorTreeData = {};
      inspectorNodeId = 0;
      
      // Load URL patterns if not already loaded
      if (Object.keys(urlPatterns.prefixes).length === 0) {
        await loadUrlPatterns();
      }
      
      // Deduplicate URLs at the root level
      const uniqueUrls = [...new Set(urls)];
      
      if (shouldAnalyze) {
        // Check URL mappings first
        const mappings = await checkUrlMappings(uniqueUrls);
        
        // Create root nodes for each unique URL
        // Each URL becomes a parent node that can expand based on its type:
        // - NPC pages -> expand to show loot items
        // - List pages -> expand to show individual items
        // - Item pages -> no expansion (leaf nodes)
        uniqueUrls.forEach(url => {
          const nodeId = `node_${inspectorNodeId++}`;
          const mapping = mappings[url];
          
          if (mapping) {
            // Use cached data
            inspectorTreeData[nodeId] = {
              id: nodeId,
              url: url,
              title: mapping.title || decodeURIComponent(url.split('/').pop()).replace(/_/g, ' '),
              type: mapping.type,
              icon: mapping.type === 'npc' ? '' : 
                    mapping.type === 'list' ? '' : 
                    mapping.type === 'item' ? '' : '',
              status: 'cached',
              children: [],
              expanded: true,
              parent: null,
              fromCache: true,
              confidence: mapping.confidence,
              lastVerified: mapping.lastVerified
            };
          } else {
            // Need to fetch
            inspectorTreeData[nodeId] = {
              id: nodeId,
              url: url,
              title: 'Loading...',
              type: 'loading',
              icon: '',
              status: 'loading',
              children: [],
              expanded: true,
              parent: null,
              fromCache: false
            };
          }
        });
        
        // Render initial tree
        renderInspectorTree();
        
        // Show Extract button in disabled state during analysis
        const extractBtnContainer = document.getElementById('inspector-extract-btn-container');
        if (extractBtnContainer) {
          extractBtnContainer.style.display = 'block';
          const extractBtn = document.getElementById('inspector-extract-btn');
          if (extractBtn) {
            extractBtn.disabled = true;
            extractBtn.querySelector('#inspector-extract-btn-text').textContent = 'Analyzing...';
            extractBtn.querySelector('span:first-child').textContent = '';
          }
        }
        
        // Start analyzing URLs
        await analyzeUrlsHierarchically(uniqueUrls);
      } else {
        // Just show the URLs without analyzing
        // Show Extract button in disabled state (but not if extraction is completed)
        if (!window.extractionCompleted) {
          const extractBtnContainer = document.getElementById('inspector-extract-btn-container');
          if (extractBtnContainer) {
            extractBtnContainer.style.display = 'block';
            const extractBtn = document.getElementById('inspector-extract-btn');
            if (extractBtn) {
              extractBtn.disabled = true;
              extractBtn.querySelector('#inspector-extract-btn-text').textContent = 'Analyze URLs First';
              extractBtn.querySelector('span:first-child').textContent = '';
            }
          }
        }
        
        uniqueUrls.forEach(url => {
          const nodeId = `node_${inspectorNodeId++}`;
          inspectorTreeData[nodeId] = {
            id: nodeId,
            url: url,
            title: decodeURIComponent(url.split('/').pop()).replace(/_/g, ' '),
            type: 'pending',
            icon: '',
            status: 'pending',
            children: [],
            expanded: false,
            parent: null,
            fromCache: false
          };
        });
        
        // Render tree showing URLs ready to analyze
        renderInspectorTree();
        
        // Update summary to show URL count
        document.getElementById('inspector-total-urls').textContent = uniqueUrls.length;
        document.getElementById('inspector-npc-count').textContent = '?';
        document.getElementById('inspector-list-stat-count').textContent = '?';
        document.getElementById('inspector-estimated-items').textContent = '?';
      }
    }
    
    // Add click handler to clear selection when clicking outside
    document.addEventListener('click', (e) => {
      const treeContainer = document.getElementById('inspector-tree');
      const contextMenu = document.getElementById('inspector-context-menu');
      
      if (treeContainer && !treeContainer.contains(e.target) && 
          contextMenu && !contextMenu.contains(e.target)) {
        if (selectedNodes.size > 0) {
          selectedNodes.clear();
          renderInspectorTree();
        }
      }
    });
    
    // Add keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      const treeContainer = document.getElementById('inspector-tree');
      if (!treeContainer) return;
      
      // Ctrl/Cmd + A to select all
      if ((e.ctrlKey || e.metaKey) && e.key === 'a') {
        const isInspectorActive = document.getElementById('data-inspector').style.display !== 'none';
        if (isInspectorActive) {
          e.preventDefault();
          selectedNodes.clear();
          Object.keys(inspectorTreeData).forEach(id => selectedNodes.add(id));
          renderInspectorTree();
        }
      }
      
      // Escape to clear selection
      if (e.key === 'Escape' && selectedNodes.size > 0) {
        selectedNodes.clear();
        renderInspectorTree();
      }
    });
    
    function deduplicateRootNodes() {
      const seenUrls = new Set();
      const nodesToDelete = [];
      
      // Find duplicate root nodes
      Object.entries(inspectorTreeData).forEach(([nodeId, node]) => {
        if (!node.parent) { // Root node
          if (seenUrls.has(node.url)) {
            nodesToDelete.push(nodeId);
          } else {
            seenUrls.add(node.url);
          }
        }
      });
      
      // Delete duplicate nodes
      nodesToDelete.forEach(nodeId => {
        delete inspectorTreeData[nodeId];
      });
    }
    
    function renderInspectorTree() {
      const treeContainer = document.getElementById('inspector-tree');
      
      // Don't render empty tree if we have extracted items or are extracting
      if (Object.keys(inspectorTreeData).length === 0 && (window.isExtractingItems || (batchImportItems && batchImportItems.length > 0))) {
        return;
      }
      
      // Debug: Check tree container
      if (!treeContainer) {
        console.error('Inspector tree container not found!');
        return;
      }
      
      
      // Use a document fragment for batch DOM updates
      const fragment = document.createDocumentFragment();
      
      // First, deduplicate root level nodes
      deduplicateRootNodes();
      
      // Get root nodes (nodes without parent)
      const rootNodes = Object.values(inspectorTreeData).filter(node => !node.parent);
      
      // Sort root nodes: lists first, then NPCs, then items, then unknown
      rootNodes.sort((a, b) => {
        const typeOrder = { 'list': 0, 'npc': 1, 'item': 2, 'unknown': 3, 'loading': 4, 'error': 5 };
        const orderA = typeOrder[a.type] ?? 5;
        const orderB = typeOrder[b.type] ?? 5;
        
        if (orderA !== orderB) return orderA - orderB;
        
        // If same type, sort by title
        return (a.title || '').localeCompare(b.title || '');
      });
      
      rootNodes.forEach(node => {
        fragment.appendChild(createTreeNode(node));
      });
      
      // If no nodes to render, show a message
      if (rootNodes.length === 0) {
        treeContainer.innerHTML = '<div style="padding: 20px; color: #999; text-align: center;">No items to display</div>';
        updateInspectorSummary();
        return;
      }
      
      // Clear and append immediately to avoid fragment issues
      treeContainer.innerHTML = '';
      rootNodes.forEach(node => {
        treeContainer.appendChild(createTreeNode(node));
      });
      updateInspectorSummary();
      updateAddToNPCButton();
    }
    
    // Optimized tree update for single node changes
    function updateTreeNode(nodeId) {
      const node = inspectorTreeData[nodeId];
      if (!node) return;
      
      const existingElement = document.getElementById(`tree-${nodeId}`);
      if (!existingElement) {
        // If node doesn't exist, do full render
        renderInspectorTree();
        return;
      }
      
      // If node has children and is a list/npc, always do a full render to ensure children are shown
      if ((node.type === 'list' || node.type === 'npc') && node.children && node.children.length > 0) {
        renderInspectorTree();
        return;
      }
      
      // Create new node element
      const newNodeElement = createTreeNode(node);
      
      // Replace in DOM
      requestAnimationFrame(() => {
        existingElement.replaceWith(newNodeElement);
        updateInspectorSummary();
      });
    }
    
    function createTreeNode(node) {
      const nodeDiv = document.createElement('div');
      nodeDiv.className = 'inspector-tree-node';
      if (selectedNodes.has(node.id)) {
        nodeDiv.className += ' selected';
      }
      if (node.excluded) {
        nodeDiv.className += ' excluded';
      }
      nodeDiv.id = `tree-${node.id}`;
      
      const hasChildren = node.children && node.children.length > 0;
      
      // Create inner container for right-click support
      const innerDiv = document.createElement('div');
      innerDiv.style.display = 'inline-block';
      innerDiv.style.cursor = 'pointer';
      innerDiv.onclick = (e) => handleNodeClick(e, node.id);
      innerDiv.oncontextmenu = (e) => showContextMenu(e, node.id);
      
      let nodeHTML = '';
      
      // Expand/collapse toggle
      if (hasChildren) {
        nodeHTML += `<span class="inspector-tree-expand ${node.expanded ? 'expanded' : ''}" onclick="toggleTreeNode('${node.id}')"></span>`;
      } else {
        nodeHTML += '<span style="display: inline-block; width: 16px;"></span>';
      }
      
      // Icon
      nodeHTML += `<span class="inspector-tree-icon">${node.icon}</span>`;
      
      // Label
      nodeHTML += `<span class="inspector-tree-label">${node.title}</span>`;
      
      // Status/badges
      if (node.status === 'loading') {
        if (node.type === 'list') {
          nodeHTML += '<span class="inspector-tree-status list-loading" style="font-size: 0.7rem; padding: 1px 4px;">Loading items...</span>';
        } else {
          nodeHTML += '<span class="inspector-tree-status loading" style="font-size: 0.7rem; padding: 1px 4px;">...</span>';
        }
      } else if (node.status === 'error') {
        nodeHTML += '<span class="inspector-tree-status error">ERROR</span>';
        if (node.errorMessage) {
          nodeHTML += `<span style="margin-left: 8px; color: #ef4444; font-size: 0.75rem;">${node.errorMessage}</span>`;
        }
        // Single retry button that handles extraction for all error cases
        nodeHTML += `<button onclick="retryItemExtraction('${node.id}'); event.stopPropagation();" style="margin-left: 8px; padding: 2px 8px; font-size: 0.7rem; background: #374151; border: 1px solid #4b5563; color: #9ca3af; border-radius: 3px; cursor: pointer;">Retry</button>`;
      } else if (node.status === 'cached') {
        nodeHTML += '<span class="inspector-verified-badge"> CACHED</span>';
        if (node.confidence >= 0.8) {
          nodeHTML += `<span style="margin-left: 4px; color: #10b981; font-size: 0.7rem;"></span>`;
        } else if (node.confidence >= 0.5) {
          nodeHTML += `<span style="margin-left: 4px; color: #f59e0b; font-size: 0.7rem;"></span>`;
        } else {
          nodeHTML += `<span style="margin-left: 4px; color: #ef4444; font-size: 0.7rem;"></span>`;
        }
        if (hasChildren) {
          // For NPCs, count all nested items recursively
          if (node.type === 'npc') {
            const itemCount = countAllItemsRecursively(node);
            nodeHTML += `<span class="inspector-tree-count">(${itemCount} items)</span>`;
          } else {
            nodeHTML += `<span class="inspector-tree-count">(${node.children.length})</span>`;
          }
        }
      } else if (node.status === 'extracted') {
        nodeHTML += '<span class="inspector-tree-status extracted"> EXTRACTED</span>';
      } else if (node.status === 'success') {
        if (node.fromCache) {
          nodeHTML += '<span class="inspector-verified-badge"> VERIFIED</span>';
        }
        if (hasChildren) {
          // For NPCs, count all nested items recursively
          if (node.type === 'npc') {
            const itemCount = countAllItemsRecursively(node);
            nodeHTML += `<span class="inspector-tree-count">(${itemCount} items)</span>`;
          } else {
            nodeHTML += `<span class="inspector-tree-count">(${node.children.length})</span>`;
          }
        }
      }
      
      innerDiv.innerHTML = nodeHTML;
      nodeDiv.appendChild(innerDiv);
      
      // Add children container
      if (hasChildren && node.expanded) {
        const childrenDiv = document.createElement('div');
        childrenDiv.className = 'inspector-tree-children';
        
        
        node.children.forEach(childId => {
          const childNode = inspectorTreeData[childId];
          if (childNode) {
            childrenDiv.appendChild(createTreeNode(childNode));
          }
        });
        
        nodeDiv.appendChild(childrenDiv);
      }
      
      return nodeDiv;
    }
    
    function toggleTreeNode(nodeId) {
      const node = inspectorTreeData[nodeId];
      if (node) {
        node.expanded = !node.expanded;
        renderInspectorTree();
      }
    }
    
    async function retryNode(nodeId) {
      const node = inspectorTreeData[nodeId];
      if (!node) {
        console.error('Retry failed: node not found', nodeId);
        return;
      }
      
      
      
      // Reset node status
      node.status = 'loading';
      node.type = 'loading';
      node.icon = '';
      node.errorMessage = null;
      
      // Update the tree to show loading state
      updateTreeNode(nodeId);
      
      // Re-analyze the node
      try {
        await analyzeUrlNode(node);
        
        // If it's a list or NPC that now has children, ensure they're displayed
        if ((node.type === 'list' || node.type === 'npc') && node.children && node.children.length > 0) {
          renderInspectorTree();
        } else {
          updateTreeNode(nodeId);
        }
        
      } catch (error) {
        console.error('Retry failed for node:', nodeId, node.title, error);
        // Error will be handled by analyzeUrlNode
        updateTreeNode(nodeId);
      }
    }
    
    async function retryItemExtraction(nodeId) {
      const node = inspectorTreeData[nodeId];
      if (!node) {
        console.error('Retry failed: node not found', nodeId);
        return;
      }
      
      // If it's not an item or if the type is unknown, do URL analysis first
      if (node.type !== 'item' || node.type === 'unknown' || node.type === 'error') {
        await retryNode(nodeId);
        return;
      }
      
      
      // Reset node status to show retry attempt
      node.status = 'loading';
      node.icon = '';
      node.errorMessage = null;
      updateTreeNode(nodeId);
      
      try {
        // Re-fetch the page content
        const url = node.url;
        let proxyUrl = 'https://api.allorigins.win/get?url=' + encodeURIComponent(url);
        let response = await fetch(proxyUrl, { 
          method: 'GET',
          mode: 'cors',
          cache: 'no-cache',
          signal: AbortSignal.timeout(10000)
        });
        
        let pageContent = null;
        if (response.ok) {
          const data = await response.json();
          pageContent = data.contents;
        } else {
          // Try fallback proxy
          const altProxyUrl = 'https://corsproxy.io/?' + encodeURIComponent(url);
          response = await fetch(altProxyUrl, {
            method: 'GET',
            mode: 'cors',
            cache: 'no-cache',
            signal: AbortSignal.timeout(10000)
          });
          
          if (response.ok) {
            pageContent = await response.text();
          }
        }
        
        if (pageContent) {
          // Debug logging for Wyrmsbane
          if (url.includes('Wyrmsbane_Lieutenant')) {
          }
          
          // Parse the item data
          const itemData = parseWikiItemData(pageContent, url);
          
          // Debug logging for Wyrmsbane
          if (url.includes('Wyrmsbane_Lieutenant')) {
            if (itemData) {
            }
          }
          
          if (itemData) {
            // Add URL to description field
            itemData.description = url;
            itemData.tempId = `batch_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            
            // Transfer excluded status from tree node
            if (node && node.excluded) {
              itemData.excluded = true;
            }
            
            // Update or add to batch import items
            const existingIndex = batchImportItems.findIndex(item => item.description === url);
            if (existingIndex >= 0) {
              // Update existing item
              batchImportItems[existingIndex] = itemData;
            } else {
              // Add new item
              batchImportItems.push(itemData);
            }
            
            // Update tree node to show success
            node.icon = '';
            node.status = 'extracted';
            node.title = itemData.name; // Update with parsed name
            updateTreeNode(nodeId);
            
            // Update the table to show the new/updated item
            renderBatchImportTable();
            updateBatchImportCount();
            updateBatchImportStatus();
            
            showMessage(`Successfully re-extracted: ${itemData.name}`, 'success');
            updateRetryAllButton();
            updateAddToNPCButton();
          } else {
            // Parsing failed again
            node.icon = '';
            node.status = 'error';
            node.errorMessage = 'Failed to parse item data (retry)';
            updateTreeNode(nodeId);
            updateRetryAllButton();
            updateAddToNPCButton();
            console.error('Item extraction retry failed - parsing error:', nodeId, node.title);
          }
        } else {
          // Fetch failed
          node.icon = '';
          node.status = 'error';  
          node.errorMessage = 'Failed to fetch page (retry)';
          updateTreeNode(nodeId);
          updateRetryAllButton();
        updateAddToNPCButton();
          updateAddToNPCButton();
          console.error('Item extraction retry failed - fetch error:', nodeId, node.title);
        }
      } catch (error) {
        console.error('Item extraction retry failed:', nodeId, node.title, error);
        node.icon = '';
        node.status = 'error';
        node.errorMessage = `Retry error: ${error.message}`;
        updateTreeNode(nodeId);
        updateRetryAllButton();
        updateAddToNPCButton();
      }
    }
    
    async function retryAllFailedExtractions() {
      // Find all nodes that are items with error status
      const failedNodes = Object.values(inspectorTreeData).filter(node => 
        node.type === 'item' && node.status === 'error'
      );
      
      if (failedNodes.length === 0) {
        showMessage('No failed extractions to retry', 'info');
        return;
      }
      
      const retryAllBtn = document.getElementById('inspector-retry-all-btn');
      if (retryAllBtn) {
        retryAllBtn.disabled = true;
        retryAllBtn.innerHTML = `<span style="margin-right: 8px;"></span><span>Retrying ${failedNodes.length} items...</span>`;
      }
      
      let successCount = 0;
      let stillFailedCount = 0;
      
      showMessage(`Retrying ${failedNodes.length} failed extractions...`, 'info');
      
      // Retry each failed node
      for (const node of failedNodes) {
        try {
          await retryItemExtraction(node.id);
          // Check if it succeeded (status changed from error)
          if (node.status === 'extracted') {
            successCount++;
          } else {
            stillFailedCount++;
          }
          
          // Small delay between retries
          await new Promise(resolve => setTimeout(resolve, 500));
        } catch (error) {
          console.error('Retry all failed for node:', node.id, error);
          stillFailedCount++;
        }
      }
      
      // Update button state
      if (retryAllBtn) {
        updateRetryAllButton();
        updateAddToNPCButton();
      }
      
      // Show results
      if (successCount > 0 && stillFailedCount === 0) {
        showMessage(` Successfully retried all ${successCount} failed extractions!`, 'success');
      } else if (successCount > 0) {
        showMessage(`Retried ${failedNodes.length} items: ${successCount} succeeded, ${stillFailedCount} still failed`, 'warning');
      } else {
        showMessage(` All ${failedNodes.length} retry attempts failed`, 'error');
      }
    }
    
    function updateRetryAllButton() {
      const retryAllBtn = document.getElementById('inspector-retry-all-btn');
      if (!retryAllBtn) return;
      
      // Count failed item extractions
      const failedNodes = Object.values(inspectorTreeData).filter(node => 
        node.type === 'item' && node.status === 'error'
      );
      
      if (failedNodes.length > 0) {
        retryAllBtn.style.display = 'inline-block';
        retryAllBtn.disabled = false;
        retryAllBtn.innerHTML = `<span style="margin-right: 8px;"></span><span>Retry All Failed (${failedNodes.length})</span>`;
      } else {
        retryAllBtn.style.display = 'none';
      }
    }
    
    function updateAddToNPCButton() {
      const addToNPCBtn = document.getElementById('inspector-add-to-npc-btn');
      if (!addToNPCBtn) return;
      
      // Check if there's an NPC node in the tree
      const npcNode = Object.values(inspectorTreeData).find(node => node.type === 'npc');
      const itemNodes = Object.values(inspectorTreeData).filter(node => 
        node.type === 'item' && !node.excluded
      );
      
      if (npcNode && itemNodes.length > 0) {
        addToNPCBtn.style.display = 'inline-block';
        addToNPCBtn.disabled = false;
      } else {
        addToNPCBtn.style.display = 'none';
      }
    }
    
    function updateInspectorSummary() {
      const nodes = Object.values(inspectorTreeData);
      
      let totalUrls = nodes.filter(n => !n.parent).length;
      let npcCount = nodes.filter(n => n.type === 'npc').length;
      let listCount = nodes.filter(n => n.type === 'list').length;
      let itemCount = nodes.filter(n => n.type === 'item').length;
      
      // For estimated items, only count actual items if lists are expanded
      // Otherwise use estimates
      let estimatedItems = itemCount;
      
      // For unexpanded lists, add their estimates
      nodes.filter(n => n.type === 'list').forEach(listNode => {
        // If list has no children yet (not expanded), use estimate
        if ((!listNode.children || listNode.children.length === 0) && listNode.estimatedCount) {
          estimatedItems += listNode.estimatedCount;
        }
      });
      
      document.getElementById('inspector-total-urls').textContent = totalUrls;
      document.getElementById('inspector-npc-count').textContent = npcCount;
      document.getElementById('inspector-list-stat-count').textContent = listCount;
      document.getElementById('inspector-estimated-items').textContent = estimatedItems;
    }
    
    function updateInspectorSummaryForTable(lines) {
      document.getElementById('inspector-total-urls').textContent = '0';
      document.getElementById('inspector-npc-count').textContent = '0';
      document.getElementById('inspector-list-stat-count').textContent = '0';
      document.getElementById('inspector-estimated-items').textContent = lines.length - 1; // Exclude header
    }
    
    function updateInspectorSummaryForSingleItem() {
      document.getElementById('inspector-total-urls').textContent = '0';
      document.getElementById('inspector-npc-count').textContent = '0';
      document.getElementById('inspector-list-stat-count').textContent = '0';
      document.getElementById('inspector-estimated-items').textContent = '1';
    }
    
    function updateInspectorSummaryForList(lines) {
      document.getElementById('inspector-total-urls').textContent = '0';
      document.getElementById('inspector-npc-count').textContent = '0';
      document.getElementById('inspector-list-stat-count').textContent = '0';
      document.getElementById('inspector-estimated-items').textContent = lines.length;
    }
    
    function updateExtractButtonState() {
      // Check if all URL analysis is complete (no loading nodes)
      const hasLoadingNodes = Object.values(inspectorTreeData).some(n => n.status === 'loading');
      
      // Don't update button state if we're still loading or if extraction is already in progress/completed
      if (hasLoadingNodes || window.isExtractingItems || window.extractionCompleted) {
        return;
      }
      
      const extractBtnContainer = document.getElementById('inspector-extract-btn-container');
      const addToNPCBtn = document.getElementById('inspector-add-to-npc-btn');
      
      if (extractBtnContainer) {
        const itemCount = Object.values(inspectorTreeData).filter(n => n.type === 'item').length;
        const npcNodes = Object.values(inspectorTreeData).filter(n => n.type === 'npc' && !n.parent);
        
        if (itemCount > 0) {
          extractBtnContainer.style.display = 'block';
          // Enable button
          const extractBtn = document.getElementById('inspector-extract-btn');
          if (extractBtn && extractBtn.disabled) {
            extractBtn.disabled = false;
            extractBtn.querySelector('#inspector-extract-btn-text').textContent = 'Extract Loot';
            extractBtn.querySelector('span:first-child').textContent = '';
            // Ensure onclick is correct if not in completed extraction state
            if (!window.extractionCompleted || batchImportItems.length === 0) {
              extractBtn.onclick = extractFromInspector;
            }
          }
          
          // Show "Add to NPC" button if we have exactly one NPC node with items
          if (addToNPCBtn && npcNodes.length === 1) {
            const npcNode = npcNodes[0];
            const npcItemCount = countAllItemsRecursively(npcNode);
            if (npcItemCount > 0) {
              addToNPCBtn.style.display = 'inline-block';
              addToNPCBtn.title = `Add ${npcItemCount} items to ${npcNode.title}`;
            } else {
              addToNPCBtn.style.display = 'none';
            }
          } else if (addToNPCBtn) {
            addToNPCBtn.style.display = 'none';
          }
        } else {
          // Hide button if no items found
          extractBtnContainer.style.display = 'none';
        }
      }
    }
    
    async function analyzeUrlsHierarchically(urls) {
      const progressDiv = document.getElementById('inspector-progress');
      const progressBar = document.getElementById('inspector-progress-bar');
      const progressText = document.getElementById('inspector-progress-text');
      const progressPercent = document.getElementById('inspector-progress-percent');
      
      // Separate cached and non-cached URLs
      const nodesToAnalyze = [];
      const cachedExpandableNodes = [];
      const mappingsToRegister = [];
      
      
      for (const url of urls) {
        const node = Object.values(inspectorTreeData).find(n => n.url === url && n.parent === null);
        
        
        if (!node) {
          console.warn('No node found for URL:', url);
          continue;
        }
        
        if (node.status === 'cached') {
          // If it's a cached list or NPC, we need to expand it
          if (node.type === 'list' || node.type === 'npc') {
            cachedExpandableNodes.push(node);
          }
          // Cached items don't need any processing - they're already complete
        } else {
          nodesToAnalyze.push(node);
        }
      }
      
      
      // If all URLs are cached, just expand the expandable ones
      if (nodesToAnalyze.length === 0 && cachedExpandableNodes.length > 0) {
        progressDiv.style.display = 'block';
        progressText.textContent = 'Expanding cached URLs...';
        progressBar.style.width = '50%';
        
        for (const node of cachedExpandableNodes) {
          await expandCachedNode(node);
        }
        
        progressDiv.style.display = 'none';
      } else if (nodesToAnalyze.length > 0) {
        // Analyze non-cached URLs
        progressDiv.style.display = 'block';
        
        let analyzed = 0;
        const total = nodesToAnalyze.length;
        
        for (const node of nodesToAnalyze) {
          progressText.textContent = `Analyzing ${node.url.split('/').pop()}...`;
          progressBar.style.width = `${(analyzed / total) * 100}%`;
          progressPercent.textContent = `${Math.round((analyzed / total) * 100)}%`;
          
          
          try {
            await analyzeUrlNode(node);
          } catch (error) {
            console.error('Error in analyzeUrlNode:', error, {
              nodeId: node.id,
              nodeUrl: node.url
            });
            // Ensure node is marked as error if analyzeUrlNode throws
            node.status = 'error';
            node.type = 'error';
            node.icon = '';
            node.errorMessage = error.message;
          }
          
          
          // Register successful mappings
          if (node.status === 'success' && node.type !== 'unknown') {
            mappingsToRegister.push({
              url: node.url,
              type: node.type,
              title: node.title
            });
          }
          
          analyzed++;
          
          // Update only this node in the tree
          updateTreeNode(node.id);
          
          // Add a small delay between requests to avoid rate limiting
          if (analyzed < total) {
            await new Promise(resolve => setTimeout(resolve, 300));
          }
        }
        
        // Register all new mappings
        if (mappingsToRegister.length > 0) {
          await registerUrlMappings(mappingsToRegister);
        }
      }
      
      progressDiv.style.display = 'none';
      document.getElementById('inspector-live-indicator').style.display = 'none';
      
      // Wait for any pending child analysis promises
      const pendingPromises = [];
      Object.values(inspectorTreeData).forEach(node => {
        if (node.childAnalysisPromise) {
          pendingPromises.push(node.childAnalysisPromise);
        }
      });
      
      if (pendingPromises.length > 0) {
        await Promise.allSettled(pendingPromises);
      }
      
      // Check for any stuck loading nodes and mark them as errors
      Object.values(inspectorTreeData).forEach(node => {
        if (node.status === 'loading') {
          // Special check for Wyrmsbane
          if (node.url && node.url.includes('Wyrmsbane_Lieutenant')) {
            console.error('WYRMSBANE STUCK IN LOADING:', {
              nodeId: node.id,
              nodeTitle: node.title,
              nodeUrl: node.url,
              nodeType: node.type,
              nodeStatus: node.status,
              fullNode: node
            });
          }
          
          console.error('Node stuck in loading state:', {
            nodeId: node.id,
            nodeTitle: node.title,
            nodeUrl: node.url,
            nodeType: node.type
          });
          node.status = 'error';
          node.type = 'error';
          node.icon = '';
          node.errorMessage = 'Failed to load - timeout';
        }
      });
      
      // Final tree render to ensure all children are displayed
      renderInspectorTree();
      
      // Show warnings/hints
      generateInspectorWarnings();
      
      // Update Extract button state when analysis is complete
      updateExtractButtonState();
    }
    
    async function expandCachedNode(node) {
      if (node.type === 'npc') {
        // For NPCs, we need to fetch the page to get loot URLs
        node.status = 'loading';
        node.icon = '';
        updateTreeNode(node.id);
        
        await analyzeUrlNode(node);
        renderInspectorTree();
        generateInspectorWarnings();
        updateExtractButtonState(); // Check if Extract button should be enabled
      } else if (node.type === 'list') {
        // For lists, we also need to fetch to get item URLs
        node.status = 'loading';
        node.icon = '';
        updateTreeNode(node.id);
        
        await analyzeUrlNode(node);
        renderInspectorTree();
        generateInspectorWarnings();
        updateExtractButtonState(); // Check if Extract button should be enabled
      }
    }
    
    async function analyzeUrlNode(node) {
      // IMPORTANT: Never analyze a node that's already cached
      if (node.status === 'cached') {
        return;
      }
      
      const cleanUrl = node.url.endsWith('#list') ? node.url.slice(0, -5) : node.url;
      const forceList = node.url.endsWith('#list');
      
      
      // Update progress text if available
      const progressText = document.getElementById('inspector-progress-text');
      if (progressText) {
        progressText.textContent = `Analyzing: ${decodeURIComponent(cleanUrl.split('/').pop()).replace(/_/g, ' ')}`;
      }
      
      if (!cleanUrl.includes('/wiki/')) {
        node.type = 'unknown';
        node.icon = '';
        node.title = 'Unknown URL';
        node.status = 'error';
        return;
      }
      
      let pageContent = '';
      
      try {
        
        // Debug logging for problem URLs
        if (cleanUrl.includes('Wyrmsbane_Lieutenant')) {
        }
        
        // Try primary proxy first
        const proxyUrl = 'https://api.allorigins.win/get?url=' + encodeURIComponent(cleanUrl);
        let response;
        
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => {
            console.error('Primary proxy timeout after 15s for:', cleanUrl);
            controller.abort();
          }, 15000); // 15 second timeout
          
          response = await fetch(proxyUrl, { 
            method: 'GET',
            mode: 'cors',
            cache: 'no-cache',
            signal: controller.signal
          });
          
          clearTimeout(timeoutId);
          
          if (response.ok) {
            const data = await response.json();
            pageContent = data.contents || '';
          } else {
            throw new Error('Primary proxy failed');
          }
        } catch (primaryError) {
          console.error('Primary proxy failed for URL:', cleanUrl, primaryError);
          
          // Update node to show retry status
          node.title = 'Retrying...';
          if (progressText) {
            progressText.textContent = `Retrying: ${cleanUrl.split('/').pop()}`;
          }
          
          // Try fallback proxy
          const altProxyUrl = 'https://corsproxy.io/?' + encodeURIComponent(cleanUrl);
          try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => {
              console.error('Fallback proxy timeout after 15s for:', cleanUrl);
              controller.abort();
            }, 15000); // 15 second timeout
            
            response = await fetch(altProxyUrl, {
              method: 'GET',
              mode: 'cors',
              cache: 'no-cache',
              signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            if (response.ok) {
              pageContent = await response.text();
            } else {
              console.error(`Fallback proxy returned ${response.status} for URL:`, cleanUrl);
              throw new Error('Fallback proxy returned ' + response.status);
            }
          } catch (fallbackError) {
            console.error('Both proxies failed for URL:', cleanUrl, {
              primaryError: primaryError,
              fallbackError: fallbackError
            });
            throw new Error('Network error - try again later');
          }
        }
        
        if (!pageContent) {
          console.error('Empty response received for URL:', cleanUrl);
          if (cleanUrl.includes('Wyrmsbane_Lieutenant')) {
          }
          node.type = 'error';
          node.icon = '';
          node.title = 'Empty response';
          node.status = 'error';
          node.errorMessage = 'No content received';
          return;
        }
        
        // Debug content for problem URLs
        if (cleanUrl.includes('Wyrmsbane_Lieutenant')) {
        }
        
        // Parse the page
        const parser = new DOMParser();
        
        // Special debugging for Wyrmsbane before parsing
        if (cleanUrl.includes('Wyrmsbane_Lieutenant')) {
        }
        
        const doc = parser.parseFromString(pageContent, 'text/html');
        const pageText = doc.body ? doc.body.textContent.toLowerCase() : '';
        const pageTextLower = pageText; // Declare pageTextLower immediately after pageText
        const h1 = doc.querySelector('h1');
        const pageTitle = h1 ? h1.textContent.trim() : '';
        
        // Special debugging for Wyrmsbane after parsing
        if (cleanUrl.includes('Wyrmsbane_Lieutenant')) {
        }
        
        // Update node title - decode URL encoding for special characters
        node.title = pageTitle || decodeURIComponent(cleanUrl.split('/').pop()).replace(/_/g, ' ');
        
        // Check page structure for NPC indicators
        
        // Look for NPC-specific table headers or sections
        const npcTableHeaders = doc.querySelectorAll('th, h2, h3, strong');
        let hasNPCStructure = false;
        let npcIndicators = [];
        
        // Check for structured NPC data
        for (const header of npcTableHeaders) {
          const headerText = header.textContent.toLowerCase().trim();
          // Also check for headers with colons (e.g., "Level:" instead of just "level")
          const cleanHeaderText = headerText.replace(/[:\s]+$/, '');
          if (cleanHeaderText === 'level' || cleanHeaderText === 'race' || cleanHeaderText === 'type' ||
              cleanHeaderText === 'health' || cleanHeaderText === 'damage' || cleanHeaderText === 'ac' ||
              cleanHeaderText === 'spawn location' || cleanHeaderText === 'respawn time' ||
              cleanHeaderText === 'faction' || cleanHeaderText === 'aggro radius' ||
              headerText.includes('level') || headerText.includes('health') || 
              headerText.includes('race') || headerText.includes('class')) {
            hasNPCStructure = true;
            npcIndicators.push(cleanHeaderText);
          }
        }
        
        // Check for NPC stats in table format
        const tables = doc.querySelectorAll('table');
        let hasNPCStatsTable = false;
        for (const table of tables) {
          const tableText = table.textContent.toLowerCase();
          if ((tableText.includes('level') && tableText.includes('race')) ||
              (tableText.includes('health') && tableText.includes('damage')) ||
              (tableText.includes('spawn') && tableText.includes('location'))) {
            hasNPCStatsTable = true;
            break;
          }
        }
        
        // Check for loot sections
        const hasLootSections = pageText.includes('unique loot') || pageText.includes('common loot') || 
                               pageText.includes('loot') || pageText.includes('drops');
        
        // Name matching is NO LONGER used for detection (kept for logging only)
        const looksLikeNPCName = /^[A-Z][a-z]+ [A-Z]/.test(pageTitle) || 
                                pageTitle.toLowerCase().includes('marshal') ||
                                pageTitle.toLowerCase().includes('guard') ||
                                pageTitle.toLowerCase().includes('keeper');
        
        // Remove all this duplicate detection logic - we'll use the simpler version below
        
        // 1. Check for NPC-specific patterns FIRST (to avoid false positives)
        let hasNPCInfoBox = false;
        let npcSpecificFields = 0;
        const allHeaders = doc.querySelectorAll('th, strong, b, td');
        
        for (const element of allHeaders) {
          const text = element.textContent.toLowerCase().trim();
          // NPC-specific fields that rarely appear on item pages
          if (text === 'race:' || text === 'factions:' || text === 'opposing factions:' ||
              text === 'location:' || text === 'spawn time:' || text === 'respawn time:') {
            npcSpecificFields++;
          }
        }
        
        // Check for NPC loot sections
        const hasUniqueLootSection = pageText.includes('Unique Loot') || pageText.includes('unique loot');
        const hasCommonLootSection = pageText.includes('Common Loot') || pageText.includes('common loot');
        
        // NPC pages have both Race: and Level: together
        const hasRaceAndLevel = pageText.match(/Race:\s*\w+/i) && pageText.match(/Level:\s*[\d~-]+/i);
        
        hasNPCInfoBox = (npcSpecificFields >= 2) || (hasRaceAndLevel && (hasUniqueLootSection || hasCommonLootSection));
        
        // 2. Check for Item List patterns (multiple items)
        // Don't call parseItemListPage here - it should only be called AFTER we determine it's a list
        const hasSetCategory = pageText.match(/Category:.*\bSets?\b/i) !== null;
        const hasCategoryListing = doc.querySelector('.mw-category, #mw-pages') !== null;
        
        // Check page title for known list patterns - be VERY specific
        const titleSuggestsList = /^(List of|All |Category:)/i.test(pageTitle) || 
                                 (pageTitle === 'Rusty Weapons' || pageTitle === 'Tattered Cloth' || pageTitle === 'Tattered Rawhide');
        
        // Be very conservative about list detection - only obvious lists
        const isItemListPage = hasSetCategory || hasCategoryListing || titleSuggestsList;
        
        // 3. Check for Individual Item patterns (single item)
        let itemSpecificFields = 0;
        let hasDropsFromSection = false;
        let hasItemInfoBox = false;
        
        for (const element of allHeaders) {
          const text = element.textContent.toLowerCase().trim();
          // Item-specific fields
          if (text === 'slot:' || text === 'classes:' || text === 'weapon dmg:' || 
              text === 'atk delay:' || text === 'weight:' || text === 'size:') {
            itemSpecificFields++;
          }
        }
        
        // Check for "Drops From" section (items have this, NPCs don't)
        hasDropsFromSection = pageText.includes('Drops From') || pageText.includes('drops from');
        
        // Item pages have specific combinations
        hasItemInfoBox = itemSpecificFields >= 2 && !hasNPCInfoBox;
        
        // 4. Check for Spell/Ability patterns
        let isSpellOrAbility = false;
        let spellIndicators = 0;
        
        // Check for spell-specific fields and patterns
        for (const element of allHeaders) {
          const text = element.textContent.toLowerCase().trim();
          // Spell-specific fields
          if (text === 'mana cost:' || text === 'cast time:' || text === 'recast time:' || 
              text === 'range:' || text === 'duration:' || text === 'target:' ||
              text === 'spell type:' || text === 'resist type:' || text === 'reagents:') {
            spellIndicators++;
          }
        }
        
        // Check for spell descriptions
        const hasSpellDescription = pageText.match(/increases? (your |target's |the )?(strength|stamina|agility|dexterity|wisdom|intelligence|charisma|armor class|hit points|mana)/i) ||
                                   pageText.match(/(buff|debuff|heal|damage|teleport|summon|charm|fear|root|snare|stun|mesmerize)/i) ||
                                   pageText.match(/spell effect:|magical effect:|when cast:/i);
        
        // Check for "Learned By" section (spells have this)
        const hasLearnedBySection = pageText.includes('Learned By') || pageText.includes('learned by') ||
                                   pageText.includes('Classes:') && pageText.match(/Level \d+:/i);
        
        // Spell pages typically have mana cost and cast time
        const hasManaCost = pageText.match(/Mana Cost:\s*\d+/i);
        const hasCastTime = pageText.match(/Cast Time:\s*[\d.]+/i);
        
        isSpellOrAbility = (spellIndicators >= 2) || 
                          (hasManaCost && hasCastTime) ||
                          (hasSpellDescription && hasLearnedBySection);
        
        // Final determination with clear priority
        let pageType = 'unknown';
        
        if (hasNPCInfoBox) {
          pageType = 'npc';
        } else if (isSpellOrAbility) {
          pageType = 'spell';
        } else if (hasItemInfoBox || (hasDropsFromSection && itemSpecificFields > 0)) {
          pageType = 'item';
        } else if (isItemListPage) {
          pageType = 'list';
        } else {
          // Default to item for any unknown page (not NPC, not list, not spell)
          // This is safer than marking things as lists
          pageType = 'item';
        }
        
        
        
        // Apply detection results based on page type
        if (pageType === 'npc') {
          node.type = 'npc';
          node.icon = '';
          node.status = 'success';
          
          // Ensure node is expanded to show children
          node.expanded = true;
          
          // Extract loot URLs for NPC
          const lootUrls = parseNPCLootPage(pageContent, cleanUrl);
          
          // Check child URLs against cache
          const childMappings = lootUrls.length > 0 ? await checkUrlMappings(lootUrls) : {};
          
          // Create child nodes for loot
          const existingChildUrls = new Set();
          // Ensure children array exists
          if (!node.children) {
            node.children = [];
          }
          for (const existingChildId of node.children) {
            const existingChild = inspectorTreeData[existingChildId];
            if (existingChild) {
              existingChildUrls.add(existingChild.url);
            }
          }
          
          for (const lootUrl of lootUrls) {
            // Skip if this URL is already a child
            if (existingChildUrls.has(lootUrl)) {
              continue;
            }
            
            const childId = `node_${inspectorNodeId++}`;
            const childMapping = childMappings[lootUrl];
            
            if (childMapping) {
              // Don't trust cached 'list' types for now - re-analyze them
              const shouldReanalyze = childMapping.type === 'list' && 
                                     !lootUrl.includes('Rusty_Weapons') && 
                                     !lootUrl.includes('Tattered_Cloth') && 
                                     !lootUrl.includes('Tattered_Rawhide');
              
              // If cached as 'unknown', treat as 'item' for NPC loot
              const effectiveType = shouldReanalyze ? 'loading' : 
                                   (childMapping.type === 'unknown' ? 'item' : childMapping.type);
              
              inspectorTreeData[childId] = {
                id: childId,
                url: lootUrl,
                title: childMapping.title || decodeURIComponent(lootUrl.split('/').pop()).replace(/_/g, ' '),
                type: effectiveType,
                icon: shouldReanalyze ? '' : (effectiveType === 'item' ? '' : 
                      effectiveType === 'list' ? '' : ''),
                status: shouldReanalyze ? 'loading' : (childMapping.type === 'list' ? 'cached-needs-expansion' : 'cached'),
                children: [],
                expanded: true,
                parent: node.id,
                fromCache: !shouldReanalyze,
                confidence: childMapping.confidence
              };
            } else {
              inspectorTreeData[childId] = {
                id: childId,
                url: lootUrl,
                title: 'Loading...',
                type: 'loading',
                icon: '',
                status: 'loading',
                children: [],
                expanded: true,
                parent: node.id
              };
            }
            node.children.push(childId);
          }
          
          // Sort children to put lists first
          sortParentChildren(node.id);
          
          // Don't update here - let the parent function handle the update
          
          // Store promise for child analysis to ensure it completes
          node.childAnalysisPromise = null;
          
          // Analyze non-cached child nodes
          if (lootUrls.length > 0) {
            node.childAnalysisPromise = (async () => {
              const mappingsToRegister = [];
              
              
              for (const childId of node.children) {
                const childNode = inspectorTreeData[childId];
                
                
                if (childNode && childNode.status === 'loading') {
                  try {
                    await analyzeUrlNode(childNode);
                    
                    // Register successful mapping
                    if (childNode.status === 'success' && childNode.type !== 'unknown') {
                      mappingsToRegister.push({
                        url: childNode.url,
                        type: childNode.type,
                        title: childNode.title
                      });
                    }
                  } catch (childError) {
                    console.error('Error analyzing child node:', {
                      parentNode: node.title,
                      childNode: childNode.title,
                      childUrl: childNode.url,
                      error: childError
                    });
                    // Error is already handled in analyzeUrlNode
                  }
                  
                  // Add delay between child requests
                  await new Promise(resolve => setTimeout(resolve, 200));
                }
              }
              
              // After analyzing all children, check if any are lists that need expansion
              for (const childId of node.children) {
                const childNode = inspectorTreeData[childId];
                if (childNode && childNode.type === 'list') {
                  if (!childNode.children || childNode.children.length === 0 || childNode.status === 'cached-needs-expansion') {
                    childNode.status = 'loading';
                    updateTreeNode(childId); // Show loading animation immediately
                    try {
                      await analyzeUrlNode(childNode);
                    } catch (listError) {
                      console.error('Error expanding list from NPC loot:', {
                        parentNPC: node.title,
                        listNode: childNode.title,
                        listUrl: childNode.url,
                        error: listError
                      });
                      // Error is already handled in analyzeUrlNode
                    }
                  }
                }
              }
              
              // Register new mappings
              if (mappingsToRegister.length > 0) {
                await registerUrlMappings(mappingsToRegister);
              }
              
              // Final render to show all expanded content
              renderInspectorTree();
              generateInspectorWarnings();
            })();
            
            // Execute the promise but don't await it here to avoid blocking
            node.childAnalysisPromise.catch(error => {
              console.error('Error in child analysis:', error);
            });
          }
        } else if (pageType === 'list') {
          node.type = 'list';
          node.icon = '';
          
          // Parse the list page to get items
          const listPageLinks = await parseItemListPage(pageContent, cleanUrl);
          
          // Ensure listPageLinks is always an array
          const safeListPageLinks = Array.isArray(listPageLinks) ? listPageLinks : [];
          
          // Set loading status while we process items
          if (safeListPageLinks.length > 0) {
            node.status = 'loading';
            updateTreeNode(node.id); // Show loading animation immediately
          }
          
          node.estimatedCount = safeListPageLinks.length;
          
          
          // Ensure node is expanded to show children
          node.expanded = true;
          
          // Check child URLs against cache
          const itemMappings = safeListPageLinks.length > 0 ? await checkUrlMappings(safeListPageLinks) : {};
          
          // Create child nodes for items
          const existingChildUrls = new Set();
          // Ensure children array exists
          if (!node.children) {
            node.children = [];
          }
          for (const existingChildId of node.children) {
            const existingChild = inspectorTreeData[existingChildId];
            if (existingChild) {
              existingChildUrls.add(existingChild.url);
            }
          }
          
          for (const itemUrl of safeListPageLinks) {
            // Skip if this URL is already a child
            if (existingChildUrls.has(itemUrl)) {
              continue;
            }
            
            const childId = `node_${inspectorNodeId++}`;
            const itemMapping = itemMappings[itemUrl];
            
            inspectorTreeData[childId] = {
              id: childId,
              url: itemUrl,
              title: itemMapping?.title || decodeURIComponent(itemUrl.split('/').pop()).replace(/_/g, ' '),
              type: itemMapping?.type || 'item',
              icon: itemMapping?.type === 'list' ? '' : '',
              status: itemMapping ? 'cached' : 'success',
              children: [],
              expanded: true,  // Changed to true to show children by default
              parent: node.id,
              fromCache: !!itemMapping,
              confidence: itemMapping?.confidence
            };
            node.children.push(childId);
            
            // Register item if not in cache
            if (!itemMapping) {
              // Register this as an item
              registerUrlMappings([{
                url: itemUrl,
                type: 'item',
                title: decodeURIComponent(itemUrl.split('/').pop()).replace(/_/g, ' ')
              }]);
            }
          }
          
          // Sort children to put lists first
          sortParentChildren(node.id);
          
          // Force update the estimatedCount to match actual children
          node.estimatedCount = node.children.length;
          
          // Set status back to success
          node.status = 'success';
          
        } else if (pageType === 'item') {
          node.type = 'item';
          node.icon = '';
          node.status = 'success';
          
          
          // Items are leaf nodes - no children to process
        } else if (pageType === 'spell') {
          node.type = 'spell';
          node.icon = '';
          node.status = 'success';
          
          
          // Spells are not items - mark them as such
        }
      } catch (error) {
        console.error('Error analyzing URL:', cleanUrl, {
          error: error,
          message: error.message,
          stack: error.stack,
          nodeId: node.id,
          nodeTitle: node.title,
          nodeType: node.type
        });
        
        // Special logging for Wyrmsbane error
        if (cleanUrl.includes('Wyrmsbane_Lieutenant')) {
          console.error('WYRMSBANE ERROR CAUGHT:', {
            errorType: error.constructor.name,
            errorMessage: error.message,
            errorStack: error.stack,
            nodeStatusBeforeError: node.status,
            nodeTypeBeforeError: node.type,
            nodeTitleBeforeError: node.title
          });
        }
        
        node.type = 'error';
        node.icon = '';
        node.title = decodeURIComponent(cleanUrl.split('/').pop()).replace(/_/g, ' ') + ' (Failed)';
        node.status = 'error';
        node.errorMessage = error.message;
      } finally {
        
        // Ensure node is never left in loading state
        if (node.status === 'loading') {
          console.warn('Node left in loading state after analysis, marking as error:', {
            nodeId: node.id,
            nodeTitle: node.title,
            url: cleanUrl
          });
          node.status = 'error';
          node.type = 'error';
          node.icon = '';
          node.errorMessage = 'Analysis timed out';
        }
        
        // Update Extract button state after node analysis completes
        updateExtractButtonState();
      }
    }
    
    function generateInspectorWarnings() {
      const warningsDiv = document.getElementById('inspector-warnings');
      const hintsDiv = document.getElementById('inspector-hints');
      
      const nodes = Object.values(inspectorTreeData);
      const npcNodes = nodes.filter(n => n.type === 'npc');
      const listNodes = nodes.filter(n => n.type === 'list');
      const spellNodes = nodes.filter(n => n.type === 'spell');
      const errorNodes = nodes.filter(n => n.status === 'error');
      
      const warnings = [];
      
      if (npcNodes.length > 0) {
        const totalLoot = npcNodes.reduce((sum, npc) => sum + npc.children.length, 0);
        warnings.push(`<div style="background: rgba(139, 92, 246, 0.1); border: 1px solid rgba(139, 92, 246, 0.3); padding: 10px 12px; border-radius: 6px; margin-bottom: 8px;">
          <strong style="color: #a78bfa;"> NPCs Detected:</strong> 
          <span style="color: #c4b5fd;">${npcNodes.length} NPC${npcNodes.length > 1 ? 's' : ''} with ${totalLoot} total loot items</span>
        </div>`);
      }
      
      if (listNodes.length > 0) {
        const totalItems = listNodes.reduce((sum, list) => sum + (list.estimatedCount || 0), 0);
        warnings.push(`<div style="background: rgba(245, 158, 11, 0.1); border: 1px solid rgba(245, 158, 11, 0.3); padding: 10px 12px; border-radius: 6px; margin-bottom: 8px;">
          <strong style="color: #fbbf24;"> Lists Detected:</strong> 
          <span style="color: #fde68a;">${listNodes.length} list${listNodes.length > 1 ? 's' : ''} containing ~${totalItems} items</span>
        </div>`);
      }
      
      if (spellNodes.length > 0) {
        warnings.push(`<div style="background: rgba(147, 51, 234, 0.1); border: 1px solid rgba(147, 51, 234, 0.3); padding: 10px 12px; border-radius: 6px; margin-bottom: 8px;">
          <strong style="color: #c084fc;"> Spells/Abilities Detected:</strong> 
          <span style="color: #e9d5ff;">${spellNodes.length} spell${spellNodes.length > 1 ? 's' : ''} excluded from item extraction</span>
        </div>`);
      }
      
      if (errorNodes.length > 0) {
        warnings.push(`<div style="background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.3); padding: 10px 12px; border-radius: 6px; margin-bottom: 8px;">
          <strong style="color: #f87171;"> Errors:</strong> 
          <span style="color: #fca5a5;">${errorNodes.length} URL${errorNodes.length > 1 ? 's' : ''} failed to analyze</span>
        </div>`);
      }
      
      warningsDiv.innerHTML = warnings.join('');
      warningsDiv.style.display = warnings.length > 0 ? 'block' : 'none';
      
      // Hints
      const hints = [];
      if (listNodes.some(n => n.estimatedCount === 0)) {
        hints.push(' Some lists appear empty. Add #list to force list detection.');
      }
      if (errorNodes.length > 0) {
        hints.push(' Some URLs failed to load. Click the Retry button to try again.');
      }
      
      hintsDiv.innerHTML = hints.join('<br>');
    }
    
    async function analyzeUrlsForInspector(urls) {
      // This function is now handled by analyzeUrlsHierarchically
      // Kept for backward compatibility
      return analyzeUrlsHierarchically(urls);
    }
    
    // URL Mappings Functions
    async function checkUrlMappings(urls) {
      try {
        // Debug logging for problem URL
        const wyrmsbanUrl = urls.find(u => u.includes('Wyrmsbane_Lieutenant'));
        if (wyrmsbanUrl) {
        }
        
        const response = await window.csrfHelper.fetchWithCSRF('/api/url-mappings/check-batch', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ urls: urls })
        });
        
        if (response.ok) {
          const mappings = await response.json();
          
          
          // Update cache
          Object.assign(urlMappingsCache, mappings);
          return mappings;
        }
      } catch (error) {
        console.error('Error checking URL mappings:', error);
      }
      return {};
    }
    
    async function updateUrlMapping(url, type, title) {
      try {
        const response = await window.csrfHelper.fetchWithCSRF(`/api/url-mappings/${encodeURIComponent(url)}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ type, title })
        });
        
        if (response.ok) {
          const mapping = await response.json();
          // Update cache
          urlMappingsCache[url] = {
            type: mapping.type,
            title: mapping.title,
            confidence: mapping.confidence
          };
          return mapping;
        }
      } catch (error) {
        console.error('Error updating URL mapping:', error);
      }
      return null;
    }
    
    async function registerUrlMappings(mappings) {
      try {
        const response = await window.csrfHelper.fetchWithCSRF('/api/url-mappings/batch-register', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ mappings })
        });
        
        if (response.ok) {
          return await response.json();
        }
      } catch (error) {
        console.error('Error registering URL mappings:', error);
      }
      return null;
    }
    
    async function loadUrlPatterns() {
      try {
        const response = await fetch('/api/url-mappings/patterns');
        if (response.ok) {
          urlPatterns = await response.json();
        }
      } catch (error) {
        console.error('Error loading URL patterns:', error);
      }
    }
    
    function inferUrlType(url) {
      // Extract page name from URL
      const pageName = url.split('/').pop().replace(/_/g, ' ');
      
      // Check prefixes
      for (const [prefix, types] of Object.entries(urlPatterns.prefixes)) {
        if (pageName.toLowerCase().startsWith(prefix.toLowerCase())) {
          // Find the type with highest count
          const bestType = Object.entries(types).sort((a, b) => b[1] - a[1])[0];
          if (bestType) return bestType[0];
        }
      }
      
      // Check suffixes
      for (const [suffix, types] of Object.entries(urlPatterns.suffixes)) {
        if (pageName.toLowerCase().endsWith(suffix.toLowerCase())) {
          const bestType = Object.entries(types).sort((a, b) => b[1] - a[1])[0];
          if (bestType) return bestType[0];
        }
      }
      
      return null;
    }
    
    // Context menu functions
    let currentContextNode = null;
    let selectedNodes = new Set(); // Track selected nodes
    
    function handleNodeClick(event, nodeId) {
      event.stopPropagation();
      
      // Skip if clicking on expand/collapse toggle
      if (event.target.classList.contains('inspector-tree-expand')) {
        return;
      }
      
      const node = inspectorTreeData[nodeId];
      if (!node) return;
      
      if (event.ctrlKey || event.metaKey) {
        // Multi-select with Ctrl/Cmd
        if (selectedNodes.has(nodeId)) {
          selectedNodes.delete(nodeId);
        } else {
          selectedNodes.add(nodeId);
        }
      } else if (event.shiftKey && selectedNodes.size > 0) {
        // Range select with Shift
        const lastSelected = Array.from(selectedNodes).pop();
        selectRange(lastSelected, nodeId);
      } else {
        // Single select
        selectedNodes.clear();
        selectedNodes.add(nodeId);
      }
      
      // Update visual selection
      renderInspectorTree();
    }
    
    function selectRange(fromId, toId) {
      // Get all visible nodes in order
      const allNodes = [];
      const collectNodes = (nodes) => {
        nodes.forEach(node => {
          allNodes.push(node.id);
          if (node.expanded && node.children) {
            const childNodes = node.children.map(id => inspectorTreeData[id]).filter(n => n);
            collectNodes(childNodes);
          }
        });
      };
      
      const rootNodes = Object.values(inspectorTreeData)
        .filter(node => !node.parent)
        .sort((a, b) => {
          const typeOrder = { 'list': 0, 'npc': 1, 'item': 2, 'unknown': 3, 'loading': 4, 'error': 5 };
          const orderA = typeOrder[a.type] ?? 5;
          const orderB = typeOrder[b.type] ?? 5;
          if (orderA !== orderB) return orderA - orderB;
          return (a.title || '').localeCompare(b.title || '');
        });
      
      collectNodes(rootNodes);
      
      // Find indices
      const fromIndex = allNodes.indexOf(fromId);
      const toIndex = allNodes.indexOf(toId);
      
      if (fromIndex !== -1 && toIndex !== -1) {
        const start = Math.min(fromIndex, toIndex);
        const end = Math.max(fromIndex, toIndex);
        
        for (let i = start; i <= end; i++) {
          selectedNodes.add(allNodes[i]);
        }
      }
    }
    
    function showContextMenu(event, nodeId) {
      event.preventDefault();
      event.stopPropagation();
      
      const node = inspectorTreeData[nodeId];
      if (!node) return;
      
      // If right-clicking on a non-selected node, select only that node
      if (!selectedNodes.has(nodeId)) {
        selectedNodes.clear();
        selectedNodes.add(nodeId);
        renderInspectorTree();
      }
      
      currentContextNode = node;
      const menu = document.getElementById('inspector-context-menu');
      
      // Update menu text to indicate selection
      const menuTitle = menu.querySelector('.context-menu-title');
      if (menuTitle) {
        if (selectedNodes.size > 1) {
          menuTitle.textContent = `${selectedNodes.size} items selected`;
          menuTitle.style.display = 'block';
        } else {
          menuTitle.textContent = node.title || 'Selected item';
          menuTitle.style.display = 'block';
        }
      }
      
      // Position the menu
      menu.style.left = event.pageX + 'px';
      menu.style.top = event.pageY + 'px';
      menu.style.display = 'block';
      
      // Show/hide include option based on whether any selected nodes are excluded
      const includeOption = document.getElementById('include-nodes-option');
      const hasExcludedNodes = Array.from(selectedNodes).some(id => inspectorTreeData[id]?.excluded);
      includeOption.style.display = hasExcludedNodes ? 'block' : 'none';
      
      // Hide menu when clicking elsewhere
      document.addEventListener('click', hideContextMenu);
    }
    
    function hideContextMenu() {
      const menu = document.getElementById('inspector-context-menu');
      menu.style.display = 'none';
      document.removeEventListener('click', hideContextMenu);
    }
    
    function sortParentChildren(parentId) {
      const parent = parentId ? inspectorTreeData[parentId] : null;
      if (!parent || !parent.children || parent.children.length === 0) return;
      
      // First, deduplicate children by URL
      const seenUrls = new Set();
      const uniqueChildren = [];
      
      for (const childId of parent.children) {
        const child = inspectorTreeData[childId];
        if (child && !seenUrls.has(child.url)) {
          seenUrls.add(child.url);
          uniqueChildren.push(childId);
        } else if (child && seenUrls.has(child.url)) {
          // Remove duplicate node from tree data
          delete inspectorTreeData[childId];
        }
      }
      
      // Update parent's children list
      parent.children = uniqueChildren;
      
      // Sort children: lists first, then NPCs, then items, then unknown
      parent.children.sort((a, b) => {
        const nodeA = inspectorTreeData[a];
        const nodeB = inspectorTreeData[b];
        if (!nodeA || !nodeB) return 0;
        
        const typeOrder = { 'list': 0, 'npc': 1, 'item': 2, 'unknown': 3, 'loading': 4, 'error': 5 };
        const orderA = typeOrder[nodeA.type] ?? 5;
        const orderB = typeOrder[nodeB.type] ?? 5;
        
        if (orderA !== orderB) return orderA - orderB;
        
        // If same type, sort by title
        return (nodeA.title || '').localeCompare(nodeB.title || '');
      });
    }
    
    async function changeNodeType(newType) {
      const nodesToUpdate = Array.from(selectedNodes).map(id => inspectorTreeData[id]).filter(n => n);
      if (nodesToUpdate.length === 0) return;
      
      let successCount = 0;
      let needsReAnalyze = [];
      
      for (const node of nodesToUpdate) {
        const oldType = node.type;
        const oldIcon = node.icon;
        const wasError = node.status === 'error';
        
        // Update node immediately for visual feedback
        node.type = newType;
        switch (newType) {
          case 'item':
            node.icon = '';
            break;
          case 'list':
            node.icon = '';
            break;
          case 'npc':
            node.icon = '';
            break;
          default:
            node.icon = '';
        }
        
        // Clear error state if node was in error
        if (wasError) {
          node.status = 'success';
          node.errorMessage = null;
        }
        
        // Update tree display
        updateTreeNode(node.id);
        
        // Update in database - this will cache the manual type setting
        const result = await updateUrlMapping(node.url, newType, node.title);
        
        if (result) {
          successCount++;
          node.fromCache = true;
          node.confidence = result.confidence;
          node.status = 'cached'; // Mark as cached since it's now in the database
          
          // Update the tree node again to show the cached status
          updateTreeNode(node.id);
          
          // If changed to list from item or NPC, mark for re-analysis
          if ((oldType === 'item' || oldType === 'npc') && newType === 'list') {
            needsReAnalyze.push(node);
          }
        } else {
          // Revert on failure
          node.type = oldType;
          node.icon = oldIcon;
          if (wasError) {
            node.status = 'error';
          }
          updateTreeNode(node.id);
        }
      }
      
      // Show success message
      if (successCount > 0) {
        showMessage(`Updated ${successCount} URL${successCount > 1 ? 's' : ''} to ${newType}`, 'success');
      }
      
      // Re-analyze nodes that need it
      if (needsReAnalyze.length > 0) {
        for (const node of needsReAnalyze) {
          node.status = 'loading';
          node.icon = '';
          node.children = [];
          updateTreeNode(node.id);
          
          // Re-analyze as a list
          await analyzeUrlNode(node);
          
          // Re-sort parent's children to put lists first
          if (node.parent) {
            sortParentChildren(node.parent);
          }
        }
        renderInspectorTree();
      }
      
      hideContextMenu();
    }
    
    async function reverifyNode() {
      const nodesToReverify = Array.from(selectedNodes).map(id => inspectorTreeData[id]).filter(n => n);
      if (nodesToReverify.length === 0) return;
      
      hideContextMenu();
      
      // Update all nodes to loading state
      for (const node of nodesToReverify) {
        node.status = 'loading';
        node.icon = '';
        node.title = 'Re-verifying...';
        node.fromCache = false;
        updateTreeNode(node.id);
      }
      
      // Re-analyze all selected nodes
      for (const node of nodesToReverify) {
        await analyzeUrlNode(node);
        
        // Update in database with new type
        if (node.status === 'success') {
          await updateUrlMapping(node.url, node.type, node.title);
        }
      }
      
      renderInspectorTree();
      showMessage(`Re-verified ${nodesToReverify.length} URL${nodesToReverify.length > 1 ? 's' : ''}`, 'info');
    }
    
    function excludeSelectedNodes() {
      const nodesToExclude = Array.from(selectedNodes).map(id => inspectorTreeData[id]).filter(n => n);
      if (nodesToExclude.length === 0) return;
      
      let excludedCount = 0;
      
      // Function to exclude a node and all its children
      function excludeNodeAndChildren(node) {
        if (!node.excluded) {
          node.excluded = true;
          node.originalIcon = node.icon || '';
          node.icon = '';
          excludedCount++;
        }
        
        // Exclude all children recursively
        const children = Object.values(inspectorTreeData).filter(n => n.parent === node.id);
        children.forEach(child => excludeNodeAndChildren(child));
      }
      
      // Exclude selected nodes and their children
      for (const node of nodesToExclude) {
        excludeNodeAndChildren(node);
      }
      
      hideContextMenu();
      renderInspectorTree();
      
      // Set a flag to prevent reinitializing the tree
      window.updatingExclusions = true;
      updateBatchImportCount();
      window.updatingExclusions = false;
      
      showMessage(`Excluded ${excludedCount} item${excludedCount > 1 ? 's' : ''} from import`, 'info');
    }
    
    function includeSelectedNodes() {
      const nodesToInclude = Array.from(selectedNodes).map(id => inspectorTreeData[id]).filter(n => n);
      if (nodesToInclude.length === 0) return;
      
      let includedCount = 0;
      
      // Function to include a node and all its children
      function includeNodeAndChildren(node) {
        if (node.excluded) {
          node.excluded = false;
          node.icon = node.originalIcon || '';
          delete node.originalIcon;
          includedCount++;
        }
        
        // Include all children recursively
        const children = Object.values(inspectorTreeData).filter(n => n.parent === node.id);
        children.forEach(child => includeNodeAndChildren(child));
      }
      
      // Include selected nodes and their children
      for (const node of nodesToInclude) {
        includeNodeAndChildren(node);
      }
      
      hideContextMenu();
      renderInspectorTree();
      
      // Set a flag to prevent reinitializing the tree
      window.updatingExclusions = true;
      updateBatchImportCount();
      window.updatingExclusions = false;
      
      showMessage(`Included ${includedCount} item${includedCount > 1 ? 's' : ''} in import`, 'info');
    }
    
    function excludeAllCachedItems() {
      let excludedCount = 0;
      
      // Function to exclude a node and all its children if cached
      function excludeCachedNodeAndChildren(node) {
        // Check if node is cached (not just the status, but also fromCache flag)
        if ((node.status === 'cached' || node.fromCache) && node.type === 'item' && !node.excluded) {
          node.excluded = true;
          node.originalIcon = node.icon || '';
          node.icon = '';
          excludedCount++;
        }
        
        // Process children recursively
        if (node.children && node.children.length > 0) {
          node.children.forEach(childId => {
            const childNode = inspectorTreeData[childId];
            if (childNode) {
              excludeCachedNodeAndChildren(childNode);
            }
          });
        }
      }
      
      // Process all nodes
      Object.values(inspectorTreeData).forEach(node => {
        excludeCachedNodeAndChildren(node);
      });
      
      if (excludedCount === 0) {
        showMessage('No cached items to exclude', 'info');
        return;
      }
      
      // Set flag to prevent reinitializing the tree
      window.updatingExclusions = true;
      renderInspectorTree();
      updateBatchImportCount();
      window.updatingExclusions = false;
      
      showMessage(`Excluded ${excludedCount} cached item${excludedCount > 1 ? 's' : ''} from import`, 'info');
    }
    
    function inspectSelectedNodes() {
      const nodesToInspect = Array.from(selectedNodes).map(id => inspectorTreeData[id]).filter(n => n && n.url);
      if (nodesToInspect.length === 0) {
        showMessage('No URLs to inspect', 'warning');
        return;
      }
      
      hideContextMenu();
      
      // Limit to 10 tabs to prevent browser overload
      const maxTabs = 10;
      const urlsToOpen = nodesToInspect.slice(0, maxTabs).map(node => node.url);
      
      if (nodesToInspect.length > maxTabs) {
        if (!confirm(`This will open ${maxTabs} tabs (out of ${nodesToInspect.length} selected). Continue?`)) {
          return;
        }
      } else if (nodesToInspect.length > 3) {
        if (!confirm(`This will open ${nodesToInspect.length} tabs. Continue?`)) {
          return;
        }
      }
      
      // Open each URL in a new tab
      urlsToOpen.forEach((url, index) => {
        // Small delay between opening tabs to prevent browser blocking
        setTimeout(() => {
          window.open(url, '_blank');
        }, index * 100);
      });
      
      const message = nodesToInspect.length > maxTabs 
        ? `Opened first ${maxTabs} of ${nodesToInspect.length} URLs`
        : `Opened ${nodesToInspect.length} URL${nodesToInspect.length > 1 ? 's' : ''}`;
      
      showMessage(message, 'info');
    }
    
    function analyzeTableFormat(lines) {
      const formatDetails = document.getElementById('format-details');
      const headers = lines[0].split(/\t|  +/).map(h => h.trim());
      const sampleRow = lines[1] ? lines[1].split(/\t|  +/).map(c => c.trim()) : [];
      
      let html = `<div style="color: #9ca3af; font-size: 0.9rem;">`;
      html += `<div style="margin-bottom: 10px;"><strong>Headers detected:</strong></div>`;
      html += `<div style="background: #111827; padding: 10px; border-radius: 4px; font-family: monospace;">`;
      html += headers.map((h, i) => `<div><span style="color: #60a5fa;">${i + 1}.</span> ${h || '(empty)'}</div>`).join('');
      html += `</div>`;
      
      if (sampleRow.length > 0) {
        html += `<div style="margin-top: 10px; margin-bottom: 5px;"><strong>Sample data:</strong></div>`;
        html += `<div style="background: #111827; padding: 10px; border-radius: 4px; font-family: monospace; font-size: 0.85rem;">`;
        html += sampleRow.map((c, i) => `<div><span style="color: #60a5fa;">${headers[i] || 'Col ' + (i+1)}:</span> ${c || '(empty)'}</div>`).join('');
        html += `</div>`;
      }
      
      html += `</div>`;
      formatDetails.innerHTML = html;
    }
    
    function analyzeSingleItemFormat(lines) {
      const formatDetails = document.getElementById('format-details');
      const properties = {};
      
      lines.forEach(line => {
        const match = line.match(/^([^:]+):\s*(.*)$/);
        if (match) {
          properties[match[1].trim()] = match[2].trim();
        }
      });
      
      let html = `<div style="color: #9ca3af; font-size: 0.9rem;">`;
      html += `<div style="margin-bottom: 10px;"><strong>Properties detected:</strong></div>`;
      html += `<div style="background: #111827; padding: 10px; border-radius: 4px; font-family: monospace;">`;
      
      for (const [key, value] of Object.entries(properties)) {
        html += `<div><span style="color: #60a5fa;">${key}:</span> ${value}</div>`;
      }
      
      html += `</div>`;
      html += `</div>`;
      formatDetails.innerHTML = html;
    }
    
    // Item type and slot detection
    const itemTypePatterns = {
      weapon: /\b(sword|blade|axe|hammer|mace|club|staff|wand|dagger|spear|lance|whip|flail|bow|crossbow|knife|scimitar|katana|rapier|claymore|halberd|pike|javelin|trident|morning\s*star|war\s*hammer|battle\s*axe|great\s*sword|short\s*sword|long\s*sword|scythe|maul)\b/i,
      armor: /\b(armor|armour|mail|plate|chain|leather|robe|tunic|vest|jerkin|breastplate|cuirass|hauberk|gambeson|doublet|surcoat|tabard|brigandine|scale\s*mail|studded|padded|pauldrons?|greaves?|gauntlets?|helm|helmet|boots?|cloak|cape|mantle|girdle|belt|sash)\b/i,
      shield: /shield|buckler|aegis|targe|pavise|kite\s*shield|tower\s*shield|round\s*shield/i,
      accessory: /ring|earring|bracelet|charm|trinket|amulet|pendant|necklace|brooch|pin|badge|medallion|talisman|torc|anklet|circlet|tiara|crown/i,
      consumable: /potion|elixir|food|drink|scroll|tome|book|flask|vial|bottle|draught|brew|tonic|salve|balm|ointment|bread|meat|fruit|wine|ale|mead|water|torch/i,
      container: /bag|sack|pouch|purse|backpack|chest|box|crate|barrel|basket|container|quiver|sheath|scabbard|holster/i,
      tool: /tool|pick|shovel|rope|lantern|compass|map|key|lockpick|kit|supplies|bedroll|tent|flint|tinder/i,
      misc: /gem|stone|crystal|shard|dust|powder|essence|material|component|ore|ingot|bar|coin|piece|fragment|relic|artifact|treasure|wood|resin|scraps?|fiber|thread|yarn|silk|hide|pelt|bone|scale|feather/i
    };
    
    const slotPatterns = {
      'Head': /\b(helm|helmet|hat|cap|crown|circlet|hood|mask|visor)\b/i,
      'Face': /\b(mask|visor|veil|goggles)\b/i,
      'Ears': /\bearring|\bears\b/i,
      'Neck': /\b(necklace|amulet|pendant|collar|choker|neck)\b/i,
      'Shoulders': /\b(shoulder|pauldron|mantle|spaulder)\b/i,
      'Arms': /\b(sleeve|armguard|vambrace)\b|\barms?\b/i,
      'Back': /\b(cloak|cape|mantle|back)\b/i,
      'Wrist1': /\b(bracer|bracelet|wrist|cuff)\b/i,
      'Wrist2': /\b(bracer|bracelet|wrist|cuff)\b/i,
      'Hands': /\b(glove|gauntlet|hand|mitt)\b/i,
      'Primary': /\b(sword|blade|axe|hammer|mace|club|staff|wand|dagger|spear|lance|whip|flail|scythe|maul)\b/i,
      'Secondary': /\b(shield|buckler|orb|tome|offhand)\b/i,
      'Primary/Secondary': /\b(sword|blade|mace|hammer|club|axe|fist|knuckle|claw)\b/i,
      'Range': /\b(bow|crossbow|thrown|range)\b/i,
      'Finger1': /\bring\b|\bband\b|\bfinger\b/i,
      'Finger2': /\bring\b|\bband\b|\bfinger\b/i,
      'Chest': /\b(chest|breastplate|mail|vest|tunic|robe|jerkin|body)\b/i,
      'Legs': /\b(leg|greave|pant|legging|kilt|skirt)\b/i,
      'Feet': /\b(boot|shoe|sandal|foot|feet|sabatons)\b/i,
      'Waist': /\b(belt|girdle|sash|waist|cord)\b/i,
      'Ammo': /\b(arrow|bolt|ammo|quiver)\b/i
    };
    
    function hasFieldConflict(item, fieldName) {
      if (!item.conflicts || !item.hasConflicts) return false;
      return item.conflicts.some(conflict => conflict.field === fieldName);
    }
    
    function getFieldConflict(item, fieldName) {
      if (!item.conflicts) return null;
      return item.conflicts.find(conflict => conflict.field === fieldName);
    }
    
    function createConflictCell(item, fieldName, index) {
      const cell = document.createElement('td');
      if (hasFieldConflict(item, fieldName)) {
        cell.className = 'batch-import-cell has-conflict';
        cell.onclick = () => showConflictModal(item, fieldName, index);
        cell.title = 'Click to resolve conflict';
      } else if (hasDirectData(item, fieldName)) {
        cell.className = 'batch-import-direct';
        cell.title = 'From direct data source';
      } else if (item.inferredFields && item.inferredFields.includes(fieldName)) {
        cell.className = 'batch-import-inferred';
        cell.title = 'Auto-detected from item name';
      }
      return cell;
    }
    
    function showConflictModal(item, fieldName, itemIndex) {
      const conflict = getFieldConflict(item, fieldName);
      if (!conflict) return;
      
      // Create modal
      const modal = document.createElement('div');
      modal.className = 'merge-conflict-modal';
      modal.onclick = (e) => {
        if (e.target === modal) {
          modal.remove();
        }
      };
      
      const content = document.createElement('div');
      content.className = 'merge-conflict-content';
      
      // Header
      const header = document.createElement('div');
      header.className = 'merge-conflict-header';
      header.innerHTML = `
        <h3>Resolve Conflict: ${getFieldDisplayName(fieldName)}</h3>
        <button class="merge-conflict-close" onclick="this.closest('.merge-conflict-modal').remove()"></button>
      `;
      content.appendChild(header);
      
      // Body
      const body = document.createElement('div');
      body.className = 'merge-conflict-body';
      
      const fieldNameDiv = document.createElement('div');
      fieldNameDiv.className = 'conflict-field-name';
      fieldNameDiv.textContent = `${item.name} - ${getFieldDisplayName(fieldName)}`;
      body.appendChild(fieldNameDiv);
      
      const valuesDiv = document.createElement('div');
      valuesDiv.className = 'conflict-values';
      
      // Existing value option
      const existingOption = document.createElement('div');
      existingOption.className = 'conflict-value-option';
      existingOption.innerHTML = `
        <div class="conflict-value-label">Current Database Value</div>
        <div class="conflict-value-content">${formatFieldValue(conflict.existingValue, fieldName)}</div>
      `;
      existingOption.onclick = () => {
        document.querySelectorAll('.conflict-value-option').forEach(opt => opt.classList.remove('selected'));
        existingOption.classList.add('selected');
      };
      valuesDiv.appendChild(existingOption);
      
      // New value option
      const newOption = document.createElement('div');
      newOption.className = 'conflict-value-option selected';
      newOption.innerHTML = `
        <div class="conflict-value-label">New Import Value</div>
        <div class="conflict-value-content">${formatFieldValue(conflict.newValue, fieldName)}</div>
      `;
      newOption.onclick = () => {
        document.querySelectorAll('.conflict-value-option').forEach(opt => opt.classList.remove('selected'));
        newOption.classList.add('selected');
      };
      valuesDiv.appendChild(newOption);
      
      body.appendChild(valuesDiv);
      content.appendChild(body);
      
      // Footer
      const footer = document.createElement('div');
      footer.className = 'merge-conflict-footer';
      footer.innerHTML = `
        <button class="btn secondary-btn" onclick="this.closest('.merge-conflict-modal').remove()">Cancel</button>
        <button class="btn primary-btn" onclick="resolveConflict(${itemIndex}, '${fieldName}', this)">Apply</button>
      `;
      content.appendChild(footer);
      
      modal.appendChild(content);
      document.body.appendChild(modal);
    }
    
    function getFieldDisplayName(fieldName) {
      const fieldNames = {
        'item_type': 'Item Type',
        'slot': 'Equipment Slot',
        'size': 'Size',
        'weight': 'Weight',
        'str': 'STR',
        'sta': 'STA',
        'agi': 'AGI',
        'dex': 'DEX',
        'wis': 'WIS',
        'int': 'INT',
        'cha': 'CHA',
        'ac': 'AC',
        'health': 'Health',
        'mana': 'Mana',
        'attack_speed': 'Attack Speed',
        'damage': 'Damage',
        'delay': 'Delay',
        'resist_cold': 'Cold Resist',
        'resist_corruption': 'Corruption Resist',
        'resist_disease': 'Disease Resist',
        'resist_electricity': 'Electricity Resist',
        'resist_fire': 'Fire Resist',
        'resist_magic': 'Magic Resist',
        'resist_poison': 'Poison Resist',
        'race': 'Race',
        'class': 'Class',
        'skill': 'Skill',
        'description': 'Description'
      };
      return fieldNames[fieldName] || fieldName;
    }
    
    function formatFieldValue(value, fieldName) {
      if (value === null || value === undefined || value === '') {
        return '<em>Empty</em>';
      }
      if (fieldName === 'weight') {
        const numValue = parseFloat(value);
        if (!isNaN(numValue)) {
          return `${numValue.toFixed(1)} (${typeof value})`;
        }
        return `${value} (${typeof value})`;
      }
      // For strings, show quotes to make whitespace visible
      if (typeof value === 'string' && value !== value.trim()) {
        return `"${value}"`;
      }
      return value;
    }
    
    function resolveConflict(itemIndex, fieldName, button) {
      const modal = button.closest('.merge-conflict-modal');
      const selectedOption = modal.querySelector('.conflict-value-option.selected');
      const isExistingValue = selectedOption.querySelector('.conflict-value-label').textContent.includes('Current Database');
      
      const item = batchImportItems[itemIndex];
      const conflict = getFieldConflict(item, fieldName);
      
      if (isExistingValue) {
        // Use existing database value
        item[fieldName] = conflict.existingValue;
      }
      // Otherwise keep the new value (which is already set)
      
      // Remove this conflict from the item's conflicts array
      item.conflicts = item.conflicts.filter(c => c.field !== fieldName);
      if (item.conflicts.length === 0) {
        item.hasConflicts = false;
      }
      
      // Close modal and refresh table
      modal.remove();
      renderBatchImportTable();
    }
    
    
    function detectConflicts(newItem, existingItem) {
      const conflicts = [];
      const fieldsToCheck = [
        'item_type', 'slot', 'size', 'weight',
        'str', 'sta', 'agi', 'dex', 'wis', 'int', 'cha',
        'ac', 'health', 'mana', 'attack_speed', 'damage', 'delay',
        'resist_cold', 'resist_corruption', 'resist_disease', 
        'resist_electricity', 'resist_fire', 'resist_magic', 'resist_poison',
        'race', 'class', 'skill', 'description'
      ];
      
      fieldsToCheck.forEach(field => {
        // Skip if new value is default/empty
        if (field === 'description' || field === 'skill' || field === 'race' || field === 'class') {
          if (!newItem[field] || newItem[field] === '' || newItem[field] === 'ALL') {
            return;
          }
        } else if (typeof newItem[field] === 'number' && newItem[field] === 0) {
          return;
        }
        
        // Compare values - normalize for comparison
        let newVal = newItem[field];
        let existingVal = existingItem[field];
        
        // Special handling for numeric fields like weight
        if (field === 'weight' || typeof newVal === 'number' || typeof existingVal === 'number') {
          // Convert both to numbers for comparison
          const newNum = parseFloat(newVal);
          const existingNum = parseFloat(existingVal);
          
          // If both are valid numbers, compare as numbers
          if (!isNaN(newNum) && !isNaN(existingNum)) {
            // Consider them equal if they're the same when rounded to 1 decimal
            if (Math.round(newNum * 10) === Math.round(existingNum * 10)) {
              return; // No conflict
            }
          }
          // If one is NaN and the other is 0, consider them equal
          else if ((isNaN(newNum) && existingNum === 0) || (newNum === 0 && isNaN(existingNum))) {
            return; // No conflict
          }
        }
        
        // Normalize string values for comparison
        if (typeof newVal === 'string') {
          newVal = newVal.trim().replace(/\s+/g, ' '); // Trim and normalize whitespace
        }
        if (typeof existingVal === 'string') {
          existingVal = existingVal.trim().replace(/\s+/g, ' '); // Trim and normalize whitespace
        }
        
        // Convert null/undefined to empty string for comparison
        if (newVal == null) newVal = '';
        if (existingVal == null) existingVal = '';
        
        // Only flag as conflict if values are actually different after normalization
        if (newVal !== existingVal) {
          conflicts.push({
            field: field,
            newValue: newItem[field], // Keep original value
            existingValue: existingItem[field] // Keep original value
          });
        }
      });
      
      return conflicts;
    }
    
    function detectItemType(name, providedSlot = null, itemStats = null) {
      // Data-driven detection based on item stats
      if (itemStats) {
        // If it has damage AND delay, it's definitely a weapon
        if (itemStats.damage > 0 && itemStats.delay > 0) {
          return 'weapon';
        }
        
        // If it has AC, it's almost certainly armor or shield
        if (itemStats.ac > 0) {
          // Check if it's a shield by name or slot
          if (itemTypePatterns.shield.test(name) || providedSlot === 'Secondary') {
            return 'shield';
          }
          return 'armor';
        }
        
        // If it has stats but no damage/delay/AC, check other patterns
        const hasStats = itemStats.str > 0 || itemStats.sta > 0 || itemStats.agi > 0 || 
                        itemStats.dex > 0 || itemStats.wis > 0 || itemStats.int > 0 || 
                        itemStats.cha > 0 || itemStats.health > 0 || itemStats.mana > 0;
        
        if (hasStats) {
          // Has stats but no damage/AC - could be armor, accessory, or special item
          // Use slot to help determine
          if (providedSlot && providedSlot !== 'None') {
            const slotLower = providedSlot.toLowerCase();
            const slotBase = slotLower.replace(/[0-9]+$/, '');
            
            // Accessory slots
            if (['finger', 'ears', 'ear', 'ring'].includes(slotBase)) {
              return 'accessory';
            }
            
            // Armor slots
            const armorSlots = ['head', 'face', 'neck', 'shoulders', 'shoulder', 'arms', 'arm', 'back', 
                               'wrist', 'wrists', 'bracers', 'hands', 'hand', 'gloves', 
                               'chest', 'body', 'torso', 'legs', 'leg', 'pants', 
                               'feet', 'foot', 'boots', 'shoes', 'waist', 'belt'];
            if (armorSlots.includes(slotBase)) {
              return 'armor';
            }
          }
        }
      }
      
      // If no stats provided or no definitive stats, fall back to name/slot patterns
      
      // Check for consumables first (torch, potions, etc)
      if (itemTypePatterns.consumable.test(name)) {
        return 'consumable';
      }
      
      // Check for containers
      if (itemTypePatterns.container.test(name)) {
        return 'container';
      }
      
      // Check for misc/crafting materials
      if (itemTypePatterns.misc.test(name)) {
        return 'misc';
      }
      
      // Check for tools
      if (itemTypePatterns.tool.test(name)) {
        return 'tool';
      }
      
      // If a slot is provided, use it to help determine the item type
      if (providedSlot && providedSlot !== 'None') {
        const slotLower = providedSlot.toLowerCase();
        const slotBase = slotLower.replace(/[0-9]+$/, '');
        
        // Accessory slots
        if (['finger', 'ears', 'ear', 'ring'].includes(slotBase)) {
          return 'accessory';
        }
        
        // Container slots
        if (slotBase === 'container') {
          return 'container';
        }
        
        // Armor slots
        const armorSlots = ['head', 'face', 'neck', 'shoulders', 'shoulder', 'arms', 'arm', 'back', 
                           'wrist', 'wrists', 'bracers', 'hands', 'hand', 'gloves', 
                           'chest', 'body', 'torso', 'legs', 'leg', 'pants', 
                           'feet', 'foot', 'boots', 'shoes', 'waist', 'belt'];
        if (armorSlots.includes(slotBase)) {
          return 'armor';
        }
        
        // Weapon slots - but only if name suggests it
        if (slotLower === 'primary' || slotLower === 'range' || slotLower === 'ranged' || 
            slotLower === 'primary/secondary') {
          if (itemTypePatterns.weapon.test(name)) {
            return 'weapon';
          }
        }
      }
      
      // Check patterns in order of specificity
      if (itemTypePatterns.weapon.test(name)) {
        return 'weapon';
      }
      if (itemTypePatterns.armor.test(name)) {
        return 'armor';
      }
      if (itemTypePatterns.shield.test(name)) {
        return 'shield';
      }
      if (itemTypePatterns.accessory.test(name)) {
        return 'accessory';
      }
      
      // Default to misc if nothing else matches
      return 'misc';
    }
    
    function detectWeaponSlot(name) {
      const nameLower = name.toLowerCase();
      
      // Off-hand weapons  Secondary only
      if (/dagger|knife|stiletto|dirk|kris|shiv|off[\s-]?hand/i.test(nameLower)) {
        return 'Secondary';
      }
      
      // Ranged weapons  Range slot  
      if (/bow|longbow|shortbow|crossbow|arbalest/i.test(nameLower)) {
        return 'Range';
      }
      
      // 2H weapons  Primary only
      if (/great|two[\s-]?hand|2h|claymore|zweihander|war\s*hammer|maul/i.test(nameLower)) {
        return 'Primary';
      }
      
      if (/scythe|spear|lance|pike|halberd|polearm|glaive|trident|javelin/i.test(nameLower)) {
        return 'Primary';
      }
      
      // Larger 1H weapons  Primary only
      if (/bastard\s*sword|hand\s*and\s*half|longsword|long\s*sword/i.test(nameLower)) {
        return 'Primary';
      }
      
      if (/battle\s*axe|war\s*axe|broad\s*axe/i.test(nameLower)) {
        return 'Primary';
      }
      
      if (/war\s*hammer|heavy\s*hammer|large\s*mace|heavy\s*mace/i.test(nameLower)) {
        return 'Primary';
      }
      
      // Staff/wand weapons are typically Primary only (magical focus items)
      if (/staff|wand|rod|scepter|orb/i.test(nameLower)) {
        return 'Primary';
      }
      
      // Smaller 1H weapons  Pri/Sec (can be used in either hand)
      if (/sword|blade|scimitar|katana|rapier|cutlass|sabre|falchion|short\s*sword/i.test(nameLower)) {
        // Check if it's explicitly 2H or large
        if (!/great|two[\s-]?hand|2h|claymore|zweihander|bastard|longsword|long\s*sword/i.test(nameLower)) {
          return 'Primary/Secondary';
        }
      }
      
      if (/mace|hammer|club|morning\s*star|flail/i.test(nameLower)) {
        // Check if it's explicitly 2H or large
        if (!/great|two[\s-]?hand|2h|war\s*hammer|maul|heavy|large|battle/i.test(nameLower)) {
          return 'Primary/Secondary';
        }
      }
      
      if (/axe|hatchet|hand\s*axe/i.test(nameLower)) {
        // Check if it's explicitly 2H or large
        if (!/great|two[\s-]?hand|2h|battle\s*axe|war\s*axe|broad\s*axe/i.test(nameLower)) {
          return 'Primary/Secondary';
        }
      }
      
      if (/fist|knuckle|claw|gauntlet|cestus|brass\s*knuckle/i.test(nameLower)) {
        return 'Primary/Secondary';
      }
      
      // Default to Primary for unknown weapons
      return 'Primary';
    }

    function detectSlot(name, itemType) {
      // This function is no longer used for general slot detection
      // Slots should be parsed from the item page data
      // Only kept for backward compatibility
      return '';
    }
    
    function getDefaultIcon(itemType, slot) {
      // Weapons
      if (itemType === 'weapon') {
        return { type: 'emoji', value: '' };
      }
      // Armor and shields
      if (itemType === 'armor' || itemType === 'shield' || slot === 'Secondary') {
        return { type: 'emoji', value: '' };
      }
      // Accessories (excluding Neck which is now armor)
      if (itemType === 'accessory' || ['Finger1', 'Finger2', 'Ears'].includes(slot)) {
        return { type: 'emoji', value: '' };
      }
      // Consumables
      if (itemType === 'consumable') {
        return { type: 'emoji', value: '' };
      }
      // Misc items (crafting materials, etc.)
      if (itemType === 'misc') {
        return { type: 'emoji', value: '' };
      }
      // Default
      return { type: 'emoji', value: '' };
    }
    
    function inferWeaponSkill(itemName, itemType) {
      // Only infer skill for weapons
      if (itemType !== 'weapon') return null;
      
      const nameLower = itemName.toLowerCase();
      
      // Database constraint allows: 'Archery', 'Slashing', 'Bludgeoning', 'Piercing', 'Throwing', 'Brass', 'Percussion', 'Stringed', 'Wind', 'Singing'
      
      // Slashing weapons (both 1H and 2H use same skill)
      if (/sword|blade|scimitar|katana|rapier|cutlass|sabre|falchion|scythe|axe|hatchet|battleaxe|battle\s*axe/i.test(nameLower)) {
        return 'Slashing';
      }
      
      // Bludgeoning weapons (both 1H and 2H use same skill)
      if (/mace|hammer|club|maul|morning\s*star|flail/i.test(nameLower)) {
        return 'Bludgeoning';
      }
      
      // Piercing weapons (includes daggers and spears)
      if (/dagger|knife|stiletto|dirk|kris|shiv|spear|lance|pike|halberd|polearm|glaive|trident|javelin/i.test(nameLower)) {
        return 'Piercing';
      }
      
      // Archery
      if (/bow|longbow|shortbow|crossbow|arbalest/i.test(nameLower)) {
        return 'Archery';
      }
      
      // Throwing weapons
      if (/throwing|thrown|shuriken|dart|throwing\s*(axe|knife|dagger)/i.test(nameLower)) {
        return 'Throwing';
      }
      
      // Hand to Hand weapons -> no direct equivalent in constraint, return null
      if (/fist|knuckle|claw|gauntlet|cestus|brass\s*knuckle/i.test(nameLower)) {
        return null; // No valid skill for hand-to-hand in database constraint
      }
      
      // Caster weapons (staves, wands) -> no skill requirement
      if (/staff|rod|wand|scepter|cane/i.test(nameLower)) {
        return null; // Caster weapons typically don't have a skill requirement
      }
      
      // Default for unrecognized weapons
      return null;
    }
    
    function parseTableData(lines) {
      if (lines.length < 2) {
        // If less than 2 lines, treat as simple list
        return lines.map((line, index) => {
          const item = createDefaultItem(line.trim(), index);
          // Already inferred, no need to do anything else
          return item;
        });
      }
      
      // Parse the header row to identify columns
      const headerLine = lines[0].toLowerCase();
      const headers = headerLine.split(/\t+|\s{2,}/).map(h => h.trim());
      
      // Map headers to field names
      const fieldMap = {
        'name': 'name',
        'item': 'name',
        'item name': 'name',
        'type': 'item_type',
        'item type': 'item_type',
        'slot': 'slot',
        'armor slot': 'slot',
        'equipment slot': 'slot',
        'size': 'size',
        'weight': 'weight',
        'wt': 'weight',
        'str': 'str',
        'strength': 'str',
        'sta': 'sta',
        'stamina': 'sta',
        'agi': 'agi',
        'agility': 'agi',
        'dex': 'dex',
        'dexterity': 'dex',
        'wis': 'wis',
        'wisdom': 'wis',
        'int': 'int',
        'intelligence': 'int',
        'cha': 'cha',
        'charisma': 'cha',
        'ac': 'ac',
        'armor class': 'ac',
        'block': 'block',
        'blk': 'block',
        'hp': 'health',
        'health': 'health',
        'mp': 'mana',
        'mana': 'mana',
        'attack speed': 'attack_speed',
        'as': 'attack_speed',
        'dmg': 'damage',
        'damage': 'damage',
        'delay': 'delay',
        'dly': 'delay',
        'race': 'race',
        'races': 'race',
        'class': 'class',
        'classes': 'class',
        'skill': 'skill',
        'description': 'description',
        'desc': 'description',
        'stats': 'stats',  // Special field for combined stats
        // Resistance fields
        'cold': 'resist_cold',
        'cold resist': 'resist_cold',
        'cr': 'resist_cold',
        'corruption': 'resist_corruption',
        'corruption resist': 'resist_corruption',
        'disease': 'resist_disease',
        'disease resist': 'resist_disease',
        'dr': 'resist_disease',
        'electricity': 'resist_electricity',
        'electric': 'resist_electricity',
        'er': 'resist_electricity',
        'fire': 'resist_fire',
        'fire resist': 'resist_fire',
        'fr': 'resist_fire',
        'magic': 'resist_magic',
        'magic resist': 'resist_magic',
        'mr': 'resist_magic',
        'poison': 'resist_poison',
        'poison resist': 'resist_poison',
        'pr': 'resist_poison'
      };
      
      // Create column mapping
      const columnMapping = [];
      headers.forEach((header, index) => {
        const field = fieldMap[header];
        if (field) {
          columnMapping[index] = field;
        }
      });
      
      // If no name column found, treat as simple list
      const nameIndex = headers.findIndex(h => fieldMap[h] === 'name');
      if (nameIndex === -1) {
        return lines.map((line, index) => {
          const item = createDefaultItem(line.trim(), index);
          // Already inferred, no need to do anything else
          return item;
        });
      }
      
      // Parse data rows
      const items = [];
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i];
        if (!line.trim()) continue;
        
        const values = line.split(/\t+|\s{2,}/).map(v => v.trim());
        // Create a basic item without inference
        const item = {
          tempId: `batch_${items.length}`,
          name: '',
          item_type: null,
          slot: null,
          slots: [],
          icon_type: 'emoji',
          icon_value: '',
          size: 'Medium',
          weight: 0,
          str: 0,
          sta: 0,
          agi: 0,
          dex: 0,
          wis: 0,
          int: 0,
          cha: 0,
          ac: 0,
          block: 0,
          health: 0,
          mana: 0,
          attack_speed: 0,
          damage: 0,
          delay: 0,
          resist_cold: 0,
          resist_corruption: 0,
          resist_disease: 0,
          resist_electricity: 0,
          resist_fire: 0,
          resist_magic: 0,
          resist_poison: 0,
          skill: null,
          race: null,
          class: null,
          description: '',
          isDuplicate: false,
          errors: [],
          inferredFields: [],
          dataSource: 'table', // Mark that this has direct data source
          parsedFields: [] // Track which fields were parsed from table
        };
        
        // Apply values based on column mapping
        columnMapping.forEach((field, index) => {
          if (field && values[index] !== undefined) {
            const value = values[index];
            
            // Handle different field types
            if (field === 'name') {
              item.name = value;
            } else if (field === 'item_type') {
              // Only set item_type if it's a valid value
              const cleanValue = value.trim().toLowerCase();
              if (cleanValue && cleanValue !== '-' && cleanValue !== 'n/a') {
                item.item_type = cleanValue;
                item.parsedFields.push('item_type');
              }
            } else if (field === 'slot') {
              // Map common slot variations
              const slotMap = {
                'head': 'Head',
                'face': 'Face', 
                'neck': 'Neck',
                'shoulders': 'Shoulders',
                'shoulder': 'Shoulders',
                'back': 'Back',
                'chest': 'Chest',
                'body': 'Chest',
                'torso': 'Chest',
                'wrist': 'Wrist1',
                'wrists': 'Wrist1',
                'bracers': 'Wrist1',
                'legs': 'Legs',
                'leg': 'Legs',
                'pants': 'Legs',
                'waist': 'Waist',
                'belt': 'Waist',
                'hands': 'Hands',
                'hand': 'Hands',
                'gloves': 'Hands',
                'feet': 'Feet',
                'foot': 'Feet',
                'boots': 'Feet',
                'shoes': 'Feet',
                'primary': 'Primary',
                'main': 'Primary',
                'mainhand': 'Primary',
                'main hand': 'Primary',
                'secondary': 'Secondary',
                'offhand': 'Secondary',
                'off hand': 'Secondary',
                'shield': 'Secondary',
                'primary/secondary': 'Primary/Secondary',
                'main/off': 'Primary/Secondary',
                'main/offhand': 'Primary/Secondary',
                'both': 'Primary/Secondary',
                'finger': 'Finger1',
                'ring': 'Finger1',
                'finger1': 'Finger1',
                'finger2': 'Finger2',
                'ears': 'Ears',
                'ear': 'Ears',
                'earring': 'Ears',
                'ranged': 'Ranged',
                'range': 'Ranged',
                'ammo': 'Ammo',
                'container': 'Container',
                'bag': 'Container'
              };
              const normalizedSlot = value.toLowerCase().trim();
              item.slot = slotMap[normalizedSlot] || value;
              // Handle Primary/Secondary combo slot
              if (item.slot === 'Primary/Secondary') {
                item.slots = ['Primary', 'Secondary'];
              } else {
                item.slots = item.slot ? [item.slot] : [];
              }
              if (value && value.trim() && value !== '-') {
                item.parsedFields.push('slot');
              }
            } else if (field === 'size') {
              item.size = value.charAt(0).toUpperCase() + value.slice(1).toLowerCase();
              item.parsedFields.push('size');
            } else if (field === 'weight' || field === 'attack_speed') {
              item[field] = parseFloat(value) || 0;
              if (item[field] !== 0) item.parsedFields.push(field);
            } else if (field === 'race') {
              item[field] = normalizeRaceClassString(value, 'race');
              if (value && value.trim() && value !== '-') {
                item.parsedFields.push('race');
              }
            } else if (field === 'class') {
              item[field] = normalizeRaceClassString(value, 'class');
              if (value && value.trim() && value !== '-') {
                item.parsedFields.push('class');
              }
            } else if (field === 'skill') {
              // Map skill abbreviations to database values
              const skillMap = {
                'SLA': 'Slashing',
                '2HS': 'Slashing',
                '1HS': 'Slashing',
                '1HB': 'Bludgeoning',
                '2HB': 'Bludgeoning',
                'BLD': 'Bludgeoning',
                'BLG': 'Bludgeoning',
                'BLU': 'Bludgeoning',
                'PIE': 'Piercing',
                'STA': 'Piercing',  // STA = Piercing (for now)
                '2HP': 'Piercing',
                '1HP': 'Piercing',
                'ARC': 'Archery',
                'H2H': null, // No valid equivalent in database constraint
                'THR': 'Throwing'
              };
              const upperValue = value ? value.toUpperCase().trim() : '';
              const mappedSkill = skillMap[upperValue];
              if (mappedSkill !== undefined) {
                item.skill = mappedSkill;
                if (mappedSkill !== null) item.parsedFields.push('skill');
              } else if (value && value.trim()) {
                // Check if it's already a valid skill name
                const validSkills = ['Archery', 'Slashing', 'Bludgeoning', 'Piercing', 'Throwing', 
                                   'Brass', 'Percussion', 'Stringed', 'Wind', 'Singing'];
                const capitalizedValue = value.charAt(0).toUpperCase() + value.slice(1).toLowerCase();
                if (validSkills.includes(capitalizedValue)) {
                  item.skill = capitalizedValue;
                } else {
                  item.skill = value; // Keep original value if not recognized
                }
                item.parsedFields.push('skill');
              } else {
                item.skill = null;
              }
            } else if (field === 'description') {
              item[field] = value || null;
            } else if (field === 'stats') {
              // Special handling for combined stats field - ignore for now
              // Could parse this in the future for multi-stat items
            } else {
              // Numeric fields (stats, resistances, etc.)
              // Treat "-" as 0
              if (value === '-' || value === '') {
                item[field] = 0;
              } else {
                item[field] = parseInt(value) || 0;
                if (item[field] !== 0) item.parsedFields.push(field);
              }
            }
          }
        });
        
        // Now infer any missing fields
        inferItemFields(item);
        
        items.push(item);
      }
      
      return items;
    }
    
    async function processUrlsAsItems(urls) {
      
      // Process item URLs with rate limiting and real-time tree updates
      const textarea = document.getElementById('batch-import-textarea');
      const processBtn = document.getElementById('batch-import-process-btn');
      
      // Show processing status
      showMessage(`Processing ${urls.length} item URLs...`, 'info');
      
      // Create progress display
      const progressDiv = document.createElement('div');
      progressDiv.style.cssText = 'margin-top: 10px; padding: 10px; background: rgba(96, 165, 250, 0.1); border: 1px solid rgba(96, 165, 250, 0.3); border-radius: 4px; color: #e0e0e0;';
      progressDiv.innerHTML = `<strong>Extracting Items:</strong> 0 / ${urls.length}`;
      
      // Insert progress after the Extract Loot button
      const extractBtn = document.querySelector('button[onclick*="extractFromInspector"]');
      if (extractBtn && extractBtn.parentNode) {
        extractBtn.parentNode.appendChild(progressDiv);
        
        // Disable the Extract Loot button during extraction
        extractBtn.disabled = true;
        extractBtn.style.opacity = '0.5';
        const extractBtnText = extractBtn.querySelector('#inspector-extract-btn-text');
        const extractBtnIcon = extractBtn.querySelector('span:first-child');
        if (extractBtnText) extractBtnText.textContent = 'Extracting...';
        if (extractBtnIcon) extractBtnIcon.textContent = '';
      }
      
      // Fetch item data from URLs with rate limiting
      const fetchedItems = [];
      let successCount = 0;
      let errorCount = 0;
      
      // Keep step1 visible with data inspector during extraction
      // Step2 remains hidden until extraction is complete
      const step1 = document.getElementById('batch-import-step1');
      const step2 = document.getElementById('batch-import-items-step2');
      if (step1) step1.style.display = 'block';
      if (step2) step2.style.display = 'none';
      
      // Set a flag to prevent the data inspector from being cleared during extraction
      window.isExtractingItems = true;
      // Clear the completion flag as we're starting a new extraction
      window.extractionCompleted = false;
      
      // Disable the textarea
      if (textarea) {
        textarea.disabled = true;
        textarea.style.opacity = '0.5';
      }
      
      // Process in batches to avoid overwhelming the server
      const BATCH_SIZE = 5;
      const DELAY_BETWEEN_ITEMS = 500; // 500ms between items
      const DELAY_BETWEEN_BATCHES = 2000; // 2s between batches
      
      for (let i = 0; i < urls.length; i += BATCH_SIZE) {
        const batch = urls.slice(i, i + BATCH_SIZE);
        const batchPromises = [];
        
        for (let j = 0; j < batch.length; j++) {
          const url = batch[j];
          const index = i + j;
          
          // Add delay between items in the same batch
          if (j > 0) {
            await new Promise(resolve => setTimeout(resolve, DELAY_BETWEEN_ITEMS));
          }
          
          // Update progress with item counts
          const totalProcessed = successCount + errorCount;
          progressDiv.innerHTML = `<strong>Extracting Items:</strong> ${totalProcessed} / ${urls.length} <span style="color: #10b981;">(${successCount} success)</span> <span style="color: #ef4444;">(${errorCount} failed)</span>`;
          
          // Find the corresponding node in the tree
          const treeNode = Object.values(inspectorTreeData).find(node => node.url === url);
          
          try {
            // Try primary proxy first
            let proxyUrl = 'https://api.allorigins.win/get?url=' + encodeURIComponent(url);
            let response = await fetch(proxyUrl, { 
              method: 'GET',
              mode: 'cors',
              cache: 'no-cache',
              signal: AbortSignal.timeout(10000) // 10s timeout
            });
            
            let pageContent = null;
            
            if (response.ok) {
              const data = await response.json();
              pageContent = data.contents;
            } else {
              // Try fallback proxy
              proxyUrl = 'https://corsproxy.io/?' + encodeURIComponent(url);
              response = await fetch(proxyUrl, {
                method: 'GET',
                mode: 'cors',
                cache: 'no-cache',
                signal: AbortSignal.timeout(10000)
              });
              
              if (response.ok) {
                pageContent = await response.text();
              }
            }
            
            if (pageContent) {
              // Debug logging for Wyrmsbane
              if (url.includes('Wyrmsbane_Lieutenant')) {
              }
              
              const itemData = parseWikiItemData(pageContent, url);
              
              // Debug logging for Wyrmsbane
              if (url.includes('Wyrmsbane_Lieutenant')) {
              }
              
              if (itemData) {
                // Add URL to description field
                itemData.description = url;
                
                fetchedItems.push(itemData);
                successCount++;
                
                // Update tree node to show success
                if (treeNode) {
                  treeNode.icon = '';
                  treeNode.status = 'extracted';
                  treeNode.title = itemData.name; // Update title with parsed name
                  updateTreeNode(treeNode.id);
                  
                  // Check if parent list/NPC has all children extracted
                  updateParentNodeStatus(treeNode);
                }
                
                // Add item to batch import items in real-time
                // Ensure item has a unique tempId
                if (!itemData.tempId) {
                  itemData.tempId = `batch_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                }
                
                // Transfer excluded status from tree node
                if (treeNode && treeNode.excluded) {
                  itemData.excluded = true;
                }
                
                batchImportItems.push(itemData);
                
                // Update the table to show the new item
                renderBatchImportTable();
                updateBatchImportCount();
                updateBatchImportStatus();
              } else {
                errorCount++;
                
                // Update tree node to show error
                if (treeNode) {
                  treeNode.icon = '';
                  treeNode.status = 'error';
                  treeNode.errorMessage = 'Failed to parse item data';
                  updateTreeNode(treeNode.id);
                  updateRetryAllButton();
              updateAddToNPCButton();
                updateAddToNPCButton();
                  updateAddToNPCButton();
        updateAddToNPCButton();
          updateAddToNPCButton();
            updateAddToNPCButton();
                  
                  // Check if parent list/NPC has all children processed
                  updateParentNodeStatus(treeNode);
                }
              }
            } else {
              errorCount++;
              
              // Update tree node to show error
              if (treeNode) {
                treeNode.icon = '';
                treeNode.status = 'error';
                treeNode.errorMessage = 'Failed to fetch page';
                updateTreeNode(treeNode.id);
                updateRetryAllButton();
              updateAddToNPCButton();
                updateAddToNPCButton();
        updateAddToNPCButton();
          updateAddToNPCButton();
            updateAddToNPCButton();
                
                // Check if parent list/NPC has all children processed
                updateParentNodeStatus(treeNode);
              }
            }
          } catch (error) {
            console.error('Error fetching URL:', url, error);
            errorCount++;
            
            // Update tree node to show error
            if (treeNode) {
              treeNode.icon = '';
              treeNode.status = 'error';
              treeNode.errorMessage = error.message || 'Network error';
              updateTreeNode(treeNode.id);
              updateRetryAllButton();
              updateAddToNPCButton();
        updateAddToNPCButton();
          updateAddToNPCButton();
            updateAddToNPCButton();
              
              // Check if parent list/NPC has all children processed
              updateParentNodeStatus(treeNode);
            }
          }
        }
        
        // Add delay between batches
        if (i + BATCH_SIZE < urls.length) {
          progressDiv.innerHTML += ' <em style="color: #f59e0b;">- Waiting to avoid rate limits...</em>';
          await new Promise(resolve => setTimeout(resolve, DELAY_BETWEEN_BATCHES));
        }
      }
      
      // Remove progress display
      if (progressDiv.parentNode) {
        progressDiv.remove();
      }
      
      // Re-enable textarea
      if (textarea) {
        textarea.disabled = false;
        textarea.style.opacity = '1';
      }
      
      // Re-enable the Extract Loot button
      if (extractBtn) {
        extractBtn.disabled = false;
        extractBtn.style.opacity = '1';
        const extractBtnText = extractBtn.querySelector('#inspector-extract-btn-text');
        const extractBtnIcon = extractBtn.querySelector('span:first-child');
        if (extractBtnText) extractBtnText.textContent = 'Extract Loot';
        if (extractBtnIcon) extractBtnIcon.textContent = '';
      }
      
      // Clear the extraction flag
      window.isExtractingItems = false;
      
      // Only show "Proceed to Step 2" button if we actually extracted items
      if (batchImportItems.length > 0) {
        // Show "Proceed to Step 2" button instead of automatically transitioning
        const extractBtnContainer = document.getElementById('inspector-extract-btn-container');
        if (extractBtnContainer) {
          const extractBtn = document.getElementById('inspector-extract-btn');
          if (extractBtn) {
            extractBtn.innerHTML = `
              <span style="margin-right: 8px;"></span>
              <span id="inspector-extract-btn-text">Proceed to Step 2 </span>
            `;
            extractBtn.onclick = () => proceedToStep2();
            extractBtn.disabled = false;
            extractBtn.style.opacity = '1';
            // Set a flag to prevent the button from being reset
            window.extractionCompleted = true;
          }
        }
      } else {
        // No items extracted, keep the Extract Loot button
        const extractBtn = document.getElementById('inspector-extract-btn');
        if (extractBtn) {
          extractBtn.disabled = false;
          extractBtn.style.opacity = '1';
          const extractBtnText = extractBtn.querySelector('#inspector-extract-btn-text');
          const extractBtnIcon = extractBtn.querySelector('span:first-child');
          if (extractBtnText) extractBtnText.textContent = 'Extract Loot';
          if (extractBtnIcon) extractBtnIcon.textContent = '';
          // Make sure onclick is set correctly
          extractBtn.onclick = extractFromInspector;
        }
      }
      
      // Check all items against existing items
      if (fetchedItems.length > 0) {
        try {
          const itemNames = batchImportItems.map(item => item.name);
          const response = await window.csrfHelper.fetchWithCSRF('/api/items/check-existing', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ names: itemNames })
          });
          
          if (response.ok) {
            const existingItems = await response.json();
            
            batchImportItems.forEach(item => {
              const existingItem = existingItems[item.name.toLowerCase()];
              if (existingItem) {
                item.existingData = existingItem;
                item.conflicts = detectConflicts(item, existingItem);
                item.hasConflicts = item.conflicts.length > 0;
                item.hasNoChanges = !item.hasConflicts && existingItem;
              }
            });
          }
        } catch (error) {
          console.error('Error checking existing items:', error);
        }
        
        // Final update to the table
        renderBatchImportTable();
        updateBatchImportStatus();
        updateAccumulatedItemsTitle();
        
        showMessage(`Successfully fetched ${successCount} items${errorCount > 0 ? ` (${errorCount} failed)` : ''}`, 'success');
      } else {
        showMessage('No items could be fetched from the URLs', 'error');
        
        // Re-enable the Extract Loot button with retry option
        const extractBtnContainer = document.getElementById('inspector-extract-btn-container');
        if (extractBtnContainer) {
          const extractBtn = document.getElementById('inspector-extract-btn');
          if (extractBtn) {
            extractBtn.innerHTML = `
              <span style="margin-right: 8px;"></span>
              <span id="inspector-extract-btn-text">Retry Failed Items</span>
            `;
            extractBtn.onclick = () => extractFromInspector();
            extractBtn.disabled = false;
            extractBtn.style.opacity = '1';
          }
        }
      }
    }
    
    async function processUrlBatch(urls) {
      const textarea = document.getElementById('batch-import-textarea');
      const processBtn = document.getElementById('batch-import-process-btn');
      
      // Save original button state
      const originalBtnText = processBtn.innerHTML;
      processBtn.disabled = true;
      
      // First, check if any URLs are list pages and expand them
      const expandedUrls = [];
      
      // Create a progress display
      const progressDiv = document.createElement('div');
      progressDiv.style.cssText = 'margin-top: 10px; font-size: 0.9rem; color: #999; padding: 10px; background: rgba(255, 215, 0, 0.1); border: 1px solid rgba(255, 215, 0, 0.3); border-radius: 4px;';
      textarea.parentNode.insertBefore(progressDiv, textarea.nextSibling);
      
      // Store original textarea content and make it semi-transparent
      const originalTextareaContent = textarea.value;
      textarea.style.opacity = '0.5';
      textarea.disabled = true;
      
      let processedCount = 0;
      const totalUrls = urls.length;
      
      for (const url of urls) {
        processedCount++;
        progressDiv.innerHTML = `Checking URL ${processedCount} of ${totalUrls}...`;
        
        // Check if it's a wiki URL that might be a list page or NPC page
        // Allow manual list designation with a special marker
        const forceList = url.endsWith('#list');
        const cleanUrl = forceList ? url.slice(0, -5) : url;
        
        if (cleanUrl.includes('/wiki/')) {
          try {
            // Update progress in data inspector if visible
            const inspectorProgressText = document.getElementById('inspector-progress-text');
            if (inspectorProgressText && document.getElementById('data-inspector').style.display !== 'none') {
              inspectorProgressText.textContent = `Checking URL ${processedCount}/${totalUrls}: ${cleanUrl.split('/').pop()}`;
            }
            processBtn.innerHTML = `Checking URLs... (${processedCount}/${totalUrls})`;
            const proxyUrl = 'https://api.allorigins.win/get?url=' + encodeURIComponent(cleanUrl);
            
            let response;
            try {
              response = await fetch(proxyUrl, {
                method: 'GET',
                mode: 'cors',
                cache: 'no-cache'
              });
            } catch (fetchError) {
              console.warn('Failed with allorigins proxy, trying corsproxy.io:', cleanUrl);
              // Try alternative proxy
              try {
                const altProxyUrl = 'https://corsproxy.io/?' + encodeURIComponent(cleanUrl);
                response = await fetch(altProxyUrl, {
                  method: 'GET',
                  mode: 'cors',
                  cache: 'no-cache'
                });
              } catch (altFetchError) {
                console.warn('Both proxies failed for URL type checking:', cleanUrl, altFetchError);
                // If we can't check the URL type, assume it's a single item
                expandedUrls.push(cleanUrl);
                continue;
              }
            }
            
            if (response.ok) {
              let pageContent;
              try {
                // Check if we're using allorigins (returns JSON) or corsproxy (returns HTML)
                if (response.url.includes('allorigins')) {
                  const data = await response.json();
                  pageContent = data.contents || '';
                } else {
                  // corsproxy returns HTML directly
                  pageContent = await response.text();
                }
              } catch (parseError) {
                console.warn('Failed to parse response for URL:', cleanUrl, parseError);
                expandedUrls.push(cleanUrl);
                continue;
              }
              
              // Parse the page to determine its type
              const parser = new DOMParser();
              const doc = parser.parseFromString(pageContent, 'text/html');
              const pageText = doc.body ? doc.body.textContent.toLowerCase() : '';
              const h1 = doc.querySelector('h1');
              const pageTitle = h1 ? h1.textContent.trim() : '';
              
              // Check for NPC indicators FIRST before item list
              const hasNPCStats = (pageText.includes('level:') || pageText.includes('race:') || pageText.includes('type:')) && 
                                 (pageText.includes('health:') || pageText.includes('damage:') || pageText.includes('spawn'));
              const hasLootSections = pageText.includes('unique loot') || pageText.includes('common loot') || 
                                     pageText.includes('loot') || pageText.includes('drops');
              const looksLikeNPCName = /^[A-Z][a-z]+ [A-Z]/.test(pageTitle) || // First Last name pattern
                                      /^(Lord|Lady|Sir|Captain|Lieutenant|Sergeant|General|Colonel|Major|Corporal|Private|Master|Keeper|Guard|Merchant|Trader|Vendor|Shopkeeper|Innkeeper|Barkeep|Smith|Blacksmith|Weaponsmith|Armorsmith|Tailor|Alchemist|Enchanter|Wizard|Cleric|Priest|Priestess|Bishop|Cardinal|Monk|Brother|Sister|Elder|Chief|Shaman|Oracle|Seer|Scout|Ranger|Hunter|Assassin|Thief|Rogue|Warrior|Knight|Paladin|Champion|Hero|Veteran|Recruit|Apprentice|Journeyman|Expert|Grandmaster|King|Queen|Prince|Princess|Duke|Duchess|Baron|Baroness|Count|Countess|Mayor|Councilor|Ambassador|Emissary|Messenger|Courier|Guide|Trainer|Teacher|Scholar|Sage|Librarian|Scribe|Historian|Archaeologist|Explorer|Adventurer|Wanderer|Traveler|Pilgrim|Hermit|Mystic|Druid|Necromancer|Warlock|Sorcerer|Mage|Elementalist|Summoner|Conjurer|Illusionist|Diviner|Abjurer|Transmuter|Evoker)\s+/i.test(pageTitle) ||
                                      pageTitle.toLowerCase().includes('master') ||
                                      pageTitle.toLowerCase().includes('keeper') ||
                                      pageTitle.toLowerCase().includes('guard') ||
                                      pageTitle.toLowerCase().includes('merchant');
              
              // Also check for NPC-specific sections
              const hasNPCSections = pageText.includes('spawn location') || pageText.includes('respawn time') ||
                                    pageText.includes('faction:') || pageText.includes('aggro radius');
              
              // More lenient NPC detection - doesn't require loot if has strong NPC indicators
              const isNPCPage = (hasNPCStats && (hasLootSections || hasNPCSections)) || 
                               (looksLikeNPCName && (hasNPCStats || hasNPCSections || hasLootSections));
              
              if (isNPCPage) {
                // This is an NPC page
                const npcLootUrls = parseNPCLootPage(pageContent, cleanUrl);
                if (npcLootUrls.length > 0) {
                  showMessage(`Found ${npcLootUrls.length} loot items/lists from NPC page`, 'info');
                  progressDiv.innerHTML = `Processing ${npcLootUrls.length} loot URLs from NPC...`;
                  
                  // Now we need to expand any item list URLs within the loot
                  let lootProcessed = 0;
                  for (const lootUrl of npcLootUrls) {
                    lootProcessed++;
                    progressDiv.innerHTML = `Processing loot URL ${lootProcessed} of ${npcLootUrls.length}...`;
                    try {
                      const lootProxyUrl = 'https://api.allorigins.win/get?url=' + encodeURIComponent(lootUrl);
                      const lootResponse = await fetch(lootProxyUrl, {
                        method: 'GET',
                        mode: 'cors',
                        cache: 'no-cache'
                      });
                      
                      if (lootResponse.ok) {
                        const lootData = await lootResponse.json();
                        const lootPageContent = lootData.contents || '';
                        
                        // Parse the page to check if it's an NPC
                        const lootParser = new DOMParser();
                        const lootDoc = lootParser.parseFromString(lootPageContent, 'text/html');
                        const lootPageText = lootDoc.body ? lootDoc.body.textContent.toLowerCase() : '';
                        
                        // Check for NPC characteristics
                        const hasNPCStats = (lootPageText.includes('level:') && lootPageText.includes('class:') && lootPageText.includes('race:')) ||
                                           (lootPageText.includes('spawn') && lootPageText.includes('zone:')) ||
                                           (lootPageText.includes('health:') && lootPageText.includes('damage per hit:'));
                        const hasNPCSections = lootPageText.includes('spawn location') || lootPageText.includes('respawn time') ||
                                              lootPageText.includes('faction:') || lootPageText.includes('aggro radius:');
                        const hasLootSection = lootPageText.includes('unique loot') || lootPageText.includes('common loot');
                        
                        // It's an NPC if it has NPC stats/sections AND loot sections
                        if ((hasNPCStats || hasNPCSections) && hasLootSection) {
                          // Skip this NPC URL
                          continue;
                        }
                        
                        // Check if it's an item list page
                        const subItemUrls = parseItemListPage(lootPageContent, lootUrl);
                        
                        if (subItemUrls.length > 0) {
                          // This loot link was an item list
                          expandedUrls.push(...subItemUrls);
                        } else {
                          // This loot link is a single item
                          expandedUrls.push(lootUrl);
                        }
                      } else {
                        expandedUrls.push(lootUrl);
                      }
                    } catch (error) {
                      expandedUrls.push(lootUrl);
                    }
                  }
                } else {
                  // NPC page but no loot found - feedback in data inspector
                  // Don't add the NPC URL itself as an item
                }
              } else {
                // Not an NPC page, check if it's an item list page
                // If forceList is true, always treat as a list page
                let itemUrls = [];
                
                if (forceList) {
                  // Force parsing as a list page regardless of heuristics
                  const parser = new DOMParser();
                  const doc = parser.parseFromString(pageContent, 'text/html');
                  const contentArea = doc.querySelector('#mw-content-text, .mw-parser-output, main, article') || doc.body;
                  const allLinks = contentArea ? contentArea.querySelectorAll('a[href*="/wiki/"]') : [];
                  
                  const urlParts = cleanUrl.split('/');
                  const baseWikiUrl = urlParts.slice(0, -1).join('/') + '/';
                  const seenUrls = new Set();
                  
                  for (const link of allLinks) {
                    const href = link.getAttribute('href');
                    if (!href || href.includes('#') || href.includes('action=') || href.includes('redlink=1')) continue;
                    
                    const wikiPath = href.split('?')[0];
                    if (wikiPath.includes('Special:') || wikiPath.includes('Category:') || 
                        wikiPath.includes('Template:') || wikiPath.includes('User:')) continue;
                    
                    let fullUrl;
                    if (href.startsWith('http')) {
                      fullUrl = href;
                    } else if (href.startsWith('/')) {
                      const urlObj = new URL(cleanUrl);
                      fullUrl = urlObj.origin + href;
                    } else {
                      fullUrl = baseWikiUrl + href;
                    }
                    
                    if (!seenUrls.has(fullUrl) && !fullUrl.endsWith(cleanUrl.split('/').pop())) {
                      seenUrls.add(fullUrl);
                      itemUrls.push(fullUrl);
                    }
                  }
                  
                  if (itemUrls.length > 0) {
                  }
                } else {
                  itemUrls = parseItemListPage(pageContent, cleanUrl);
                }
                
                if (itemUrls.length > 0) {
                  // This is a list page, replace with item URLs
                  expandedUrls.push(...itemUrls);
                  // Feedback moved to data inspector
                } else {
                  // Check if this might be a list page that we failed to parse
                  const mightBeList = pageTitle.toLowerCase().match(/\b(list|index|category|equipment|weapons|armors?|items|collection|set|gear)\b/);
                  if (mightBeList && !pageContent.match(/Weapon\s+DMG:|Slot:\s*\w+\s+Class:/i)) {
                    console.warn(`Possible list page not expanded: "${pageTitle}" - treating as single item. Add #list to force expansion.`);
                  }
                  // Single item page
                  expandedUrls.push(cleanUrl);
                }
              }
            } else {
              // Failed to fetch, keep original URL
              expandedUrls.push(cleanUrl);
            }
          } catch (error) {
            console.error('Error checking URL:', error);
            // If there's any error in URL type detection, just add the original URL
            expandedUrls.push(cleanUrl);
          }
        } else {
          expandedUrls.push(cleanUrl);
        }
      }
      
      // Remove the progress display and restore textarea
      if (progressDiv && progressDiv.parentNode) {
        progressDiv.parentNode.removeChild(progressDiv);
      }
      textarea.style.opacity = '1';
      textarea.disabled = false;
      
      // Update textarea with expanded URLs
      if (expandedUrls.length !== urls.length) {
        const originalCount = urls.length;
        urls = expandedUrls;
        
        // If we expanded URLs but got nothing, it means we only had NPCs/lists with no items
        if (expandedUrls.length === 0) {
          showMessage('No item URLs found. The provided URL(s) contained no loot items.', 'warning');
          textarea.value = '';
          processBtn.disabled = false;
          processBtn.innerHTML = 'Fetch & Add Items';
          return;
        }
        
        // Expansion complete - feedback shown in data inspector
      }
      
      // Remove duplicates from the URL list
      const uniqueUrls = [...new Set(urls)];
      if (uniqueUrls.length !== urls.length) {
        const duplicateCount = urls.length - uniqueUrls.length;
        showMessage(`Removed ${duplicateCount} duplicate URL${duplicateCount > 1 ? 's' : ''}`, 'info');
        urls = uniqueUrls;
      }
      
      // Update textarea with final URL list
      textarea.value = urls.join('\n');
      
      // Show loading state
      processBtn.disabled = true;
      processBtn.innerHTML = 'Fetching Items...';
      
      // Show info about rate limiting
      if (urls.length > 10) {
        showMessage(`Processing ${urls.length} URLs with rate limiting. This will take approximately ${Math.round(urls.length * 1.5 / 60)} minutes.`, 'info');
      }
      
      // Create visual feedback for each URL
      const urlStatuses = {};
      const originalContent = textarea.value;
      
      // Create a status display overlay
      let statusDisplay = document.getElementById('batch-url-status');
      if (!statusDisplay) {
        statusDisplay = document.createElement('div');
        statusDisplay.id = 'batch-url-status';
        statusDisplay.style.cssText = 'position: absolute; top: 0; left: 0; right: 0; bottom: 0; padding: 15px; pointer-events: auto; white-space: pre-wrap; font-family: monospace; overflow-y: auto; overflow-x: hidden; background: rgba(26, 26, 26, 0.95);';
        
        // Create wrapper for positioning
        const textareaWrapper = document.createElement('div');
        textareaWrapper.className = 'url-status-wrapper';
        textareaWrapper.style.cssText = 'position: relative; flex: 1; display: flex;';
        textarea.parentNode.insertBefore(textareaWrapper, textarea);
        textareaWrapper.appendChild(textarea);
        textareaWrapper.appendChild(statusDisplay);
        
        // Hide textarea while processing
        textarea.style.display = 'none';
      }
      
      // Show URL status in overlay
      const updateUrlDisplay = () => {
        const displayElements = urls.map((url, index) => {
          const status = urlStatuses[url] || 'pending';
          let color = '#999';
          let prefix = '';
          
          if (status === 'success') {
            color = '#4CAF50';
            prefix = ' ';
          } else if (status === 'error') {
            color = '#f44336';
            prefix = ' ';
          } else if (status === 'skipped') {
            color = '#999';
            prefix = ' ';
          } else if (status === 'fetching') {
            color = '#FFD700';
            prefix = ' ';
          } else if (status === 'retrying') {
            color = '#FF9800';
            prefix = ' ';
          } else {
            prefix = ' ';
          }
          
          return `<div style="color: ${color}; line-height: 1.5;" data-url="${url}">${prefix}${url}</div>`;
        });
        
        statusDisplay.innerHTML = displayElements.join('');
        
        // Auto-scroll to the current item being processed
        const currentItem = statusDisplay.querySelector('div[style*="#FFD700"], div[style*="#FF9800"]');
        if (currentItem && statusDisplay.scrollHeight > statusDisplay.clientHeight) {
          // Scroll the item into view, keeping it centered if possible
          const itemTop = currentItem.offsetTop;
          const itemHeight = currentItem.offsetHeight;
          const containerHeight = statusDisplay.clientHeight;
          const scrollPosition = itemTop - (containerHeight / 2) + (itemHeight / 2);
          statusDisplay.scrollTop = Math.max(0, scrollPosition);
        }
        
        // Keep textarea content in sync but transparent
        textarea.value = urls.join('\n');
        textarea.style.color = 'transparent';
        textarea.style.caretColor = '#e0e0e0';
      };
      
      updateUrlDisplay();
      
      // Parse item data from wiki page
      const parseWikiItemData = (html, url) => {
        // Extract item name from URL (e.g., "Rusty_Axe" -> "Rusty Axe")
        const urlParts = url.split('/');
        const itemNameFromUrl = urlParts[urlParts.length - 1].replace(/_/g, ' ').replace(/%20/g, ' ');
        
        // Create a temporary div to parse HTML
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        
        // Try to find item name from page title or h1
        let itemName = itemNameFromUrl;
        const h1 = doc.querySelector('h1');
        if (h1) {
          itemName = h1.textContent.trim();
        }
        
        // Check if this is a quest page, NPC page, or crafting material
        const bodyText = doc.body ? doc.body.textContent : '';
        const questIndicators = [
          'Quest Giver',
          'Quest Type',
          'Start Zone',
          'End Zone',
          'Quest Text',
          'Level Requirement',
          'Prerequisites',
          'Quest Rewards',
          'Quest Chain',
          'Quest Objectives'
        ];
        
        // Check if page contains quest-related content
        const isQuestPage = questIndicators.some(indicator => bodyText.includes(indicator)) ||
                           /quest|task|mission|errand/i.test(itemName) ||
                           bodyText.match(/Quest\s*:/i) ||
                           bodyText.match(/Type\s*:\s*Quest/i);
        
        // We'll determine if it's a crafting material based on page content, not just name
        let isCraftingMaterial = false;
        
        // If it's a quest page, skip it
        if (isQuestPage) {
          return null; // This will be filtered out later
        }
        
        // Start with basic item structure - don't infer anything yet
        const item = {
          tempId: `batch_${batchImportItems.length}`,
          name: itemName,
          item_type: null,
          slot: null,
          slots: [],
          icon_type: 'emoji',
          icon_value: '',
          size: 'Medium',
          weight: 0,
          str: 0,
          sta: 0,
          agi: 0,
          dex: 0,
          wis: 0,
          int: 0,
          cha: 0,
          ac: 0,
          block: 0,
          health: 0,
          mana: 0,
          attack_speed: 0,
          damage: 0,
          delay: 0,
          resist_cold: 0,
          resist_corruption: 0,
          resist_disease: 0,
          resist_electricity: 0,
          resist_fire: 0,
          resist_magic: 0,
          resist_poison: 0,
          skill: null,
          race: 'ALL',
          class: 'ALL',
          description: '',
          isDuplicate: false,
          errors: [],
          inferredFields: [],
          dataSource: 'url', // Mark as coming from URL
          parsedFields: [] // Track which fields were parsed
        };
        
        // Look for item data in various formats
        // First look for wiki text content in pre or code blocks
        const preBlocks = doc.querySelectorAll('pre, code');
        let wikiText = '';
        for (const block of preBlocks) {
          wikiText += block.textContent + '\n';
        }
        
        // If no pre blocks, try to find structured data in tables
        const tables = doc.querySelectorAll('table');
        for (const table of tables) {
          const rows = table.querySelectorAll('tr');
          for (const row of rows) {
            const cells = row.querySelectorAll('td, th');
            if (cells.length >= 2) {
              const label = cells[0].textContent.trim().toLowerCase();
              const value = cells[1].textContent.trim();
              
              // Map common labels to item properties
              if (label.includes('slot')) {
                // Check for PRIMARY SECONDARY first
                if (value.match(/PRIMARY\s+SECONDARY/i) || value.match(/PRIMARY\/SECONDARY/i)) {
                  item.slot = 'Primary/Secondary';
                  item.slots = ['Primary', 'Secondary'];
                } else if (value.match(/RANGE/i)) {
                  item.slot = 'Range';
                  item.slots = ['Range'];
                } else if (value.match(/SECONDARY/i)) {
                  item.slot = 'Secondary';
                  item.slots = ['Secondary'];
                } else if (value.match(/PRIMARY/i)) {
                  item.slot = 'Primary';
                  item.slots = ['Primary'];
                }
              } else if (label.includes('type')) {
                item.item_type = value.toLowerCase();
              } else if (label.includes('damage')) {
                const dmgMatch = value.match(/(\d+)/);
                if (dmgMatch) item.damage = parseInt(dmgMatch[1]);
              } else if (label.includes('delay')) {
                const delayMatch = value.match(/(\d+)/);
                if (delayMatch) item.delay = parseInt(delayMatch[1]);
              } else if (label.includes('weight')) {
                const weightMatch = value.match(/([\d.]+)/);
                if (weightMatch) item.weight = parseFloat(weightMatch[1]);
              } else if (label.includes('size')) {
                item.size = value.charAt(0).toUpperCase() + value.slice(1).toLowerCase();
              } else if (label.includes('class')) {
                item.class = value;
              } else if (label.includes('race')) {
                item.race = value;
              }
              // Stats
              else if (label === 'str' || label.includes('strength')) {
                item.str = parseInt(value) || 0;
              } else if (label === 'sta' || label.includes('stamina')) {
                item.sta = parseInt(value) || 0;
              } else if (label === 'agi' || label.includes('agility')) {
                item.agi = parseInt(value) || 0;
              } else if (label === 'dex' || label.includes('dexterity')) {
                item.dex = parseInt(value) || 0;
              } else if (label === 'wis' || label.includes('wisdom')) {
                item.wis = parseInt(value) || 0;
              } else if (label === 'int' || label.includes('intelligence')) {
                item.int = parseInt(value) || 0;
              } else if (label === 'cha' || label.includes('charisma')) {
                item.cha = parseInt(value) || 0;
              } else if (label === 'ac' || label.includes('armor class')) {
                item.ac = parseInt(value) || 0;
              } else if (label === 'hp' || label.includes('health') || label.includes('hit points')) {
                item.health = parseInt(value) || 0;
              } else if (label.includes('mana')) {
                item.mana = parseInt(value) || 0;
              }
            }
          }
        }
        
        // Also try to parse from text content using regex patterns
        // Combine wiki text from pre blocks with body text
        const fullText = (wikiText + '\n' + bodyText).replace(/\s+/g, ' ');
        
        // Look for common patterns in wiki pages
        // Weapon DMG pattern: "Weapon DMG: X ATK Delay: Y Skill: Z"
        const weaponDmgMatch = fullText.match(/Weapon\s+DMG:\s*(\d+)\s+ATK\s+Delay:\s*(\d+)(?:\s+Skill:\s*(\w+))?/i);
        if (weaponDmgMatch) {
          item.damage = parseInt(weaponDmgMatch[1]) || 0;
          item.delay = parseInt(weaponDmgMatch[2]) || 0;
          if (item.damage > 0) item.parsedFields.push('damage');
          if (item.delay > 0) item.parsedFields.push('delay');
          if (weaponDmgMatch[3]) {
            const skillMap = {
              'SLA': 'Slashing',
              '2HS': 'Slashing',
              '1HS': 'Slashing',
              '1HB': 'Bludgeoning',
              '2HB': 'Bludgeoning',
              'BLD': 'Bludgeoning',
              'BLG': 'Bludgeoning',
              'BLU': 'Bludgeoning',
              'PIE': 'Piercing',
              'STA': 'Piercing',
              '2HP': 'Piercing',
              '1HP': 'Piercing',
              'ARC': 'Archery',
              'THR': 'Throwing'
            };
            const mappedSkill = skillMap[weaponDmgMatch[3].toUpperCase()];
            if (mappedSkill) {
              item.skill = mappedSkill;
              item.parsedFields.push('skill');
            }
          }
        }
        
        // Weight pattern: "Weight: X"
        const weightMatch = fullText.match(/Weight:\s*([\d.]+)/i);
        if (weightMatch) {
          item.weight = parseFloat(weightMatch[1]) || 0;
          item.parsedFields.push('weight');
        }
        
        // Size pattern: "Size: X"
        const sizeMatch = fullText.match(/Size:\s*(\w+)/i);
        if (sizeMatch) {
          item.size = sizeMatch[1].charAt(0).toUpperCase() + sizeMatch[1].slice(1).toLowerCase();
          item.parsedFields.push('size');
        }
        
        // Look for class/race restrictions in a more structured way
        // First check if there's a clear item stats section
        const statsSection = fullText.match(/(?:Item Stats|Stats|Properties)[\s\S]*?(?=\n\n|Drops From|Related|$)/i);
        const searchText = statsSection ? statsSection[0] : fullText;
        
        // Class pattern: "Class: X" or "Classes: X" - match only valid class values
        const validClasses = ['ARC', 'WAR', 'PAL', 'RNG', 'ROG', 'CLR', 'DRU', 'SHA', 'WIZ', 'NEC', 'ENC', 'MAG', 'MNK', 'BRD', 'ELE', 'ALL'];
        // Look for Class: followed by valid class codes or ALL
        const classMatch = fullText.match(/Class(?:es)?:\s*((?:ALL|[A-Z]{3}(?:\s+[A-Z]{3})*))/i);
        if (classMatch) {
          const classText = classMatch[1].trim();
          // Validate each part is a known class
          const classParts = classText.split(/\s+/);
          const allValid = classParts.every(part => validClasses.includes(part));
          if (allValid) {
            item.class = classText;
          }
        }
        
        // Race pattern: "Race: X" or "Races: X" - match only valid race values
        const validRaces = ['HUM', 'ELF', 'DEF', 'HEF', 'DWF', 'HFL', 'GNM', 'OGR', 'TRL', 'BAR', 'ALL'];
        // Look for Race: followed by valid race codes or ALL
        const raceMatch = fullText.match(/Race(?:s)?:\s*((?:ALL|[A-Z]{3}(?:\s+[A-Z]{3})*))/i);
        if (raceMatch) {
          const raceText = raceMatch[1].trim();
          // Validate each part is a known race
          const raceParts = raceText.split(/\s+/);
          const allValid = raceParts.every(part => validRaces.includes(part));
          if (allValid) {
            item.race = raceText;
          }
        }
        
        // Slot pattern: "Slot: X" - make it more flexible
        // Try multiple patterns to catch different formats
        let slotMatch = fullText.match(/Slot:\s*([\w\s/]+?)(?=\s*(?:Class|Race|Size|Weight|Stats|Weapon|AC:|STR:|STA:|AGI:|DEX:|WIS:|INT:|CHA:|$))/i);
        if (!slotMatch) {
          // Try a simpler pattern
          slotMatch = fullText.match(/Slot:\s*([A-Za-z\s/]+)/i);
        }
        if (slotMatch) {
          const slotValue = slotMatch[1].trim();
          // Check for PRIMARY SECONDARY first (with any amount of spaces)
          if (slotValue.match(/PRIMARY\s+SECONDARY/i) || slotValue.match(/PRIMARY\/SECONDARY/i)) {
            item.slot = 'Primary/Secondary';
            item.slots = ['Primary', 'Secondary'];
          } else if (slotValue.match(/RANGE/i)) {
            item.slot = 'Range';
            item.slots = ['Range'];
          } else if (slotValue.match(/SECONDARY/i)) {
            item.slot = 'Secondary';
            item.slots = ['Secondary'];
          } else if (slotValue.match(/PRIMARY/i)) {
            item.slot = 'Primary';
            item.slots = ['Primary'];
          } else {
            // Handle other slot values by normalizing them
            // Normalize the slot value for comparison
            const slotNormalized = slotValue.toUpperCase().trim();
            const slotMap = {
              'NECK': 'Neck',
              'HEAD': 'Head',
              'FACE': 'Face',
              'EARS': 'Ears',
              'SHOULDERS': 'Shoulders',
              'ARMS': 'Arms',
              'BACK': 'Back',
              'WRIST': 'Wrist1',
              'WRISTS': 'Wrist1',
              'HANDS': 'Hands',
              'CHEST': 'Chest',
              'LEGS': 'Legs',
              'FEET': 'Feet',
              'WAIST': 'Waist',
              'FINGER': 'Finger1',
              'FINGERS': 'Finger1',
              'RING': 'Finger1',
              'AMMO': 'Ammo',
              'CONTAINER': 'Container'
            };
            
            if (slotMap[slotNormalized]) {
              item.slot = slotMap[slotNormalized];
              item.slots = [item.slot];
            } else {
              // If still not found, use the value as-is but capitalize first letter
              item.slot = slotValue.charAt(0).toUpperCase() + slotValue.slice(1).toLowerCase();
              item.slots = [item.slot];
            }
          }
          item.parsedFields.push('slot');
        }
        
        // Stats patterns - make colon optional to handle formats like "STR +2 DEX +2"
        const statPatterns = {
          'STR': /STR(?::)?\s*\+?(\d+)/i,
          'STA': /STA(?::)?\s*\+?(\d+)/i,
          'AGI': /AGI(?::)?\s*\+?(\d+)/i,
          'DEX': /DEX(?::)?\s*\+?(\d+)/i,
          'WIS': /WIS(?::)?\s*\+?(\d+)/i,
          'INT': /INT(?::)?\s*\+?(\d+)/i,
          'CHA': /CHA(?::)?\s*\+?(\d+)/i,
          'AC': /AC(?::)?\s*\+?(\d+)/i,
          'HP': /HP(?::)?\s*\+?(\d+)/i,
          'MANA': /MANA(?::)?\s*\+?(\d+)/i
        };
        
        for (const [stat, pattern] of Object.entries(statPatterns)) {
          const match = fullText.match(pattern);
          if (match) {
            const statKey = stat.toLowerCase();
            if (statKey === 'hp') {
              item.health = parseInt(match[1]) || 0;
            } else {
              item[statKey] = parseInt(match[1]) || 0;
            }
          }
        }
        
        // Also try to parse multiple stats on one line (e.g., "STR +2 DEX +2")
        const multiStatMatches = fullText.matchAll(/(\w+)(?::)?\s*([+-]?\d+)/g);
        for (const match of multiStatMatches) {
          const statName = match[1].toUpperCase();
          const statValue = parseInt(match[2]) || 0;
          
          if (['STR', 'STA', 'AGI', 'DEX', 'WIS', 'INT', 'CHA'].includes(statName)) {
            const statKey = statName.toLowerCase();
            // Only update if we don't already have a value from the more specific patterns
            if (item[statKey] === 0) {
              item[statKey] = statValue;
            }
          }
        }
        
        // Resistance patterns - handle formats like "SV Magic: +5"
        const resistancePatterns = [
          { pattern: /SV\s+Magic(?::)?\s*([+-]?\d+)/i, field: 'resist_magic' },
          { pattern: /Magic\s+Resist(?::)?\s*([+-]?\d+)/i, field: 'resist_magic' },
          { pattern: /SV\s+Fire(?::)?\s*([+-]?\d+)/i, field: 'resist_fire' },
          { pattern: /Fire\s+Resist(?::)?\s*([+-]?\d+)/i, field: 'resist_fire' },
          { pattern: /SV\s+Cold(?::)?\s*([+-]?\d+)/i, field: 'resist_cold' },
          { pattern: /Cold\s+Resist(?::)?\s*([+-]?\d+)/i, field: 'resist_cold' },
          { pattern: /SV\s+Poison(?::)?\s*([+-]?\d+)/i, field: 'resist_poison' },
          { pattern: /Poison\s+Resist(?::)?\s*([+-]?\d+)/i, field: 'resist_poison' },
          { pattern: /SV\s+Disease(?::)?\s*([+-]?\d+)/i, field: 'resist_disease' },
          { pattern: /Disease\s+Resist(?::)?\s*([+-]?\d+)/i, field: 'resist_disease' },
          { pattern: /SV\s+Corruption(?::)?\s*([+-]?\d+)/i, field: 'resist_corruption' },
          { pattern: /Corruption\s+Resist(?::)?\s*([+-]?\d+)/i, field: 'resist_corruption' },
          { pattern: /SV\s+Electricity(?::)?\s*([+-]?\d+)/i, field: 'resist_electricity' },
          { pattern: /Electricity\s+Resist(?::)?\s*([+-]?\d+)/i, field: 'resist_electricity' },
          { pattern: /Lightning\s+Resist(?::)?\s*([+-]?\d+)/i, field: 'resist_electricity' }
        ];
        
        for (const { pattern, field } of resistancePatterns) {
          const match = fullText.match(pattern);
          if (match) {
            item[field] = parseInt(match[1]) || 0;
          }
        }
        
        // Add URL to description
        item.description = url;
        
        // Determine item type based on parsed data, not name
        if (!item.item_type) {
          // Priority 1: If it has weapon stats (damage and delay), it's definitely a weapon
          if (item.damage > 0 && item.delay > 0) {
            item.item_type = 'weapon';
            item.parsedFields.push('item_type');
          } 
          // Priority 2: If it has a valid equipment slot, determine type from slot
          else if (item.slot && item.slot !== 'Primary/Secondary') {
            // Map slots to item types
            const slotToType = {
              'Head': 'armor',
              'Face': 'armor',
              'Ears': 'accessory',
              'Neck': 'armor',  // Changed from accessory to armor
              'Shoulders': 'armor',
              'Arms': 'armor',
              'Back': 'armor',
              'Wrist1': 'armor',
              'Wrist2': 'armor',
              'Hands': 'armor',
              'Chest': 'armor',
              'Legs': 'armor',
              'Feet': 'armor',
              'Waist': 'armor',
              'Finger1': 'accessory',
              'Finger2': 'accessory',
              'Primary': 'weapon',
              'Secondary': 'shield', // Could be weapon or shield
              'Range': 'weapon',
              'Ammo': 'misc',
              'Container': 'container'
            };
            
            if (slotToType[item.slot]) {
              item.item_type = slotToType[item.slot];
              item.parsedFields.push('item_type');
            }
          }
          // Priority 3: Check if it's a consumable (bandages with Bind Wound effect)
          else if ((itemName.toLowerCase().includes('bandage') && fullText.match(/Bind Wound/i)) || 
                   fullText.match(/Effect:\s*Bind Wound/i)) {
            item.item_type = 'consumable';
            item.parsedFields.push('item_type');
          }
          // Priority 4: If it has AC but no weapon stats, it's likely armor
          else if (item.ac > 0 && item.damage === 0) {
            item.item_type = 'armor';
            item.parsedFields.push('item_type');
          }
          // Priority 5: Check if page content suggests it's a crafting material
          else if (!item.slot && item.damage === 0 && item.ac === 0) {
            // No slot, no combat stats - check for crafting/misc indicators
            const craftingKeywords = /material|component|ingredient|reagent|resource|craft|tradeskill|scraps/i;
            const isCraftingName = /scraps|dust|powder|ore|ingot|hide|pelt|bone|scale|wood|resin|fiber|thread/i.test(itemName);
            
            if (craftingKeywords.test(bodyText) || craftingKeywords.test(item.description) || isCraftingName) {
              item.item_type = 'misc';
              item.parsedFields.push('item_type');
              isCraftingMaterial = true;
              // Clear any slot that was parsed for crafting materials
              if (item.slot) {
                item.slot = null;
                item.slots = [];
                // Remove slot from parsedFields if it was there
                const slotIndex = item.parsedFields.indexOf('slot');
                if (slotIndex > -1) {
                  item.parsedFields.splice(slotIndex, 1);
                }
              }
            }
          }
          
          // Last resort: Only use name-based detection if we have no other data
          if (!item.item_type) {
            const inferredType = detectItemType(item.name, item.slot);
            if (inferredType) {
              item.item_type = inferredType;
              item.inferredFields.push('item_type');
            } else {
              // Default to misc if we can't determine type
              item.item_type = 'misc';
              item.inferredFields.push('item_type');
            }
          }
        }
        
        if (!item.slot) {
          // Only infer slots for weapons based on type, not name
          if (item.item_type === 'weapon' && item.damage > 0) {
            // Default weapon slot to Primary if not parsed from page
            item.slot = 'Primary';
            item.slots = ['Primary'];
            item.inferredFields.push('slot');
          }
          // For all other items without a parsed slot, leave it as null (will show as "None" in UI)
        }
        
        // Infer weapon skill if it's a weapon and skill wasn't parsed
        if (item.item_type === 'weapon' && !item.skill) {
          const inferredSkill = inferWeaponSkill(item.name, item.item_type);
          if (inferredSkill) {
            item.skill = inferredSkill;
            item.inferredFields.push('skill');
          }
        }
        
        // Set default icon based on type if not already set
        if (item.icon_value === '') {
          const icon = getDefaultIcon(item.item_type || 'misc', item.slot);
          item.icon_type = icon.type;
          item.icon_value = icon.value;
        }
        
        return item;
      };
      
      // Process URLs sequentially with rate limiting
      const results = [];
      const DELAY_BETWEEN_REQUESTS = 1100; // 1.1 second delay between requests to avoid rate limits
      const MAX_RETRIES = 2;
      
      // Temporarily suppress console errors during processing to avoid rate limit spam
      const originalConsoleError = console.error;
      const originalConsoleWarn = console.warn;
      console.error = (...args) => {
        // Only suppress network-related errors
        const message = args.join(' ');
        if (message.includes('429') || message.includes('rate limit') || message.includes('Failed to fetch') || 
            message.includes('CORS') || message.includes('Access-Control-Allow-Origin') ||
            message.includes('ERR_FAILED') || message.includes('Too Many Requests')) {
          return; // Silently ignore
        }
        originalConsoleError.apply(console, args);
      };
      console.warn = (...args) => {
        const message = args.join(' ');
        if (message.includes('429') || message.includes('CORS') || message.includes('Too Many Requests')) {
          return; // Silently ignore
        }
        originalConsoleWarn.apply(console, args);
      };
      
      for (let i = 0; i < urls.length; i++) {
        const url = urls[i];
        let retries = 0;
        let success = false;
        
        while (retries <= MAX_RETRIES && !success) {
          try {
            urlStatuses[url] = 'fetching';
            updateUrlDisplay();
            
            // Add delay between requests to avoid rate limiting
            if (i > 0 || retries > 0) {
              await new Promise(resolve => setTimeout(resolve, DELAY_BETWEEN_REQUESTS));
            }
            
            // Use fetch API with CORS proxy
            // Try different proxy on retries to spread the load
            let proxyUrl;
            if (retries === 0) {
              proxyUrl = 'https://api.allorigins.win/get?url=' + encodeURIComponent(url);
            } else {
              // Use cors-anywhere as fallback (note: this has stricter limits)
              proxyUrl = 'https://corsproxy.io/?' + encodeURIComponent(url);
            }
            
            let response;
            try {
              response = await fetch(proxyUrl);
            } catch (networkError) {
              // Silently handle network/CORS errors
              if (retries < MAX_RETRIES) {
                retries++;
                urlStatuses[url] = 'retrying';
                updateUrlDisplay();
                await new Promise(resolve => setTimeout(resolve, 2000));
                continue;
              } else {
                urlStatuses[url] = 'error';
                updateUrlDisplay();
                results.push(null);
                success = true;
                continue;
              }
            }
            
            if (!response.ok) {
              if (response.status === 429) {
                // Rate limited - wait longer before retry (silently handle)
                urlStatuses[url] = 'retrying';
                updateUrlDisplay();
                await new Promise(resolve => setTimeout(resolve, 3000)); // Wait 3 seconds for rate limit
                retries++;
                continue;
              } else if (response.status === 500) {
                // Server error - might be temporary, retry with delay (silently handle)
                urlStatuses[url] = 'retrying';
                updateUrlDisplay();
                await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds for server error
                retries++;
                continue;
              }
              throw new Error(`HTTP ${response.status}`);
            }
            
            let pageContent;
            if (retries === 0) {
              // allorigins returns JSON with contents property
              const data = await response.json();
              pageContent = data.contents || '';
            } else {
              // corsproxy returns HTML directly
              pageContent = await response.text();
            }
            const pageDoesNotExist = pageContent.includes('There is currently no text in this page') ||
                                     pageContent.includes('This page does not exist') ||
                                     pageContent.includes('Creating') ||
                                     pageContent.includes('class="noarticletext"') ||
                                     !pageContent.includes('</h1>');
            
            if (pageDoesNotExist) {
              // Skip items without valid wiki pages
              urlStatuses[url] = 'skipped';
              updateUrlDisplay();
              results.push(null);
            } else {
              // Parse normally if page exists
              const item = parseWikiItemData(pageContent, url);
              if (item === null) {
                // This was a quest page or other non-item content
                urlStatuses[url] = 'skipped';
                updateUrlDisplay();
                results.push(null);
              } else {
                urlStatuses[url] = 'success';
                updateUrlDisplay();
                results.push(item);
              }
            }
            
            success = true;
            
          } catch (error) {
            if (retries < MAX_RETRIES) {
              retries++;
              urlStatuses[url] = 'retrying';
              updateUrlDisplay();
              await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2s before retry
            } else {
              urlStatuses[url] = 'error';
              updateUrlDisplay();
              results.push(null);
              success = true; // Move on to next URL
            }
          }
        }
        
        // Update progress indicator
        const progress = Math.round((i + 1) / urls.length * 100);
        const statusDisplay = document.getElementById('batch-url-status');
        if (statusDisplay) {
          let progressBar = statusDisplay.querySelector('.url-progress-bar');
          if (!progressBar) {
            progressBar = document.createElement('div');
            progressBar.className = 'url-progress-bar';
            progressBar.style.cssText = `position: absolute; bottom: 0; left: 0; right: 100%; height: 3px; background: #4CAF50; transition: right 0.3s; z-index: 2;`;
            statusDisplay.appendChild(progressBar);
          }
          progressBar.style.right = `${100 - progress}%`;
        }
      }
      
      // Filter out failed fetches and quest pages
      const successfulItems = results.filter(item => item !== null);
      
      // Clean up the status display
      const cleanupUrlDisplay = () => {
        textarea.style.background = '#1a1a1a';
        textarea.style.color = '#e0e0e0';
        textarea.style.position = '';
        textarea.style.zIndex = '';
        textarea.style.display = ''; // Show textarea again
        
        if (statusDisplay) {
          const wrapper = statusDisplay.parentNode;
          if (wrapper && wrapper.classList.contains('url-status-wrapper')) {
            // Move textarea back to original position
            wrapper.parentNode.insertBefore(textarea, wrapper);
            wrapper.remove();
          }
          statusDisplay.remove();
        }
      };
      
      if (successfulItems.length === 0) {
        showMessage('Failed to fetch any items from URLs', 'error');
        textarea.value = originalContent;
        cleanupUrlDisplay();
        processBtn.disabled = false;
        processBtn.innerHTML = 'Fetch & Add Items';
        // Restore original console functions
        console.error = originalConsoleError;
        console.warn = originalConsoleWarn;
        return;
      }
      
      // Add successful items to batch
      batchImportItems = batchImportItems.concat(successfulItems);
      
      // Clear textarea and show success
      textarea.value = '';
      cleanupUrlDisplay();
      updateBatchImportCount();
      // Show appropriate message based on results
      const successCount = successfulItems.length;
      const errorCount = Object.values(urlStatuses).filter(s => s === 'error').length;
      const skippedCount = Object.values(urlStatuses).filter(s => s === 'skipped').length;
      
      let message = `Fetched ${successCount} of ${totalUrls} items`;
      const details = [];
      if (errorCount > 0) details.push(`${errorCount} failed`);
      if (skippedCount > 0) details.push(`${skippedCount} skipped (quest/NPC/non-item pages)`);
      if (details.length > 0) {
        message += ` (${details.join(', ')})`;
      }
      
      showMessage(message, successCount > 0 ? 'success' : 'error');
      
      // Check against existing items and fetch their data
      try {
        const itemNames = batchImportItems.map(item => item.name);
        const response = await window.csrfHelper.fetchWithCSRF('/api/items/check-existing', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ names: itemNames })
        });
        
        if (response.ok) {
          const existingItems = await response.json();
          
          // Store existing item data and mark conflicts
          batchImportItems.forEach(item => {
            const existingItem = existingItems[item.name.toLowerCase()];
            if (existingItem) {
              item.existingData = existingItem;
              item.conflicts = detectConflicts(item, existingItem);
              if (item.conflicts.length > 0) {
                item.hasConflicts = true;
                item.hasNoChanges = false;
              } else {
                // Check if this is truly unchanged (exists but no conflicts)
                item.hasNoChanges = true;
                item.hasConflicts = false;
              }
            } else {
              item.hasNoChanges = false;
            }
          });
        }
      } catch (error) {
        console.error('Error checking existing items:', error);
      }
      
      // Show batch mode
      showBatchMode();
      
      // Render the table
      renderBatchImportTable();
      updateBatchImportStatus();
      updateAccumulatedItemsTitle();
      
      // Reset button to original state
      processBtn.disabled = false;
      processBtn.innerHTML = originalBtnText || 'Process Items ';
      
      // Restore original console functions
      console.error = originalConsoleError;
      console.warn = originalConsoleWarn;
    }
    
    function parseNPCLootPage(html, baseUrl) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
      const lootUrls = [];
      const seenUrls = new Set(); // Use Set for deduplication
      
      // Debug logging for specific NPCs
      if (baseUrl.includes('Bone_Construct')) {
      }
      
      // Check if this is an NPC page by looking for indicators
      const pageText = doc.body ? doc.body.textContent.toLowerCase() : '';
      const h1 = doc.querySelector('h1');
      const pageTitle = h1 ? h1.textContent.trim() : '';
      
      // NPC pages typically have these characteristics:
      // - Stats like "Level:", "Health:", "Damage:"
      // - Sections for "Unique Loot" and/or "Common Loot"
      // - Often have "Spawn Locations" section
      // - May have "Race:", "Type:" fields
      const hasNPCStats = (pageText.includes('level:') || pageText.includes('race:') || pageText.includes('type:')) && 
                         (pageText.includes('health:') || pageText.includes('damage:') || pageText.includes('spawn'));
      const hasLootSections = pageText.includes('unique loot') || pageText.includes('common loot') || 
                             pageText.includes('loot') || pageText.includes('drops') ||
                             pageText.includes('known loot');
      
      // Also check page title - NPCs often have titles or descriptive names
      const looksLikeNPCName = /^[A-Z][a-z]+ [A-Z]/.test(pageTitle) || // First Last name pattern
                              pageTitle.toLowerCase().includes('master') ||
                              pageTitle.toLowerCase().includes('keeper') ||
                              pageTitle.toLowerCase().includes('guard') ||
                              pageTitle.toLowerCase().includes('merchant');
      
      // Also check for NPC-specific sections
      const hasNPCSections = pageText.includes('spawn location') || pageText.includes('respawn time') ||
                            pageText.includes('faction:') || pageText.includes('aggro radius');
      
      
      if ((!hasNPCStats && !looksLikeNPCName && !hasNPCSections) || !hasLootSections) {
        // Not an NPC page or no loot sections
        if (baseUrl.includes('Bone_Construct')) {
        }
        return [];
      }
      
      // Extract base URL for relative links
      const urlParts = baseUrl.split('/');
      const baseWikiUrl = urlParts.slice(0, -1).join('/') + '/';
      
      // Find loot sections - specifically look for "Unique Loot" and "Common Loot" headers
      const contentArea = doc.querySelector('#mw-content-text, .mw-parser-output, main, article') || doc.body;
      const allHeaders = contentArea ? contentArea.querySelectorAll('h2, h3, h4') : [];
      
      if (baseUrl.includes('Bone_Construct')) {
      }
      
      for (const header of allHeaders) {
        const headerText = header.textContent.trim();
        const headerTextLower = headerText.toLowerCase();
        
        // Look specifically for loot-related headers
        // Also check for headers that contain these words
        if (headerTextLower === 'unique loot' || headerTextLower === 'common loot' ||
            headerTextLower === 'loot' || headerTextLower === 'drops' || 
            headerTextLower === 'known loot' ||
            headerTextLower.includes('loot') || headerTextLower.includes('drop') ||
            headerTextLower === 'items' || headerTextLower === 'rewards') {
          
          if (baseUrl.includes('Bone_Construct')) {
          }
          
          // Find the next element after the header that contains the loot
          let currentElement = header.nextElementSibling;
          
          // Keep looking until we find a list or table, or hit another header
          while (currentElement && !currentElement.matches('h2, h3, h4')) {
            if (baseUrl.includes('Bone_Construct')) {
            }
            
            // Check for lists
            if (currentElement.matches('ul, ol')) {
              const links = currentElement.querySelectorAll('a[href*="/wiki/"]');
              
              if (baseUrl.includes('Bone_Construct')) {
              }
              
              for (const link of links) {
                const href = link.getAttribute('href');
                if (!href) continue;
                
                // For loot sections, exclude special wiki pages and edit/redlink URLs
                const wikiPath = href.split('?')[0];
                const queryString = href.includes('?') ? href.split('?')[1] : '';
                
                // Skip if it's a special page or likely a spell/ability
                if (wikiPath.includes('Special:') ||
                    wikiPath.includes('Category:') ||
                    wikiPath.includes('Template:') ||
                    wikiPath.includes('User:') ||
                    wikiPath.includes('Talk:') ||
                    wikiPath.includes('Help:') ||
                    wikiPath.includes('MediaWiki:') ||
                    wikiPath.includes('File:') ||
                    href.includes('#')) {
                  continue;
                }
                
                // We'll need to fetch and analyze the page structure to determine if it's a spell
                // For now, we'll include all links and let the later analysis phase filter them
                // This ensures we use structure-based detection rather than name matching
                
                // Skip if it has edit/redlink parameters (non-existent pages)
                if (queryString.includes('action=edit') || 
                    queryString.includes('redlink=1')) {
                  continue;
                }
                
                // Construct full URL
                let fullUrl;
                if (href.startsWith('http')) {
                  fullUrl = href;
                } else if (href.startsWith('/')) {
                  const urlObj = new URL(baseUrl);
                  fullUrl = urlObj.origin + href;
                } else {
                  fullUrl = baseWikiUrl + href;
                }
                
                // Avoid duplicates using Set
                if (!seenUrls.has(fullUrl)) {
                  seenUrls.add(fullUrl);
                  lootUrls.push(fullUrl);
                }
              }
            }
            
            // Check for tables
            if (currentElement.matches('table')) {
              const links = currentElement.querySelectorAll('a[href*="/wiki/"]');
              for (const link of links) {
                const href = link.getAttribute('href');
                if (!href) continue;
                
                // Skip special pages and edit/redlink URLs
                const wikiPath = href.split('?')[0];
                const queryString = href.includes('?') ? href.split('?')[1] : '';
                
                if (wikiPath.includes('Special:') ||
                    wikiPath.includes('Category:') ||
                    wikiPath.includes('Template:') ||
                    wikiPath.includes('User:') ||
                    wikiPath.includes('Talk:') ||
                    wikiPath.includes('Help:') ||
                    wikiPath.includes('MediaWiki:') ||
                    wikiPath.includes('File:') ||
                    href.includes('#') ||
                    queryString.includes('action=edit') || 
                    queryString.includes('redlink=1')) {
                  continue;
                }
                
                // We'll need to fetch and analyze the page structure to determine if it's a spell
                // For now, we'll include all links and let the later analysis phase filter them
                // This ensures we use structure-based detection rather than name matching
                
                // Construct full URL
                let fullUrl;
                if (href.startsWith('http')) {
                  fullUrl = href;
                } else if (href.startsWith('/')) {
                  const urlObj = new URL(baseUrl);
                  fullUrl = urlObj.origin + href;
                } else {
                  fullUrl = baseWikiUrl + href;
                }
                
                // Avoid duplicates using Set
                if (!seenUrls.has(fullUrl)) {
                  seenUrls.add(fullUrl);
                  lootUrls.push(fullUrl);
                }
              }
            }
            
            currentElement = currentElement.nextElementSibling;
          }
        }
      }
      
      return lootUrls;
    }
    
    async function parseItemListPage(html, baseUrl) {
      try {
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, 'text/html');
        const items = [];
        
        // First check if this is a MediaWiki category page
        const categoryPages = doc.querySelector('#mw-pages');
        if (categoryPages) {
          // This is a category page like Category:Items
          // Look for links in the mw-category-group sections
          const categoryLinks = categoryPages.querySelectorAll('.mw-category-group ul li a');
          for (const link of categoryLinks) {
            const href = link.getAttribute('href');
            if (href && href.includes('/wiki/') && !href.includes(':')) {
              const fullUrl = new URL(href, baseUrl).href;
              // Skip self-references and category pages
              if (fullUrl !== baseUrl && !fullUrl.includes('Category:') && !fullUrl.includes('Special:')) {
                items.push(fullUrl);
              }
            }
          }
          
          // Also check for items in the mw-category div (alternative structure)
          const mwCategory = doc.querySelector('.mw-category');
          if (mwCategory) {
            const mwCategoryLinks = mwCategory.querySelectorAll('ul li a');
            for (const link of mwCategoryLinks) {
              const href = link.getAttribute('href');
              if (href && href.includes('/wiki/') && !href.includes(':')) {
                const fullUrl = new URL(href, baseUrl).href;
                // Skip self-references and category pages
                if (fullUrl !== baseUrl && !fullUrl.includes('Category:') && !fullUrl.includes('Special:')) {
                  items.push(fullUrl);
                }
              }
            }
          }
        }
        
        // If no items found from category structure, try common list selectors
        if (items.length === 0) {
          const listSelectors = [
            '#mw-content-text ul li a',  // Bullet lists
            '#mw-content-text ol li a',  // Numbered lists
            '#mw-content-text table td a',  // Tables
            '.item-list a',  // Explicit item list class
            '.mw-parser-output ul li a',  // MediaWiki output lists
            '.mw-parser-output table td a'  // MediaWiki output tables
          ];
          
          for (const selector of listSelectors) {
            const links = doc.querySelectorAll(selector);
            for (const link of links) {
              const href = link.getAttribute('href');
              if (href && href.includes('/wiki/') && !href.includes(':')) {
                const fullUrl = new URL(href, baseUrl).href;
                // Skip self-references and category pages
                if (fullUrl !== baseUrl && !fullUrl.includes('Category:') && !fullUrl.includes('Special:')) {
                  items.push(fullUrl);
                }
              }
            }
          }
        }
        
        // Deduplicate
        return [...new Set(items)];
      } catch (error) {
        console.error('Error parsing item list page:', error, { html: html?.substring(0, 200), baseUrl });
        return []; // Always return an array
      }
    }
    
    function createDefaultItem(name, index, skipInference = false) {
      // Create minimal item first
      const item = {
        tempId: `batch_${index}`,
        name: name,
        item_type: null,
        slot: null,
        slots: [],
        icon_type: 'emoji',
        icon_value: '',
        size: 'Medium',
        weight: 0,
        str: 0,
        sta: 0,
        agi: 0,
        dex: 0,
        wis: 0,
        int: 0,
        cha: 0,
        ac: 0,
        block: 0,
        health: 0,
        mana: 0,
        attack_speed: 0,
        damage: 0,
        delay: 0,
        resist_cold: 0,
        resist_corruption: 0,
        resist_disease: 0,
        resist_electricity: 0,
        resist_fire: 0,
        resist_magic: 0,
        resist_poison: 0,
        skill: null,
        race: null,
        class: null,
        description: '',
        isDuplicate: false,
        errors: [],
        inferredFields: [] // Track which fields were automatically inferred
      };
      
      // Only infer if not skipped (for when we want to parse data first)
      if (!skipInference) {
        inferItemFields(item);
      }
      
      return item;
    }
    
    function inferItemFields(item) {
      const inferredFields = [];
      
      // Don't infer slots - only use what's parsed from the page
      // If no slot was parsed, it remains null (displays as "None")
      
      // Only infer item type if not already set
      if (!item.item_type) {
        // Pass the item stats to detectItemType for data-driven detection
        const itemType = detectItemType(item.name, item.slot, item);
        if (itemType && itemType !== 'misc') {
          item.item_type = itemType;
          inferredFields.push('item_type');
        } else {
          item.item_type = 'misc';
        }
      }
      
      // Update icon only if it's still the default unknown icon
      if (item.icon_value === '') {
        const icon = getDefaultIcon(item.item_type, item.slot);
        item.icon_type = icon.type;
        item.icon_value = icon.value;
      }
      
      // Only infer weapon skill if not already set and it's a weapon
      if (!item.skill && item.item_type === 'weapon') {
        const skill = inferWeaponSkill(item.name, item.item_type);
        if (skill) {
          item.skill = skill;
          inferredFields.push('skill');
        }
      }
      
      // Only set defaults for race/class if they weren't parsed from data
      if (!item.race && (!item.parsedFields || !item.parsedFields.includes('race'))) {
        item.race = 'ALL';
      }
      if (!item.class && (!item.parsedFields || !item.parsedFields.includes('class'))) {
        item.class = 'ALL';
      }
      
      // Update the inferredFields array
      item.inferredFields = [...new Set([...item.inferredFields, ...inferredFields])];
    }
    
    async function processBatchImport() {
      const textarea = document.getElementById('batch-import-textarea');
      const lines = textarea.value.split('\n').filter(line => line.trim());
      
      if (lines.length === 0) {
        showMessage('No items to process', 'warning');
        return;
      }
      
      // Check if all lines are URLs
      // Supports multiple URLs - each URL becomes a root node in the inspector tree
      const isUrlData = lines.every(line => /^https?:\/\/.+/i.test(line.trim()));
      
      if (isUrlData) {
        // Process URLs - can be NPCs, item lists, or individual items
        await processUrlBatch(lines);
        return;
      }
      
      // Check if data is in table format (has tabs or multiple spaces)
      const hasTableData = lines.some(line => line.includes('\t') || line.includes('  '));
      
      // Check if this is single item data format (has colons like "Slot:" or "Class:")
      const isSingleItemData = lines.some(line => /^(Slot|Class|Race|Weapon\s+DMG|Weight|Size|STR|STA|AGI|DEX|WIS|INT|CHA|AC|HP|MANA):/i.test(line));
      
      let newItems = [];
      if (isSingleItemData) {
        // Parse as single item with properties
        const itemName = lines[0].trim(); // First line is the item name
        const item = createDefaultItem(itemName, batchImportItems.length, true); // Skip inference
        
        // Parse the item properties from the remaining lines
        parseItemDataString(lines.join('\n'), item);
        
        // Now infer any missing fields
        inferItemFields(item);
        
        newItems = [item];
        
        // Single item mode - add and clear
        batchImportItems = batchImportItems.concat(newItems);
        textarea.value = '';
        updateBatchImportCount();
        showMessage(`Added "${item.name}" to batch (${batchImportItems.length} total)`, 'success');
        
        // Show both steps for single item mode
        showSingleItemMode();
        
        // Render the table to show the new item
        renderBatchImportTable();
        updateBatchImportStatus();
        updateAccumulatedItemsTitle();
        return;
      } else if (hasTableData) {
        // Parse as table data
        newItems = parseTableData(lines);
      } else {
        // Check if this is a simple single item (just one line, no special formatting)
        const isSingleItem = lines.length === 1;
        
        // Process as simple list - use createDefaultItem for consistency
        newItems = lines.map((line, index) => {
          return createDefaultItem(line.trim(), batchImportItems.length + index);
        });
        
        // If single item, add to existing items and clear textarea
        if (isSingleItem) {
          batchImportItems = batchImportItems.concat(newItems);
          textarea.value = '';
          updateBatchImportCount();
          showMessage(`Added "${newItems[0].name}" to batch (${batchImportItems.length} total)`, 'success');
          
          // Show both steps for single item mode
          showSingleItemMode();
          
          // Render the table to show the new item
          renderBatchImportTable();
          updateBatchImportStatus();
          return;
        }
      }
      
      // Multiple items - add to existing batch
      batchImportItems = batchImportItems.concat(newItems);
      
      // Clear the textarea after adding items
      textarea.value = '';
      updateBatchImportCount();
      showMessage(`Added ${newItems.length} items to batch (${batchImportItems.length} total)`, 'success');
      
      // Check for duplicates
      const nameMap = {};
      batchImportItems.forEach(item => {
        if (nameMap[item.name.toLowerCase()]) {
          item.isDuplicate = true;
          nameMap[item.name.toLowerCase()].isDuplicate = true;
        } else {
          nameMap[item.name.toLowerCase()] = item;
        }
      });
      
      // Check against existing items and fetch their data
      try {
        const itemNames = batchImportItems.map(item => item.name);
        const response = await window.csrfHelper.fetchWithCSRF('/api/items/check-existing', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ names: itemNames })
        });
        
        if (response.ok) {
          const existingItems = await response.json();
          
          // Store existing item data and mark conflicts
          batchImportItems.forEach(item => {
            const existingItem = existingItems[item.name.toLowerCase()];
            if (existingItem) {
              item.existingData = existingItem;
              item.conflicts = detectConflicts(item, existingItem);
              if (item.conflicts.length > 0) {
                item.hasConflicts = true;
                item.hasNoChanges = false;
              } else {
                // Check if this is truly unchanged (exists but no conflicts)
                item.hasNoChanges = true;
                item.hasConflicts = false;
              }
            } else {
              item.hasNoChanges = false;
            }
          });
        }
      } catch (error) {
        console.error('Error checking existing items:', error);
      }
      
      // Show both steps for batch mode
      showBatchMode();
      
      // Render the table to show all items
      renderBatchImportTable();
      updateBatchImportStatus();
      updateAccumulatedItemsTitle();
    }
    
    function showSingleItemMode() {
      // Show both steps
      document.getElementById('batch-import-step1').style.display = 'block';
      document.getElementById('batch-import-items-step2').style.display = 'flex';
      
      // Adjust step 1 to be more compact
      const step1Div = document.getElementById('batch-import-step1');
      step1Div.style.padding = '20px';
      
      // Update step 2 header to indicate it's showing accumulated items
      updateAccumulatedItemsTitle();
      
      // Show finish button
      showSingleItemControls();
    }
    
    function updateAccumulatedItemsTitle() {
      const step2Title = document.querySelector('#batch-import-step2 h3');
      if (step2Title) {
        const itemCount = batchImportItems.length;
        step2Title.innerHTML = `Accumulated Items (${itemCount} item${itemCount !== 1 ? 's' : ''})`;
      }
    }
    
    function showBatchMode() {
      // Show both steps
      document.getElementById('batch-import-step1').style.display = 'block';
      document.getElementById('batch-import-items-step2').style.display = 'flex';
      
      // Adjust step 1 to be more compact
      const step1Div = document.getElementById('batch-import-step1');
      step1Div.style.padding = '20px';
      
      // Update step 2 header to indicate it's showing accumulated items
      updateAccumulatedItemsTitle();
      
      // Show batch mode controls
      showBatchModeControls();
    }
    
    function showSingleItemControls() {
      let controlsDiv = document.getElementById('single-item-controls');
      if (!controlsDiv) {
        controlsDiv = document.createElement('div');
        controlsDiv.id = 'single-item-controls';
        controlsDiv.style.cssText = 'margin-top: 1rem; display: flex; gap: 1rem; align-items: center; justify-content: space-between;';
        controlsDiv.innerHTML = `
          <div style="color: #999;">
            Continue adding items or click "Finish" when done
          </div>
          <div style="display: flex; gap: 1rem;">
            <button class="btn secondary-btn" onclick="clearBatchImport()">
              Clear All
            </button>
            <button class="btn primary-btn" onclick="finishSingleItemMode()">
              Finish Adding Items
            </button>
          </div>
        `;
        
        const step1Div = document.getElementById('batch-import-step1');
        const textarea = document.getElementById('batch-import-textarea');
        const textareaContainer = textarea.parentNode;
        textareaContainer.appendChild(controlsDiv);
      }
      
      controlsDiv.style.display = 'flex';
      
      // Hide batch controls if they exist
      const batchControlsDiv = document.getElementById('batch-mode-controls');
      if (batchControlsDiv) {
        batchControlsDiv.style.display = 'none';
      }
    }
    
    function showBatchModeControls() {
      // Hide single item controls if they exist
      const singleControlsDiv = document.getElementById('single-item-controls');
      if (singleControlsDiv) {
        singleControlsDiv.style.display = 'none';
      }
      
      let controlsDiv = document.getElementById('batch-mode-controls');
      if (!controlsDiv) {
        controlsDiv = document.createElement('div');
        controlsDiv.id = 'batch-mode-controls';
        controlsDiv.style.cssText = 'margin-top: 1rem; display: flex; gap: 1rem; align-items: center; justify-content: space-between;';
        controlsDiv.innerHTML = `
          <div style="color: #999;">
            Continue adding batch data or click "Finish" when done
          </div>
          <div style="display: flex; gap: 1rem;">
            <button class="btn secondary-btn" onclick="clearBatchImport()">
              Clear All
            </button>
            <button class="btn primary-btn" onclick="finishBatchMode()">
              Finish Adding Items
            </button>
          </div>
        `;
        
        const step1Div = document.getElementById('batch-import-step1');
        const textarea = document.getElementById('batch-import-textarea');
        const textareaContainer = textarea.parentNode;
        textareaContainer.appendChild(controlsDiv);
      }
      
      controlsDiv.style.display = 'flex';
    }
    
    function finishSingleItemMode() {
      // Hide step 1 and show only step 2 in full mode
      document.getElementById('batch-import-step1').style.display = 'none';
      document.getElementById('batch-import-step1').style.padding = '30px'; // Reset padding
      
      // Update step 2 title back to normal
      const step2Title = document.querySelector('#batch-import-step2 h3');
      if (step2Title) {
        step2Title.innerHTML = 'Step 2: Review and Edit Items';
      }
      
      // Initialize keyboard navigation if not already done
      if (window.batchCurrentRow === undefined || window.batchCurrentRow === -1) {
        window.batchCurrentRow = -1;
        window.batchCurrentCol = -1;
        initBatchTableKeyboardNav();
      }
    }
    
    function finishBatchMode() {
      // Hide step 1 and show only step 2 in full mode
      document.getElementById('batch-import-step1').style.display = 'none';
      document.getElementById('batch-import-step1').style.padding = '30px'; // Reset padding
      
      // Update step 2 title back to normal
      const step2Title = document.querySelector('#batch-import-step2 h3');
      if (step2Title) {
        step2Title.innerHTML = 'Step 2: Review and Edit Items';
      }
      
      // Initialize keyboard navigation if not already done
      if (window.batchCurrentRow === undefined || window.batchCurrentRow === -1) {
        window.batchCurrentRow = -1;
        window.batchCurrentCol = -1;
        initBatchTableKeyboardNav();
      }
    }
    
    async function proceedToStep2() {
      // Debug logging
      
      // Count non-excluded items
      const nonExcludedItems = batchImportItems.filter(item => !item.excluded);
      
      if (batchImportItems.length === 0) {
        showMessage('No items have been extracted yet', 'warning');
        return;
      }
      
      if (nonExcludedItems.length === 0 && batchImportItems.length > 0) {
        showMessage('No items to process (all items are excluded)', 'warning');
        return;
      }
      
      // Ensure the batch import modal is open
      const modal = document.getElementById('batch-import-modal');
      if (!modal || modal.style.display === 'none') {
        // Open the modal without clearing items since we have extractionCompleted flag set
        showBatchImportModal();
      }
      
      // Check against existing items and fetch their data
      try {
        const itemNames = batchImportItems.map(item => item.name);
        const response = await window.csrfHelper.fetchWithCSRF('/api/items/check-existing', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ names: itemNames })
        });
        
        if (response.ok) {
          const existingItems = await response.json();
          
          // Store existing item data and mark conflicts
          batchImportItems.forEach(item => {
            const existingItem = existingItems[item.name.toLowerCase()];
            if (existingItem) {
              item.existingData = existingItem;
              item.conflicts = detectConflicts(item, existingItem);
              if (item.conflicts.length > 0) {
                item.hasConflicts = true;
                item.hasNoChanges = false;
              } else {
                // Check if this is truly unchanged (exists but no conflicts)
                item.hasNoChanges = true;
                item.hasConflicts = false;
              }
            } else {
              item.hasNoChanges = false;
            }
          });
        }
      } catch (error) {
        console.error('Error checking existing items:', error);
      }
      
      // Switch to step 2
      document.getElementById('batch-import-step1').style.display = 'none';
      document.getElementById('batch-import-items-step2').style.display = 'flex';
      
      // Render the table
      renderBatchImportTable();
      updateBatchImportStatus();
      
      // Initialize keyboard navigation and position tracking
      window.batchCurrentRow = -1;
      window.batchCurrentCol = -1;
      initBatchTableKeyboardNav();
    }
    
    // Track current cell selection for keyboard navigation
    let currentBatchRow = -1;
    let currentBatchCol = -1;
    const batchTableFocusableColumns = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]; // Indices of editable columns
    
    function hasDirectData(item, field) {
      // Check if this field was populated from a direct data source
      if (!item.dataSource || item.dataSource === 'name-only') {
        return false;
      }
      
      // If we have a parsedFields array, use it (most accurate)
      if (item.parsedFields && Array.isArray(item.parsedFields)) {
        return item.parsedFields.includes(field);
      }
      
      // Fallback for table data - check if the field had a value in the table
      if (item.dataSource === 'table') {
        // These fields come from table data if they're not default values
        const numericFields = ['str', 'sta', 'agi', 'dex', 'wis', 'int', 'cha', 'ac', 'health', 'mana', 
                             'attack_speed', 'damage', 'delay', 'weight', 'block',
                             'resist_cold', 'resist_corruption', 'resist_disease', 'resist_electricity',
                             'resist_fire', 'resist_magic', 'resist_poison'];
        if (numericFields.includes(field)) {
          return item[field] !== 0;
        }
        if (field === 'size') return item.size !== 'Medium';
        if (field === 'race') return item.race !== null && item.race !== 'ALL';
        if (field === 'class') return item.class !== null && item.class !== 'ALL';
        if (field === 'item_type') return item.item_type !== null;
        if (field === 'slot') return item.slot !== null;
        if (field === 'skill') return item.skill !== null;
        if (field === 'description') return item.description !== '';
      }
      
      // Fallback for direct data (single item paste) or URL data
      if (item.dataSource === 'direct' || item.dataSource === 'url') {
        // All non-null/non-default values came from the data source
        const numericFields = ['str', 'sta', 'agi', 'dex', 'wis', 'int', 'cha', 'ac', 'health', 'mana', 
                             'attack_speed', 'damage', 'delay', 'weight', 'block',
                             'resist_cold', 'resist_corruption', 'resist_disease', 'resist_electricity',
                             'resist_fire', 'resist_magic', 'resist_poison'];
        if (numericFields.includes(field)) {
          return item[field] !== 0;
        }
        if (field === 'size') return item.size !== 'Medium';
        if (field === 'race') return item.race !== null && item.race !== 'ALL';
        if (field === 'class') return item.class !== null && item.class !== 'ALL';
        if (field === 'item_type') return item.item_type !== null;
        if (field === 'slot') return item.slot !== null;
        if (field === 'skill') return item.skill !== null;
        if (field === 'description') return item.description !== '';
      }
      
      return false;
    }
    
    function renderBatchImportTable() {
      const tbody = document.getElementById('batch-import-tbody');
      tbody.innerHTML = '';
      
      // Filter out excluded items before rendering
      const itemsToRender = batchImportItems.filter(item => !item.excluded);
      
      // Check for duplicate names among new items
      const nameCount = {};
      itemsToRender.forEach(item => {
        if (!item.existing) {
          const name = item.name || '';
          nameCount[name] = (nameCount[name] || 0) + 1;
        }
      });
      
      // Mark items with duplicate names
      itemsToRender.forEach(item => {
        if (!item.existing && nameCount[item.name] > 1) {
          item.isDuplicate = true;
        } else {
          item.isDuplicate = false;
        }
      });
      
      itemsToRender.forEach((item) => {
        // Get the original index from batchImportItems
        const index = batchImportItems.indexOf(item);
        const row = document.createElement('tr');
        if (item.hasNoChanges) {
          row.classList.add('unchanged-item');
        } else if (item.isDuplicate) {
          row.style.background = 'rgba(255, 193, 7, 0.1)';
        } else if (item.errors.length > 0) {
          row.style.background = 'rgba(244, 67, 54, 0.1)';
        }
        
        // Checkbox
        const checkCell = document.createElement('td');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = batchImportSelectedItems.has(item.tempId);
        checkbox.onchange = () => {
          if (checkbox.checked) {
            batchImportSelectedItems.add(item.tempId);
          } else {
            batchImportSelectedItems.delete(item.tempId);
          }
          updateBatchImportCount();
        };
        checkCell.appendChild(checkbox);
        row.appendChild(checkCell);
        
        // Icon
        const iconCell = document.createElement('td');
        iconCell.style.textAlign = 'center';
        iconCell.style.cursor = 'pointer';
        iconCell.innerHTML = item.icon_type === 'emoji' ? 
          `<span style="font-size: 1.5rem;">${item.icon_value}</span>` : 
          `<iconify-icon icon="${item.icon_value}" width="24"></iconify-icon>`;
        iconCell.onclick = () => showBatchItemIconPicker(index);
        iconCell.title = 'Click to change icon';
        row.appendChild(iconCell);
        
        // Name
        const nameCell = document.createElement('td');
        const nameWrapper = document.createElement('div');
        nameWrapper.style.display = 'flex';
        nameWrapper.style.alignItems = 'center';
        nameWrapper.style.gap = '5px';
        
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.value = item.name;
        nameInput.className = 'form-control';
        nameInput.style.flex = '1';
        nameInput.style.minWidth = '150px';
        nameInput.style.visibility = 'visible';
        nameInput.style.opacity = '1';
        if (item.isDuplicate) {
          nameInput.style.borderColor = '#FFC107';
        }
        if (item.existingData) {
          nameInput.style.borderColor = '#FFD700';
        }
        nameInput.oninput = () => {
          item.name = nameInput.value;
        };
        nameInput.onblur = () => {
          validateBatchItem(index);
        };
        nameInput.onfocus = (e) => {
          e.stopPropagation();
        };
        nameWrapper.appendChild(nameInput);
        
        // Add launch URL button
        const launchBtn = document.createElement('button');
        launchBtn.type = 'button';
        launchBtn.className = 'btn small-btn secondary-btn';
        launchBtn.innerHTML = '';
        launchBtn.title = 'Open item page in new tab';
        launchBtn.style.padding = '4px 8px';
        launchBtn.style.fontSize = '0.9rem';
        launchBtn.onclick = (e) => {
          e.stopPropagation();
          if (item.description && item.description.startsWith('http')) {
            window.open(item.description, '_blank');
          } else {
            showMessage('No URL available for this item', 'warning');
          }
        };
        nameWrapper.appendChild(launchBtn);
        
        // Add duplicate name indicator
        if (item.isDuplicate) {
          const duplicateBadge = document.createElement('span');
          duplicateBadge.className = 'duplicate-item-indicator';
          duplicateBadge.textContent = 'DUPLICATE';
          duplicateBadge.title = 'Multiple items have this name in the batch';
          duplicateBadge.style.cssText = 'background: #FFC107; color: #000; padding: 2px 6px; border-radius: 3px; font-size: 0.7rem; font-weight: bold; margin-left: 8px;';
          nameWrapper.appendChild(duplicateBadge);
        }
        
        // Add existing item indicator
        if (item.existingData) {
          if (item.hasNoChanges) {
            const unchangedBadge = document.createElement('span');
            unchangedBadge.className = 'unchanged-indicator';
            unchangedBadge.textContent = 'UNCHANGED';
            unchangedBadge.title = 'This item already exists in the database with no changes';
            nameWrapper.appendChild(unchangedBadge);
          } else {
            const existingBadge = document.createElement('span');
            existingBadge.className = 'existing-item-indicator';
            existingBadge.textContent = 'EXISTS';
            existingBadge.title = 'This item already exists in the database';
            
            // Add tooltip element
            const tooltip = document.createElement('span');
            tooltip.className = 'existing-item-warning';
            tooltip.textContent = 'This item will override the existing database entry';
            existingBadge.appendChild(tooltip);
            
            nameWrapper.appendChild(existingBadge);
          }
        }
        
        
        nameCell.appendChild(nameWrapper);
        
        if (item.errors.length > 0) {
          const errorDiv = document.createElement('div');
          errorDiv.className = 'batch-error-message';
          errorDiv.style.color = '#f44336';
          errorDiv.style.fontSize = '0.8rem';
          errorDiv.textContent = item.errors.join(', ');
          nameCell.appendChild(errorDiv);
        }
        row.appendChild(nameCell);
        
        // Type
        const typeCell = document.createElement('td');
        typeCell.style.position = 'relative';
        if (hasFieldConflict(item, 'item_type')) {
          typeCell.className = 'batch-import-cell has-conflict';
          typeCell.onclick = () => showConflictModal(item, 'item_type', index);
          typeCell.title = 'Click to resolve conflict';
        } else if (hasDirectData(item, 'item_type')) {
          typeCell.className = 'batch-import-direct';
          typeCell.title = 'From direct data source';
        } else if (item.inferredFields && item.inferredFields.includes('item_type')) {
          typeCell.className = 'batch-import-inferred';
          typeCell.title = 'Auto-detected from item name';
        }
        const typeSelect = createItemTypeSelect(item.item_type);
        typeSelect.onchange = () => {
          item.item_type = typeSelect.value;
          // Remove from inferred fields if manually changed
          if (item.inferredFields) {
            const idx = item.inferredFields.indexOf('item_type');
            if (idx > -1) item.inferredFields.splice(idx, 1);
          }
          // Update slot if type changed
          const newSlot = detectSlot(item.name, typeSelect.value);
          if (newSlot && !item.slot) {
            item.slot = newSlot;
            // Handle Primary/Secondary combo slot
            if (newSlot === 'Primary/Secondary') {
              item.slots = ['Primary', 'Secondary'];
            } else {
              item.slots = [newSlot];
            }
          }
          // Infer weapon skill if type changed to weapon and no skill set
          if (typeSelect.value === 'weapon' && !item.skill) {
            const inferredSkill = inferWeaponSkill(item.name, 'weapon');
            if (inferredSkill) {
              item.skill = inferredSkill;
              if (!item.inferredFields) item.inferredFields = [];
              if (!item.inferredFields.includes('skill')) {
                item.inferredFields.push('skill');
              }
            }
          }
          renderBatchImportTable();
        };
        typeCell.appendChild(typeSelect);
        row.appendChild(typeCell);
        
        // Slot
        const slotCell = createConflictCell(item, 'slot', index);
        slotCell.style.position = 'relative';
        if (!hasFieldConflict(item, 'slot')) {
          if (hasDirectData(item, 'slot')) {
            slotCell.className = 'batch-import-direct';
            slotCell.title = 'From direct data source';
          } else if (item.inferredFields && item.inferredFields.includes('slot')) {
            slotCell.className = 'batch-import-inferred';
            slotCell.title = 'Auto-detected from item name';
          }
        }
        const slotSelect = createSlotSelect(item.slot);
        slotSelect.onchange = () => {
          item.slot = slotSelect.value;
          // Handle Primary/Secondary combo slot
          if (slotSelect.value === 'Primary/Secondary') {
            item.slots = ['Primary', 'Secondary'];
          } else {
            item.slots = slotSelect.value ? [slotSelect.value] : [];
          }
          // Remove from inferred fields if manually changed
          if (item.inferredFields) {
            const idx = item.inferredFields.indexOf('slot');
            if (idx > -1) item.inferredFields.splice(idx, 1);
          }
          renderBatchImportTable();
        };
        slotCell.appendChild(slotSelect);
        row.appendChild(slotCell);
        
        // Size
        const sizeCell = createConflictCell(item, 'size', index);
        const sizeSelect = document.createElement('select');
        sizeSelect.className = 'form-control';
        ['Small', 'Medium', 'Large', 'Giant'].forEach(size => {
          const option = document.createElement('option');
          option.value = size;
          option.textContent = size;
          if (size === item.size) option.selected = true;
          sizeSelect.appendChild(option);
        });
        sizeSelect.onchange = () => item.size = sizeSelect.value;
        sizeCell.appendChild(sizeSelect);
        row.appendChild(sizeCell);
        
        // Weight
        const weightCell = createConflictCell(item, 'weight', index);
        const weightInput = document.createElement('input');
        weightInput.type = 'number';
        weightInput.value = item.weight;
        weightInput.className = 'form-control';
        weightInput.style.width = '100%';
        weightInput.min = '0';
        weightInput.step = '0.01';
        weightInput.onblur = () => item.weight = parseFloat(weightInput.value) || 0;
        weightCell.appendChild(weightInput);
        row.appendChild(weightCell);
        
        // Stats
        ['str', 'sta', 'agi', 'dex', 'wis', 'int', 'cha'].forEach(stat => {
          const statCell = createConflictCell(item, stat, index);
          const statInput = document.createElement('input');
          statInput.type = 'number';
          statInput.value = item[stat];
          statInput.className = 'form-control';
          statInput.style.width = '100%';
          statInput.style.textAlign = 'center';
          statInput.min = '-999';
          statInput.max = '999';
          statInput.onblur = () => item[stat] = parseInt(statInput.value) || 0;
          statCell.appendChild(statInput);
          row.appendChild(statCell);
        });
        
        // Resistances
        const resistCell = document.createElement('td');
        resistCell.className = 'batch-resist-col';
        resistCell.style.textAlign = 'center';
        resistCell.style.cursor = 'pointer';
        
        // Count total resistances
        const resistanceFields = ['resist_fire', 'resist_ice', 'resist_disease', 'resist_poison', 'resist_magic'];
        let resistanceCount = 0;
        resistanceFields.forEach(field => {
          if (item[field] && item[field] !== 0) {
            resistanceCount++;
          }
        });
        
        // Create resistance display
        const resistDisplay = document.createElement('div');
        resistDisplay.style.cssText = 'padding: 4px 8px; background: #2d2d2d; border: 1px solid #555; border-radius: 4px; min-height: 28px; display: flex; align-items: center; justify-content: center;';
        
        if (resistanceCount > 0) {
          resistDisplay.style.background = '#1a472a';
          resistDisplay.style.borderColor = '#2e7d32';
          resistDisplay.innerHTML = `<span style="color: #4caf50; font-weight: bold;">${resistanceCount}</span>`;
          resistDisplay.title = 'Click to edit resistances';
        } else {
          resistDisplay.innerHTML = '<span style="color: #666;">-</span>';
          resistDisplay.title = 'Click to add resistances';
        }
        
        resistDisplay.onclick = () => {
          openResistanceModal(item, resistDisplay, resistanceCount);
        };
        
        resistCell.appendChild(resistDisplay);
        row.appendChild(resistCell);
        
        // Advanced stats (hidden by default)
        ['ac', 'health', 'mana', 'attack_speed', 'damage', 'delay'].forEach(stat => {
          const statCell = createConflictCell(item, stat, index);
          statCell.classList.add('batch-advanced-col');
          statCell.style.display = document.getElementById('batch-import-show-advanced').checked ? 'table-cell' : 'none';
          const statInput = document.createElement('input');
          statInput.type = 'number';
          statInput.value = item[stat];
          statInput.className = 'form-control';
          statInput.style.width = '100%';
          statInput.style.textAlign = 'center';
          if (stat === 'attack_speed') {
            statInput.step = '0.1';
          }
          statInput.min = '0';
          statInput.onblur = () => item[stat] = parseFloat(statInput.value) || 0;
          statCell.appendChild(statInput);
          row.appendChild(statCell);
        });
        
        // Skill (hidden by default)
        const skillCell = createConflictCell(item, 'skill', index);
        skillCell.classList.add('batch-advanced-col');
        skillCell.style.display = document.getElementById('batch-import-show-advanced').checked ? 'table-cell' : 'none';
        skillCell.style.position = 'relative';
        if (!hasFieldConflict(item, 'skill')) {
          if (hasDirectData(item, 'skill')) {
            skillCell.className = 'batch-import-direct batch-advanced-col';
            skillCell.title = 'From direct data source';
          } else if (item.inferredFields && item.inferredFields.includes('skill')) {
            skillCell.className = 'batch-import-inferred batch-advanced-col';
            skillCell.title = 'Auto-detected weapon skill based on item name';
          }
        }
        const skillSelect = document.createElement('select');
        skillSelect.className = 'form-control';
        const skillOption = document.createElement('option');
        skillOption.value = '';
        skillOption.textContent = 'None';
        skillSelect.appendChild(skillOption);
        
        // Weapon skills - only show valid database skills for weapons
        if (item.item_type === 'weapon') {
          const weaponSkills = ['Slashing', 'Bludgeoning', 'Piercing', 'Archery', 'Throwing'];
          weaponSkills.forEach(skill => {
            const option = document.createElement('option');
            option.value = skill;
            option.textContent = skill;
            if (skill === item.skill) option.selected = true;
            skillSelect.appendChild(option);
          });
        } else {
          // For non-weapons, show all skills grouped
          const weaponGroup = document.createElement('optgroup');
          weaponGroup.label = 'Weapon Skills';
          const weaponSkills = ['Slashing', 'Bludgeoning', 'Piercing', 'Archery', 'Throwing'];
          weaponSkills.forEach(skill => {
            const option = document.createElement('option');
            option.value = skill;
            option.textContent = skill;
            if (skill === item.skill) option.selected = true;
            weaponGroup.appendChild(option);
          });
          skillSelect.appendChild(weaponGroup);
        }
        
        // Music skills group - only show for non-weapons
        if (item.item_type !== 'weapon') {
          const musicGroup = document.createElement('optgroup');
          musicGroup.label = 'Music Skills';
          const musicSkills = [
            'Brass', 'Percussion', 'Stringed', 'Wind', 'Singing'
          ];
          musicSkills.forEach(skill => {
            const option = document.createElement('option');
            option.value = skill;
            option.textContent = skill;
            if (skill === item.skill) option.selected = true;
            musicGroup.appendChild(option);
          });
          skillSelect.appendChild(musicGroup);
        }
        
        skillSelect.onchange = () => {
          item.skill = skillSelect.value || null;
          // Remove from inferred fields if manually changed
          if (item.inferredFields) {
            const idx = item.inferredFields.indexOf('skill');
            if (idx > -1) item.inferredFields.splice(idx, 1);
          }
          renderBatchImportTable();
        };
        skillCell.appendChild(skillSelect);
        row.appendChild(skillCell);
        
        // Race (hidden by default)
        const raceCell = createConflictCell(item, 'race', index);
        raceCell.classList.add('batch-advanced-col');
        raceCell.style.display = document.getElementById('batch-import-show-advanced').checked ? 'table-cell' : 'none';
        raceCell.style.position = 'relative';
        
        // Create display div for selected races
        const raceDisplay = document.createElement('div');
        raceDisplay.className = 'batch-race-display';
        raceDisplay.style.cssText = 'cursor: pointer; padding: 4px 8px; background: #2d2d2d; border: 1px solid #555; border-radius: 4px; min-height: 28px; font-size: 0.85rem; text-align: center;';
        
        // Display current selection
        const currentRaceValue = item.race || 'ALL';
        raceDisplay.textContent = formatRaceClassDisplay(currentRaceValue, 'race');
        raceDisplay.title = 'Click to select races';
        
        raceDisplay.onclick = () => {
          openRaceClassModal('race', item, raceDisplay);
        };
        
        raceCell.appendChild(raceDisplay);
        row.appendChild(raceCell);
        
        // Class (hidden by default)
        const classCell = createConflictCell(item, 'class', index);
        classCell.classList.add('batch-advanced-col');
        classCell.style.display = document.getElementById('batch-import-show-advanced').checked ? 'table-cell' : 'none';
        classCell.style.position = 'relative';
        
        // Create display div for selected classes
        const classDisplay = document.createElement('div');
        classDisplay.className = 'batch-class-display';
        classDisplay.style.cssText = 'cursor: pointer; padding: 4px 8px; background: #2d2d2d; border: 1px solid #555; border-radius: 4px; min-height: 28px; font-size: 0.85rem; text-align: center;';
        
        // Display current selection
        const currentClassValue = item.class || 'ALL';
        classDisplay.textContent = formatRaceClassDisplay(currentClassValue, 'class');
        classDisplay.title = 'Click to select classes';
        
        classDisplay.onclick = () => {
          openRaceClassModal('class', item, classDisplay);
        };
        
        classCell.appendChild(classDisplay);
        row.appendChild(classCell);
        
        // Description
        const descCell = createConflictCell(item, 'description', index);
        const descInput = document.createElement('textarea');
        descInput.value = item.description;
        descInput.className = 'form-control';
        descInput.style.width = '100%';
        descInput.style.minHeight = '40px';
        descInput.rows = 1;
        descInput.onblur = () => item.description = descInput.value;
        descCell.appendChild(descInput);
        row.appendChild(descCell);
        
        // Actions
        const actionCell = document.createElement('td');
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'btn btn-sm btn-danger';
        deleteBtn.innerHTML = '';
        deleteBtn.title = 'Remove item';
        deleteBtn.onclick = () => {
          batchImportItems.splice(index, 1);
          renderBatchImportTable();
          updateBatchImportStatus();
        };
        actionCell.appendChild(deleteBtn);
        row.appendChild(actionCell);
        
        tbody.appendChild(row);
      });
    }
    
    function createItemTypeSelect(selectedType) {
      const select = document.createElement('select');
      select.className = 'form-control';
      const types = ['weapon', 'armor', 'shield', 'accessory', 'consumable', 'container', 'tool', 'misc'];
      types.forEach(type => {
        const option = document.createElement('option');
        option.value = type;
        option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
        if (type === selectedType) option.selected = true;
        select.appendChild(option);
      });
      return select;
    }
    
    function createSlotSelect(selectedSlot) {
      const select = document.createElement('select');
      select.className = 'form-control';
      const option = document.createElement('option');
      option.value = '';
      option.textContent = 'None';
      select.appendChild(option);
      
      const slots = Object.keys(slotPatterns);
      slots.forEach(slot => {
        const option = document.createElement('option');
        option.value = slot;
        // Abbreviate Primary/Secondary as Pri/Sec in UI
        option.textContent = slot === 'Primary/Secondary' ? 'Pri/Sec' : slot;
        if (slot === selectedSlot) option.selected = true;
        select.appendChild(option);
      });
      return select;
    }
    
    function validateBatchItem(index) {
      const item = batchImportItems[index];
      item.errors = [];
      
      // Check for empty name
      if (!item.name.trim()) {
        item.errors.push('Name is required');
      }
      
      // Check for duplicates within batch
      const duplicates = batchImportItems.filter((i, idx) => 
        idx !== index && i.name.toLowerCase() === item.name.toLowerCase()
      );
      item.isDuplicate = duplicates.length > 0;
      
      // Removed check for existing items - we handle this during save
      
      // Update only the specific row instead of re-rendering entire table
      updateBatchItemRow(index);
      updateBatchImportStatus();
    }
    
    function updateBatchItemRow(index) {
      const tbody = document.getElementById('batch-import-tbody');
      const rows = tbody.querySelectorAll('tr');
      if (rows[index]) {
        const row = rows[index];
        const item = batchImportItems[index];
        
        // Update row styling
        if (item.errors.length > 0) {
          row.style.background = 'rgba(244, 67, 54, 0.1)';
        } else if (item.isDuplicate) {
          row.style.background = 'rgba(255, 193, 7, 0.1)';
        } else {
          row.style.background = '';
        }
        
        // Update name input styling and error message
        const nameCell = row.cells[2]; // Name is in column 2
        const nameInput = nameCell.querySelector('input');
        if (nameInput) {
          if (item.isDuplicate) {
            nameInput.style.borderColor = '#FFC107';
          } else {
            nameInput.style.borderColor = '';
          }
        }
        
        // Update or remove error div - use a class to identify it
        let errorDiv = nameCell.querySelector('.batch-error-message');
        if (item.errors.length > 0) {
          if (!errorDiv) {
            errorDiv = document.createElement('div');
            errorDiv.className = 'batch-error-message';
            errorDiv.style.color = '#f44336';
            errorDiv.style.fontSize = '0.8rem';
            nameCell.appendChild(errorDiv);
          }
          errorDiv.textContent = item.errors.join(', ');
        } else if (errorDiv) {
          errorDiv.remove();
        }
      }
    }
    
    function updateBatchImportStatus() {
      const validItems = batchImportItems.filter(item => 
        !item.excluded && item.errors.length === 0 && item.name.trim()
      );
      document.getElementById('batch-import-valid-count').textContent = validItems.length;
      document.getElementById('batch-insert-btn').disabled = validItems.length === 0;
    }
    
    function backToBatchStep1() {
      document.getElementById('batch-import-step1').style.display = 'block';
      document.getElementById('batch-import-items-step2').style.display = 'none';
    }
    
    function toggleBatchImportAdvanced() {
      const show = document.getElementById('batch-import-show-advanced').checked;
      const advancedCols = document.querySelectorAll('.batch-advanced-col');
      advancedCols.forEach(col => {
        col.style.display = show ? 'table-cell' : 'none';
      });
    }
    
    function toggleBatchImportSelectAll() {
      const selectAll = document.getElementById('batch-import-select-all').checked;
      batchImportSelectedItems.clear();
      if (selectAll) {
        batchImportItems.forEach(item => {
          // Only select non-excluded items
          if (!item.excluded) {
            batchImportSelectedItems.add(item.tempId);
          }
        });
      }
      renderBatchImportTable();
    }
    
    function applyBatchAction() {
      const field = document.getElementById('batch-action-type').value;
      const value = document.getElementById('batch-action-value').value;
      
      if (!field) {
        showMessage('Please select a field', 'warning');
        return;
      }
      
      // Determine which items to update
      const itemsToUpdate = batchImportSelectedItems.size > 0 
        ? batchImportItems.filter(item => batchImportSelectedItems.has(item.tempId))
        : batchImportItems;
      
      if (itemsToUpdate.length === 0) {
        showMessage('No items selected', 'warning');
        return;
      }
      
      // Apply the value to all items
      itemsToUpdate.forEach(item => {
        if (['str', 'sta', 'agi', 'dex', 'wis', 'int', 'cha', 'ac', 'health', 'mana', 'damage', 'delay'].includes(field)) {
          item[field] = parseInt(value) || 0;
        } else if (['weight', 'attack_speed'].includes(field)) {
          item[field] = parseFloat(value) || 0;
        } else if (field.startsWith('resist_')) {
          item[field] = parseInt(value) || 0;
        } else if (field === 'race') {
          item[field] = normalizeRaceClassString(value, 'race');
        } else if (field === 'class') {
          item[field] = normalizeRaceClassString(value, 'class');
        } else {
          item[field] = value;
        }
      });
      
      renderBatchImportTable();
      showMessage(`Updated ${itemsToUpdate.length} items`, 'success');
    }
    
    function purgeUnchangedItems() {
      // Count items before purge
      const unchangedItems = batchImportItems.filter(item => item.hasNoChanges);
      const unchangedCount = unchangedItems.length;
      
      if (unchangedCount === 0) {
        showMessage('No unchanged items to purge', 'info');
        return;
      }
      
      // Confirm purge
      if (!confirm(`Remove ${unchangedCount} unchanged item${unchangedCount > 1 ? 's' : ''} from the table?\n\nThese items already exist in the database with no changes.`)) {
        return;
      }
      
      // Remove unchanged items from the array
      batchImportItems = batchImportItems.filter(item => !item.hasNoChanges);
      
      // Clear selections for purged items
      unchangedItems.forEach(item => {
        batchImportSelectedItems.delete(item.tempId);
      });
      
      // Update the display
      renderBatchImportTable();
      updateBatchImportCount();
      updateBatchImportStatus();
      
      showMessage(`Removed ${unchangedCount} unchanged item${unchangedCount > 1 ? 's' : ''}`, 'success');
    }
    
    async function batchInsertItems() {
      const validItems = batchImportItems.filter(item => 
        !item.excluded && item.errors.length === 0 && item.name.trim() && !item.hasNoChanges
      );
      
      if (validItems.length === 0) {
        showMessage('No valid items to insert. All items are either invalid or unchanged.', 'warning');
        return;
      }
      
      // Separate new items from existing items
      const newItems = validItems.filter(item => !item.existingData);
      const existingItems = validItems.filter(item => item.existingData);
      const itemsWithConflicts = validItems.filter(item => item.hasConflicts && item.conflicts && item.conflicts.length > 0);
      const unchangedItems = batchImportItems.filter(item => !item.excluded && item.hasNoChanges);
      
      const message = [];
      if (newItems.length > 0) {
        message.push(`Insert ${newItems.length} new items`);
      }
      if (existingItems.length > 0) {
        message.push(`Update ${existingItems.length} existing items`);
      }
      if (unchangedItems.length > 0) {
        message.push(`\n\n ${unchangedItems.length} unchanged items will be skipped`);
      }
      if (itemsWithConflicts.length > 0) {
        message.push(`\n ${itemsWithConflicts.length} items have unresolved conflicts. New values will be used.`);
      }
      
      if (!confirm(message.join(' and ') + '?')) {
        return;
      }
      
      try {
        let totalInserted = 0;
        let totalUpdated = 0;
        
        // Handle new items
        if (newItems.length > 0) {
          // Remove duplicate names within the batch - keep only the first occurrence
          const seenNames = new Set();
          const deduplicatedItems = [];
          const removedDuplicates = [];
          
          newItems.forEach(item => {
            const name = (item.name || '').toLowerCase().trim();
            if (!seenNames.has(name)) {
              seenNames.add(name);
              deduplicatedItems.push(item);
            } else {
              removedDuplicates.push(item.name);
            }
          });
          
          // If duplicates were removed, inform the user
          if (removedDuplicates.length > 0) {
            showMessage(`Note: Removed ${removedDuplicates.length} duplicate items from the batch. Keeping first occurrence only.`, 'info');
            newItems.length = 0;
            newItems.push(...deduplicatedItems);
          }
          
          // Clean up items before sending - remove temporary fields and normalize data
          const cleanedItems = newItems.map(item => {
            // Create a clean copy without temporary fields
            const cleanItem = {
              name: (item.name || '').substring(0, 100), // DB limit is 100 chars
              icon_type: item.icon_type || 'emoji',
              icon_value: item.icon_value || '',
              str: parseInt(item.str) || 0,
              sta: parseInt(item.sta) || 0,
              agi: parseInt(item.agi) || 0,
              dex: parseInt(item.dex) || 0,
              wis: parseInt(item.wis) || 0,
              int: parseInt(item.int) || 0,
              cha: parseInt(item.cha) || 0,
              attack_speed: parseFloat(item.attack_speed) || 0,
              health: parseInt(item.health) || 0,
              mana: parseInt(item.mana) || 0,
              ac: parseInt(item.ac) || 0,
              block: parseInt(item.block) || 0,
              resist_cold: parseInt(item.resist_cold) || 0,
              resist_corruption: parseInt(item.resist_corruption) || 0,
              resist_disease: parseInt(item.resist_disease) || 0,
              resist_electricity: parseInt(item.resist_electricity) || 0,
              resist_fire: parseInt(item.resist_fire) || 0,
              resist_magic: parseInt(item.resist_magic) || 0,
              resist_poison: parseInt(item.resist_poison) || 0,
              weight: parseFloat(item.weight) || 0.0,
              size: (item.size || 'Medium').substring(0, 50),
              skill: item.skill ? item.skill.substring(0, 50) : null,
              damage: parseInt(item.damage) || 0,
              delay: parseInt(item.delay) || 0,
              item_type: (item.item_type || 'misc').substring(0, 50),
              slot: item.slot ? item.slot.substring(0, 50) : null,
              slots: item.slots || [],
              description: (item.description || '').substring(0, 1000), // Allow longer descriptions but cap at 1000
              race: (item.race === 'ALL' || !item.race) ? null : (item.race || '').substring(0, 255),
              class: (item.class === 'ALL' || !item.class) ? null : (item.class || '').substring(0, 255)
            };
            
            // Log a warning if we had to truncate
            if (item.name && item.name.length > 100) {
              console.warn(`Item name "${item.name}" was truncated from ${item.name.length} to 100 characters`);
            }
            if (item.description && item.description.length > 1000) {
              console.warn(`Description for "${item.name}" was truncated from ${item.description.length} to 1000 characters`);
            }
            if (item.race && item.race.length > 255) {
              console.warn(`Race field for "${item.name}" was truncated from ${item.race.length} to 255 characters`);
            }
            if (item.class && item.class.length > 255) {
              console.warn(`Class field for "${item.name}" was truncated from ${item.class.length} to 255 characters`);
            }
            
            return cleanItem;
          });
          
          
          let response;
          try {
            response = await window.csrfHelper.fetchWithCSRF('/api/items/batch', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({ items: cleanedItems })
            });
          } catch (fetchError) {
            console.error('Failed to fetch batch insert endpoint:', fetchError);
            throw new Error(`Network error: ${fetchError.message}`);
          }
        
          if (!response.ok) {
            let errorData;
            try {
              errorData = await response.json();
            } catch (parseError) {
              errorData = { error: `HTTP ${response.status}: ${response.statusText}` };
            }
            
            console.error('Batch insert failed:', {
              status: response.status,
              statusText: response.statusText,
              errorData: errorData,
              url: response.url
            });
            
            // Check for specific error types
            if (response.status === 403) {
              throw new Error('Admin access required. Please ensure you are logged in as an admin.');
            } else if (response.status === 401) {
              throw new Error('Authentication required. Please log in again.');
            } else if (response.status === 400 && errorData.existing) {
              // Items already exist
              console.error('Items already exist:', errorData.existing);
              throw new Error(`Some items already exist: ${errorData.existing.join(', ')}`);
            }
            
            // Log detailed error information if available
            if (errorData.details) {
              console.error('Error details:', errorData.details);
              // Show each detail error to the user
              if (Array.isArray(errorData.details)) {
                errorData.details.forEach(detail => {
                  showMessage(detail, 'error');
                });
              }
            }
            
            throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);
          }
          
          let result;
          try {
            result = await response.json();
          } catch (jsonError) {
            console.error('Failed to parse response JSON:', jsonError);
            const responseText = await response.text();
            console.error('Response text:', responseText);
            throw new Error('Invalid response from server');
          }
          
          totalInserted = result.inserted || 0;
          
          // Log individual inserted items if available
          if (result.items && result.items.length > 0) {
          }
          
          // Check if we actually inserted the expected number
          if (totalInserted !== newItems.length) {
            console.warn(`Expected to insert ${newItems.length} items but only inserted ${totalInserted}`);
            if (result.errors && result.errors.length > 0) {
              console.error('Insert errors:', result.errors);
              // Show specific errors to user
              result.errors.forEach(err => {
                showMessage(`Error: ${err}`, 'error');
              });
            }
          }
        }
        
        // Handle existing items (updates)
        if (existingItems.length > 0) {
          
          // Update items one by one
          for (const item of existingItems) {
            try {
              const updateResponse = await window.csrfHelper.fetchWithCSRF(`/api/items/${item.existingData.id}`, {
                method: 'PUT',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify(item)
              });
              
              if (updateResponse.ok) {
                totalUpdated++;
              } else {
                console.error(`Failed to update item ${item.name}:`, await updateResponse.text());
              }
            } catch (error) {
              console.error(`Error updating item ${item.name}:`, error);
            }
          }
        }
        
        // Show appropriate message based on results
        const messages = [];
        if (totalInserted > 0) {
          messages.push(`Inserted ${totalInserted} items`);
        }
        if (totalUpdated > 0) {
          messages.push(`Updated ${totalUpdated} items`);
        }
        
        if (messages.length > 0) {
          showMessage(messages.join(' and '), 'success');
          
          // Only close modal and refresh if we actually saved something
          // Force close without confirmation since items were successfully saved
          batchImportItems = []; // Clear items to bypass confirmation
          closeBatchImportModal();
          
          // Refresh the item list to show new items
          try {
            await loadItemEditor();
          } catch (refreshError) {
            console.error('Failed to refresh item list:', refreshError);
            // Don't throw - the save was successful even if refresh failed
          }
        } else {
          showMessage('No items were saved. Check the console for errors.', 'warning');
        }
        
      } catch (error) {
        console.error('Batch insert error:', error);
        
        // Check if it's a network error
        if (error.message.includes('Failed to fetch') || error.message.includes('Network')) {
          showMessage('Network error: Please check your connection and try again', 'error');
        } else {
          showMessage(`Error: ${error.message}`, 'error');
        }
        
        // Log the full error stack for debugging
        console.error('Full error stack:', error.stack);
      }
    }
    
    function showBatchItemIconPicker(index) {
      // This would show an icon picker modal
      // For now, just cycle through some default icons
      const item = batchImportItems[index];
      const icons = ['', '', '', '', '', '', '', '', '', ''];
      const currentIndex = icons.indexOf(item.icon_value);
      const nextIndex = (currentIndex + 1) % icons.length;
      item.icon_value = icons[nextIndex];
      renderBatchImportTable();
    }
    
    function cycleIconForBatchItem(rowIndex, forward = true) {
      if (rowIndex < 0 || rowIndex >= batchImportItems.length) return;
      
      const item = batchImportItems[rowIndex];
      const icons = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''];
      
      const currentIndex = icons.indexOf(item.icon_value);
      let nextIndex;
      
      if (forward) {
        nextIndex = currentIndex === -1 ? 0 : (currentIndex + 1) % icons.length;
      } else {
        nextIndex = currentIndex === -1 ? icons.length - 1 : (currentIndex - 1 + icons.length) % icons.length;
      }
      
      item.icon_value = icons[nextIndex];
      
      // Update only the icon cell instead of re-rendering entire table
      const tbody = document.getElementById('batch-import-tbody');
      const row = tbody.querySelectorAll('tr')[rowIndex];
      if (row) {
        const iconCell = row.querySelectorAll('td')[1]; // Icon is column 1
        if (iconCell) {
          iconCell.innerHTML = `<span style="font-size: 1.5rem;">${icons[nextIndex]}</span>`;
          // Keep focus on the icon cell
          iconCell.setAttribute('tabindex', '0');
          iconCell.focus();
        }
      }
    }
    
    function cycleDropdownOption(dropdown, forward = true) {
      if (!dropdown || dropdown.tagName !== 'SELECT') return;
      
      const options = Array.from(dropdown.options);
      const currentIndex = dropdown.selectedIndex;
      let newIndex;
      
      if (forward) {
        newIndex = (currentIndex + 1) % options.length;
      } else {
        newIndex = (currentIndex - 1 + options.length) % options.length;
      }
      
      dropdown.selectedIndex = newIndex;
      
      // Trigger change event to update the data
      const changeEvent = new Event('change', { bubbles: true });
      dropdown.dispatchEvent(changeEvent);
      
      // Keep focus on the dropdown
      dropdown.focus();
    }
    
    function revertBatchFieldValue(rowIndex, colIndex, input) {
      if (rowIndex < 0 || rowIndex >= batchImportItems.length) return;
      
      const item = batchImportItems[rowIndex];
      let originalValue = '';
      
      // Determine the field based on column index
      switch(colIndex) {
        case 2: // Name
          originalValue = item.name;
          break;
        case 3: // Type
          originalValue = item.item_type;
          break;
        case 4: // Slot
          originalValue = item.slot;
          break;
        case 5: // Size
          originalValue = item.size;
          break;
        case 6: // Weight
          originalValue = item.weight;
          break;
        case 7: // STR
          originalValue = item.str;
          break;
        case 8: // STA
          originalValue = item.sta;
          break;
        case 9: // AGI
          originalValue = item.agi;
          break;
        case 10: // DEX
          originalValue = item.dex;
          break;
        case 11: // WIS
          originalValue = item.wis;
          break;
        case 12: // INT
          originalValue = item.int;
          break;
        case 13: // CHA
          originalValue = item.cha;
          break;
        case 14: // AC (if advanced fields shown)
          originalValue = item.ac;
          break;
        case 15: // Health
          originalValue = item.health;
          break;
        case 16: // Mana
          originalValue = item.mana;
          break;
        case 17: // Attack Speed
          originalValue = item.attack_speed;
          break;
        case 18: // Damage
          originalValue = item.damage;
          break;
        case 19: // Delay
          originalValue = item.delay;
          break;
        case 20: // Skill
          originalValue = item.skill || '';
          break;
        case 21: // Description (when advanced not shown) or description when advanced is shown
          originalValue = item.description;
          break;
      }
      
      // Revert the input value
      if (input.tagName === 'SELECT') {
        // For select elements, we need to set the value
        input.value = originalValue;
      } else {
        // For text/number inputs and textareas
        input.value = originalValue;
      }
      
      // Blur the input to trigger any validation
      input.blur();
      
      // Flash the field to indicate reversion
      const originalBorder = input.style.border;
      const originalBackground = input.style.background;
      input.style.border = '2px solid #ffa500';
      input.style.background = 'rgba(255, 165, 0, 0.1)';
      
      setTimeout(() => {
        input.style.border = originalBorder;
        input.style.background = originalBackground;
      }, 300);
    }
    
    // Global flag to track if number slider is open
    let isNumberSliderOpen = false;
    
    function showNumberSlider(input, rowIndex, colIndex) {
      // Set flag to prevent table navigation
      isNumberSliderOpen = true;
      
      // Store original value
      const originalValue = parseFloat(input.value) || 0;
      let currentValue = originalValue;
      
      // Determine min/max and step based on field type
      let min = parseFloat(input.min) || -999;
      let max = parseFloat(input.max) || 999;
      let step = parseFloat(input.step) || 1;
      
      // Special handling for weight and attack speed (decimal fields)
      if (colIndex === 6) { // Weight
        step = 0.1;
        min = 0;
        max = 100;
      } else if (colIndex === 17) { // Attack Speed
        step = 0.1;
        min = 0;
        max = 10;
      }
      
      // Create slider container
      const sliderContainer = document.createElement('div');
      sliderContainer.style.cssText = `
        position: absolute;
        background: #2d2d2d;
        border: 2px solid #FFD700;
        border-radius: 8px;
        padding: 15px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.8);
        z-index: 10001;
        min-width: 250px;
      `;
      
      // Create slider HTML
      sliderContainer.innerHTML = `
        <div style="text-align: center; margin-bottom: 10px;">
          <div style="color: #FFD700; font-size: 0.9rem; margin-bottom: 5px;">Adjust Value</div>
          <div id="slider-value" style="font-size: 1.5rem; font-weight: bold; color: #e0e0e0;">${currentValue}</div>
        </div>
        <div style="position: relative; height: 40px; display: flex; align-items: center;">
          <input type="range" id="number-slider" 
            min="${min}" max="${max}" step="${step}" value="${currentValue}"
            style="
              width: 100%;
              height: 6px;
              background: #555;
              outline: none;
              opacity: 0.9;
              transition: opacity 0.2s;
              cursor: pointer;
            ">
        </div>
        <div style="display: flex; justify-content: space-between; margin-top: 5px; font-size: 0.8rem; color: #999;">
          <span>${min}</span>
          <span>${max}</span>
        </div>
        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #444;">
          <div style="font-size: 0.8rem; color: #FFD700; margin-bottom: 6px; text-align: center;">Keyboard Controls</div>
          <div style="display: grid; grid-template-columns: auto 1fr; gap: 4px 12px; font-size: 0.75rem; color: #999;">
            <span style="text-align: right; color: #ccc;"> </span>
            <span>${step < 1 ? '1.0' : 'Adjust value'}</span>
            <span style="text-align: right; color: #ccc;">Shift +  </span>
            <span>10</span>
            ${step < 1 ? `<span style="text-align: right; color: #ccc;">Ctrl +  </span>
            <span>0.1</span>` : ''}
            <span style="text-align: right; color: #ccc;">Space</span>
            <span>Reset to 0</span>
            <span style="text-align: right; color: #ccc;">Enter</span>
            <span>Confirm</span>
            <span style="text-align: right; color: #ccc;">Esc</span>
            <span>Cancel</span>
          </div>
        </div>
      `;
      
      // Position the slider
      const rect = input.getBoundingClientRect();
      sliderContainer.style.left = Math.max(10, rect.left - 50) + 'px';
      sliderContainer.style.top = (rect.bottom + 5) + 'px';
      
      // Add custom slider styles
      const styleSheet = document.createElement('style');
      styleSheet.textContent = `
        #number-slider::-webkit-slider-thumb {
          appearance: none;
          width: 20px;
          height: 20px;
          background: #FFD700;
          cursor: pointer;
          border-radius: 50%;
          box-shadow: 0 2px 4px rgba(0,0,0,0.4);
        }
        #number-slider::-moz-range-thumb {
          width: 20px;
          height: 20px;
          background: #FFD700;
          cursor: pointer;
          border-radius: 50%;
          border: none;
          box-shadow: 0 2px 4px rgba(0,0,0,0.4);
        }
        #number-slider:hover {
          opacity: 1 !important;
        }
      `;
      document.head.appendChild(styleSheet);
      
      document.body.appendChild(sliderContainer);
      
      const slider = document.getElementById('number-slider');
      const valueDisplay = document.getElementById('slider-value');
      
      // Update display when slider changes
      slider.oninput = () => {
        currentValue = parseFloat(slider.value);
        valueDisplay.textContent = currentValue;
        // Update input value in real-time
        input.value = currentValue;
      };
      
      // Focus the slider
      slider.focus();
      
      // Acceleration variables
      let accelerationTimer = null;
      let accelerationStartTime = 0;
      let currentDirection = null;
      let accelerationInterval = null;
      
      // Function to calculate current speed multiplier based on hold duration
      const getSpeedMultiplier = (holdDuration) => {
        // Progressive acceleration curve
        if (holdDuration < 500) return 1;        // First 0.5s: normal speed
        if (holdDuration < 1000) return 2;       // 0.5-1s: 2x speed
        if (holdDuration < 1500) return 5;       // 1-1.5s: 5x speed
        if (holdDuration < 2000) return 10;      // 1.5-2s: 10x speed
        return 20;                                // 2s+: 20x speed (cap)
      };
      
      // Function to update value with acceleration
      const updateValueWithAcceleration = (direction, isShiftPressed = false, isCtrlPressed = false) => {
        let adjustedStep;
        
        // Determine step based on modifiers
        if (isCtrlPressed && step < 1) {
          // Ctrl for decimal fields: use 0.1 (no acceleration)
          adjustedStep = 0.1;
        } else if (isShiftPressed) {
          // Shift: use fixed step of 10 (no acceleration)
          adjustedStep = 10;
        } else if (step < 1) {
          // For decimal fields without modifiers: base step is 1.0 with acceleration
          const holdDuration = Date.now() - accelerationStartTime;
          const speedMultiplier = getSpeedMultiplier(holdDuration);
          adjustedStep = 1.0 * speedMultiplier;
        } else {
          // For integer fields: use normal step with acceleration
          const holdDuration = Date.now() - accelerationStartTime;
          const speedMultiplier = getSpeedMultiplier(holdDuration);
          adjustedStep = step * speedMultiplier;
        }
        
        if (direction === 'left') {
          currentValue = Math.max(min, currentValue - adjustedStep);
        } else if (direction === 'right') {
          currentValue = Math.min(max, currentValue + adjustedStep);
        } else if (direction === 'up') {
          // Up/down arrows use 10x the left/right adjustment
          currentValue = Math.min(max, currentValue + (adjustedStep * 10));
        } else if (direction === 'down') {
          currentValue = Math.max(min, currentValue - (adjustedStep * 10));
        }
        
        // Round to appropriate decimal places based on the step size
        const decimalPlaces = step.toString().split('.')[1]?.length || 0;
        if (decimalPlaces > 0) {
          // For decimal fields, maintain decimal precision even with Shift
          currentValue = parseFloat(currentValue.toFixed(decimalPlaces));
        } else {
          // For integer fields, round to whole numbers
          currentValue = Math.round(currentValue);
        }
        
        slider.value = currentValue;
        valueDisplay.textContent = currentValue;
        input.value = currentValue;
      };
      
      // Track if shift or ctrl is currently pressed
      let isShiftPressed = false;
      let isCtrlPressed = false;
      
      // Start acceleration timer
      const startAcceleration = (direction) => {
        currentDirection = direction;
        
        // Reset acceleration timer when starting, so switching between
        // shift and non-shift modes starts fresh
        accelerationStartTime = Date.now();
        
        // Initial update
        updateValueWithAcceleration(direction, isShiftPressed, isCtrlPressed);
        
        // Clear any existing interval
        if (accelerationInterval) {
          clearInterval(accelerationInterval);
        }
        
        // For Shift and Ctrl modifiers, don't start interval (single increment only)
        if (!isShiftPressed && !isCtrlPressed) {
          // Start repeating updates only for normal mode (with acceleration)
          accelerationInterval = setInterval(() => {
            updateValueWithAcceleration(direction, isShiftPressed, isCtrlPressed);
          }, 50); // Update every 50ms for smooth changes
        }
      };
      
      // Stop acceleration
      const stopAcceleration = () => {
        if (accelerationInterval) {
          clearInterval(accelerationInterval);
          accelerationInterval = null;
        }
        currentDirection = null;
        accelerationStartTime = 0;
      };
      
      // Handle keyboard navigation
      const handleSliderKeys = (e) => {
        // Track modifier key states
        if (e.key === 'Shift') {
          isShiftPressed = e.type === 'keydown';
          return;
        }
        if (e.key === 'Control') {
          isCtrlPressed = e.type === 'keydown';
          return;
        }
        
        // Handle all arrow keys, Enter, Escape, and Space
        if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', 'Enter', 'Escape', ' '].includes(e.key)) {
          e.preventDefault();
          e.stopPropagation();
          e.stopImmediatePropagation(); // Stop event from bubbling to table navigation
        }
        
        switch(e.key) {
          case 'ArrowLeft':
            if (e.type === 'keydown') {
              if (!currentDirection || currentDirection !== 'left') {
                startAcceleration('left');
              }
            }
            break;
            
          case 'ArrowRight':
            if (e.type === 'keydown') {
              if (!currentDirection || currentDirection !== 'right') {
                startAcceleration('right');
              }
            }
            break;
            
          case 'ArrowUp':
            if (e.type === 'keydown') {
              if (!currentDirection || currentDirection !== 'up') {
                startAcceleration('up');
              }
            }
            break;
            
          case 'ArrowDown':
            if (e.type === 'keydown') {
              if (!currentDirection || currentDirection !== 'down') {
                startAcceleration('down');
              }
            }
            break;
            
          case 'Enter':
            // Confirm the value
            stopAcceleration();
            input.value = currentValue;
            // Update the batch item data
            if (rowIndex >= 0 && rowIndex < batchImportItems.length) {
              const item = batchImportItems[rowIndex];
              const fieldMap = {
                6: 'weight', 7: 'str', 8: 'sta', 9: 'agi', 10: 'dex',
                11: 'wis', 12: 'int', 13: 'cha', 14: 'ac', 15: 'health',
                16: 'mana', 17: 'attack_speed', 18: 'damage', 19: 'delay'
              };
              const field = fieldMap[colIndex];
              if (field) {
                item[field] = currentValue;
              }
            }
            cleanup();
            // Trigger blur to run validation
            input.blur();
            // Refocus the input
            setTimeout(() => input.focus(), 10);
            break;
            
          case 'Escape':
            // Cancel and revert
            stopAcceleration();
            input.value = originalValue;
            cleanup();
            input.focus();
            break;
            
          case ' ': // Space bar
            // Reset to 0
            stopAcceleration();
            currentValue = 0;
            slider.value = currentValue;
            valueDisplay.textContent = currentValue;
            input.value = currentValue;
            // Add a brief flash effect to indicate reset
            valueDisplay.style.color = '#FFD700';
            setTimeout(() => {
              valueDisplay.style.color = '#e0e0e0';
            }, 200);
            break;
            
          default:
            return; // Don't prevent default for other keys
        }
      };
      
      // Handle key up to stop acceleration
      const handleSliderKeyUp = (e) => {
        // Track modifier key releases
        if (e.key === 'Shift') {
          isShiftPressed = false;
        }
        if (e.key === 'Control') {
          isCtrlPressed = false;
        }
        
        if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
          e.preventDefault();
          e.stopPropagation();
          stopAcceleration();
        }
      };
      
      // Cleanup function
      const cleanup = () => {
        isNumberSliderOpen = false;
        isShiftPressed = false; // Reset shift state
        isCtrlPressed = false; // Reset ctrl state
        stopAcceleration();
        document.removeEventListener('keydown', handleSliderKeys, true);
        document.removeEventListener('keyup', handleSliderKeyUp, true);
        sliderContainer.remove();
        styleSheet.remove();
      };
      
      // Add event listeners with capture to intercept before table navigation
      document.addEventListener('keydown', handleSliderKeys, true);
      document.addEventListener('keyup', handleSliderKeyUp, true);
      
      // Close on click outside
      setTimeout(() => {
        const handleClickOutside = (e) => {
          if (!sliderContainer.contains(e.target) && e.target !== input) {
            input.value = currentValue;
            cleanup();
            document.removeEventListener('click', handleClickOutside);
          }
        };
        document.addEventListener('click', handleClickOutside);
      }, 100);
    }
    
    function deleteSelectedBatchRow() {
      const currentRow = window.batchCurrentRow;
      if (currentRow === undefined || currentRow === -1 || currentRow >= batchImportItems.length) {
        showMessage('No row selected', 'warning');
        return;
      }
      
      const item = batchImportItems[currentRow];
      
      // Create custom confirmation dialog
      const confirmDialog = document.createElement('div');
      confirmDialog.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #2d2d2d;
        border: 2px solid #dc3545;
        border-radius: 8px;
        padding: 20px;
        z-index: 10001;
        box-shadow: 0 4px 20px rgba(0,0,0,0.8);
        min-width: 300px;
      `;
      
      confirmDialog.innerHTML = `
        <h3 style="margin: 0 0 1rem 0; color: #dc3545;">Delete Item?</h3>
        <p style="margin: 0 0 1.5rem 0; color: #e0e0e0;">
          Are you sure you want to delete "<strong>${item.name || 'Unnamed Item'}</strong>"?
        </p>
        <div style="display: flex; gap: 10px; justify-content: flex-end;">
          <button id="confirm-delete-btn" style="
            background: #dc3545;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            outline: 2px solid #FFD700;
            outline-offset: 2px;
            box-shadow: 0 0 0 3px rgba(255, 215, 0, 0.3);
          ">Delete</button>
          <button id="cancel-delete-btn" style="
            background: #555;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
          ">Cancel</button>
        </div>
      `;
      
      // Create backdrop
      const backdrop = document.createElement('div');
      backdrop.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.5);
        z-index: 10000;
      `;
      
      document.body.appendChild(backdrop);
      document.body.appendChild(confirmDialog);
      
      // Focus on cancel button by default
      const cancelBtn = document.getElementById('cancel-delete-btn');
      const confirmBtn = document.getElementById('confirm-delete-btn');
      cancelBtn.focus();
      
      // Add hover and focus styles to buttons
      confirmBtn.onmouseover = () => {
        confirmBtn.style.background = '#b91c1c';
        confirmBtn.style.transform = 'scale(1.05)';
      };
      confirmBtn.onmouseout = () => {
        confirmBtn.style.background = '#dc3545';
        confirmBtn.style.transform = 'scale(1)';
      };
      confirmBtn.onfocus = () => {
        confirmBtn.style.outline = '2px solid #FFD700';
        confirmBtn.style.outlineOffset = '2px';
        confirmBtn.style.boxShadow = '0 0 0 3px rgba(255, 215, 0, 0.3)';
      };
      confirmBtn.onblur = () => {
        confirmBtn.style.outline = 'none';
        confirmBtn.style.boxShadow = 'none';
      };
      
      cancelBtn.onmouseover = () => {
        cancelBtn.style.background = '#666';
      };
      cancelBtn.onmouseout = () => {
        cancelBtn.style.background = '#555';
      };
      cancelBtn.onfocus = () => {
        cancelBtn.style.outline = '2px solid #FFD700';
        cancelBtn.style.outlineOffset = '2px';
      };
      cancelBtn.onblur = () => {
        cancelBtn.style.outline = 'none';
      };
      
      // Handle button clicks
      const cleanup = () => {
        confirmDialog.remove();
        backdrop.remove();
        // Restore focus to the table
        focusBatchCell(window.batchCurrentRow, window.batchCurrentCol);
      };
      
      cancelBtn.onclick = cleanup;
      confirmBtn.onclick = () => {
        // Remove the item
        batchImportItems.splice(currentRow, 1);
        
        // Update navigation position
        if (batchImportItems.length === 0) {
          window.batchCurrentRow = -1;
          window.batchCurrentCol = -1;
        } else if (currentRow >= batchImportItems.length) {
          window.batchCurrentRow = batchImportItems.length - 1;
        }
        
        // Re-render table and update status
        renderBatchImportTable();
        updateBatchImportStatus();
        
        // Cleanup dialog
        cleanup();
        
        showMessage('Item deleted', 'info');
      };
      
      // Handle keyboard events in the confirmation dialog
      const handleDialogKeys = (e) => {
        if (e.key === 'Escape') {
          e.preventDefault();
          cleanup();
          document.removeEventListener('keydown', handleDialogKeys);
        } else if (e.key === 'Enter') {
          e.preventDefault();
          confirmBtn.click();
          document.removeEventListener('keydown', handleDialogKeys);
        }
      };
      document.addEventListener('keydown', handleDialogKeys);
    }
    
    // Keyboard navigation for batch import table
    function initBatchTableKeyboardNav() {
      const modal = document.getElementById('batch-import-modal');
      if (!modal) return;
      
      // Remove any existing listeners from both modal and document
      modal.removeEventListener('keydown', handleBatchTableKeyNav);
      document.removeEventListener('keydown', handleBatchTableKeyNav);
      
      // Add keyboard event listener to document for global capture
      document.addEventListener('keydown', handleBatchTableKeyNav);
    }
    
    function trapFocusInModal(e) {
      const modal = document.getElementById('batch-import-modal');
      const focusableElements = modal.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );
      const focusableArray = Array.from(focusableElements).filter(el => 
        !el.disabled && el.offsetParent !== null
      );
      
      if (focusableArray.length === 0) return;
      
      const firstFocusable = focusableArray[0];
      const lastFocusable = focusableArray[focusableArray.length - 1];
      
      // Handle Tab key for focus trapping
      if (e.key === 'Tab') {
        if (e.shiftKey) {
          // Shift + Tab
          if (document.activeElement === firstFocusable) {
            e.preventDefault();
            lastFocusable.focus();
          }
        } else {
          // Tab
          if (document.activeElement === lastFocusable) {
            e.preventDefault();
            firstFocusable.focus();
          }
        }
      }
      
      // Handle Escape key to close modal
      if (e.key === 'Escape') {
        e.preventDefault();
        closeBatchImportModal();
      }
    }
    
    function handleBatchTableKeyNav(e) {
      // Check if batch modal is open and in step 2
      const modal = document.getElementById('batch-import-modal');
      if (!modal || modal.style.display === 'none') return;
      if (document.getElementById('batch-import-items-step2').style.display === 'none') return;
      
      // Don't handle navigation if number slider is open
      if (isNumberSliderOpen) return;
      
      // Handle escape key
      if (e.key === 'Escape') {
        e.preventDefault();
        
        // Check if we're editing a field
        const activeElement = document.activeElement;
        if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.tagName === 'SELECT')) {
          // Find which item and field we're editing
          const tbody = document.getElementById('batch-import-tbody');
          const rows = tbody.querySelectorAll('tr');
          
          for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
            const cells = rows[rowIndex].querySelectorAll('td');
            for (let colIndex = 0; colIndex < cells.length; colIndex++) {
              const input = cells[colIndex].querySelector('input:not([type="checkbox"]), select, textarea');
              if (input === activeElement) {
                // Revert the field value
                revertBatchFieldValue(rowIndex, colIndex, input);
                return;
              }
            }
          }
        }
        
        // If not editing a field, close the modal
        closeBatchImportModal();
        return;
      }
      
      // Handle Ctrl+Delete to delete selected row
      if (e.ctrlKey && (e.key === 'Delete' || e.key === 'Del')) {
        e.preventDefault();
        deleteSelectedBatchRow();
        return;
      }
      
      // Handle arrow keys, tab, and enter
      if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Tab', 'Enter'].includes(e.key)) {
        return;
      }
      
      const tbody = document.getElementById('batch-import-tbody');
      if (!tbody) return;
      
      const rows = tbody.querySelectorAll('tr');
      if (rows.length === 0) return;
      
      // Get current position - prefer stored values
      let currentRow = window.batchCurrentRow;
      let currentCol = window.batchCurrentCol;
      
      // If no stored position, find from active element
      if (currentRow === undefined || currentRow === -1) {
        const activeElement = document.activeElement;
        let found = false;
        
        for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
          const cells = rows[rowIndex].querySelectorAll('td');
          for (let colIndex = 0; colIndex < cells.length; colIndex++) {
            // Check if the cell itself is focused (for icon column)
            if (cells[colIndex] === activeElement) {
              currentRow = rowIndex;
              currentCol = colIndex;
              found = true;
              break;
            }
            const input = cells[colIndex].querySelector('input:not([type="checkbox"]), select, textarea');
            if (input === activeElement) {
              currentRow = rowIndex;
              currentCol = colIndex;
              found = true;
              break;
            }
          }
          if (found) break;
        }
        
        // If still no position, start at first cell
        if (!found) {
          currentRow = 0;
          currentCol = 2; // First editable column (Name)
        }
      }
      
      // Special handling for Tab key in icon and dropdown columns
      if (e.key === 'Tab' && currentRow >= 0 && currentCol >= 0) {
        const cell = rows[currentRow].querySelectorAll('td')[currentCol];
        
        // Icon column (column 1)
        if (currentCol === 1 && cell === document.activeElement) {
          e.preventDefault();
          cycleIconForBatchItem(currentRow, !e.shiftKey);
          return;
        }
        
        // Dropdown columns (type, slot, size, skill)
        const dropdown = cell?.querySelector('select');
        if (dropdown && dropdown === document.activeElement) {
          e.preventDefault();
          cycleDropdownOption(dropdown, !e.shiftKey);
          return;
        }
      }
      
      // Prevent default for arrow keys to stop scrolling
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
        e.preventDefault();
      }
      
      // Handle navigation
      switch(e.key) {
        case 'ArrowUp':
          if (currentRow > 0) {
            focusBatchCell(currentRow - 1, currentCol);
          }
          break;
          
        case 'ArrowDown':
          if (currentRow < rows.length - 1) {
            focusBatchCell(currentRow + 1, currentCol);
          }
          break;
          
        case 'ArrowLeft':
          // Find previous editable column
          for (let col = currentCol - 1; col >= 0; col--) {
            if (isEditableColumn(col)) {
              focusBatchCell(currentRow, col);
              break;
            }
          }
          break;
          
        case 'ArrowRight':
          // Find next editable column
          const maxCol = rows[currentRow].querySelectorAll('td').length - 1;
          for (let col = currentCol + 1; col <= maxCol; col++) {
            if (isEditableColumn(col)) {
              focusBatchCell(currentRow, col);
              break;
            }
          }
          break;
          
        case 'Tab':
          // Only handle if we're in the table and not handled above
          if (currentRow >= 0 && currentCol >= 0) {
            e.preventDefault();
            navigateToNextCell(currentRow, currentCol, !e.shiftKey);
          }
          break;
          
        case 'Enter':
          // Check if we're in a numeric field
          const currentCell = rows[currentRow]?.querySelectorAll('td')[currentCol];
          const currentInput = currentCell?.querySelector('input[type="number"]');
          
          if (currentInput && document.activeElement === currentInput) {
            // Show number slider for numeric fields
            e.preventDefault();
            showNumberSlider(currentInput, currentRow, currentCol);
          } else {
            // Move to next row, same column
            if (currentRow >= 0 && currentRow < rows.length - 1) {
              e.preventDefault();
              focusBatchCell(currentRow + 1, currentCol);
            }
          }
          break;
      }
    }
    
    function isEditableColumn(col) {
      // Columns that have editable content
      // 0: checkbox (not editable)
      // 1: icon (NOW EDITABLE via keyboard)
      // 2: name
      // 3: type
      // 4: slot
      // 5: size
      // 6: weight
      // 7-13: stats (STR, STA, AGI, DEX, WIS, INT, CHA)
      // 14-19: advanced stats (AC, HP, MP, AS, DMG, Delay) - may be hidden
      // 20: skill - may be hidden
      // 21: description
      // 22: actions (not editable)
      
      // Check if we're showing advanced fields
      const showAdvanced = document.getElementById('batch-import-show-advanced')?.checked;
      
      if (col === 0) return false; // Only checkbox is not editable
      if (col >= 1 && col <= 13) return true; // Icon and always visible fields
      if (showAdvanced && col >= 14 && col <= 21) return true; // Advanced fields
      if (!showAdvanced && col === 21) return true; // Description when advanced is hidden
      
      return false;
    }
    
    function focusBatchCell(row, col) {
      const tbody = document.getElementById('batch-import-tbody');
      const rows = tbody.querySelectorAll('tr');
      
      if (row < 0 || row >= rows.length) return;
      
      const targetRow = rows[row];
      const cells = targetRow.querySelectorAll('td');
      
      // Ensure the column exists
      if (col < 0 || col >= cells.length) return;
      
      // If the column is not editable, find the nearest editable column
      if (!isEditableColumn(col)) {
        // Try to find the nearest editable column
        for (let i = 1; i <= cells.length - 1; i++) {
          if (isEditableColumn(i)) {
            col = i;
            break;
          }
        }
      }
      
      const cell = cells[col];
      
      // Store current position globally BEFORE focusing
      window.batchCurrentRow = row;
      window.batchCurrentCol = col;
      
      // Highlight the cell and row BEFORE focusing
      highlightBatchCell(row, col);
      
      // Special handling for icon column
      if (col === 1) {
        // Focus on the icon cell itself
        cell.setAttribute('tabindex', '0');
        cell.focus();
        return;
      }
      
      const input = cell.querySelector('input:not([type="checkbox"]), select, textarea');
      
      if (input) {
        // Focus and select text
        input.focus();
        
        // Select all text in the input
        if (input.type === 'text' || input.type === 'number' || input.tagName === 'TEXTAREA') {
          input.select();
        }
      }
    }
    
    function navigateToNextCell(currentRow, currentCol, forward = true) {
      const tbody = document.getElementById('batch-import-tbody');
      const rows = tbody.querySelectorAll('tr');
      const totalRows = rows.length;
      
      if (totalRows === 0) return;
      
      let newRow = currentRow;
      let newCol = currentCol;
      
      if (forward) {
        // Find next editable column
        newCol++;
        while (newRow < totalRows) {
          const maxCol = rows[newRow].querySelectorAll('td').length - 1;
          
          while (newCol <= maxCol) {
            if (isEditableColumn(newCol)) {
              focusBatchCell(newRow, newCol);
              return;
            }
            newCol++;
          }
          
          // Move to next row
          newRow++;
          newCol = 2; // Start from first editable column
        }
      } else {
        // Find previous editable column
        newCol--;
        while (newRow >= 0) {
          while (newCol >= 0) {
            if (isEditableColumn(newCol)) {
              focusBatchCell(newRow, newCol);
              return;
            }
            newCol--;
          }
          
          // Move to previous row
          newRow--;
          if (newRow >= 0) {
            newCol = rows[newRow].querySelectorAll('td').length - 2; // Start from last editable column
          }
        }
      }
    }
    
    function highlightBatchCell(row, col) {
      // Remove all existing highlights
      const allCells = document.querySelectorAll('#batch-import-tbody td');
      allCells.forEach(cell => cell.classList.remove('batch-cell-focused'));
      
      const allRows = document.querySelectorAll('#batch-import-tbody tr');
      allRows.forEach(r => r.classList.remove('batch-row-highlighted'));
      
      const tbody = document.getElementById('batch-import-tbody');
      const rows = tbody.querySelectorAll('tr');
      
      // Add row highlight
      if (rows[row]) {
        rows[row].classList.add('batch-row-highlighted');
        
        // Add cell highlight
        const cells = rows[row].querySelectorAll('td');
        if (cells[col]) {
          cells[col].classList.add('batch-cell-focused');
        }
      }
    }
    
    // Add event listener for textarea
    document.addEventListener('DOMContentLoaded', () => {
      const textarea = document.getElementById('batch-import-textarea');
      if (textarea) {
        textarea.addEventListener('input', updateBatchImportCount);
        textarea.addEventListener('paste', () => {
          setTimeout(updateBatchImportCount, 10);
        });
      }
    });
    
    // Item Data Import Modal Functions
    function showItemDataImportModal(itemIndex) {
      const item = batchImportItems[itemIndex];
      if (!item) return;
      
      // Create modal if it doesn't exist
      let modal = document.getElementById('item-data-import-modal');
      if (!modal) {
        modal = document.createElement('div');
        modal.id = 'item-data-import-modal';
        modal.className = 'modal';
        modal.style.display = 'none';
        modal.innerHTML = `
          <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
              <h2>Import Item Data - <span id="import-item-name"></span></h2>
              <button class="close-btn" onclick="closeItemDataImportModal()">&times;</button>
            </div>
            <div class="modal-body">
              <div style="margin-bottom: 1rem;">
                <label for="item-data-textarea">Paste item data here:</label>
                <textarea id="item-data-textarea" class="form-control" 
                  style="min-height: 200px; font-family: monospace; font-size: 0.9rem;"
                  placeholder="Example:
Rusty Axe

Slot: PRIMARY SECONDARY
Class: BST FTR INQ PAL RNG SHD SPB
Race: ALL

Weapon DMG: 5   ATK Delay: 35    Skill: SLA
Weight: 6.0
Size: Medium"></textarea>
              </div>
              <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                <button class="btn secondary-btn" onclick="closeItemDataImportModal()">Cancel</button>
                <button class="btn primary-btn" onclick="parseAndApplyItemData()">Import Data</button>
              </div>
            </div>
          </div>
        `;
        document.body.appendChild(modal);
      }
      
      // Set item name and index
      document.getElementById('import-item-name').textContent = item.name;
      modal.setAttribute('data-item-index', itemIndex);
      modal.style.display = 'block';
      
      // Focus textarea
      setTimeout(() => {
        document.getElementById('item-data-textarea').focus();
      }, 100);
    }
    
    function closeItemDataImportModal() {
      const modal = document.getElementById('item-data-import-modal');
      if (modal) {
        modal.style.display = 'none';
        document.getElementById('item-data-textarea').value = '';
      }
    }
    
    function parseAndApplyItemData() {
      const modal = document.getElementById('item-data-import-modal');
      const itemIndex = parseInt(modal.getAttribute('data-item-index'));
      const item = batchImportItems[itemIndex];
      if (!item) return;
      
      const textarea = document.getElementById('item-data-textarea');
      const data = textarea.value.trim();
      if (!data) {
        showMessage('No data to import', 'error');
        return;
      }
      
      try {
        parseItemDataString(data, item);
        renderBatchImportTable();
        closeItemDataImportModal();
        showMessage('Item data imported successfully', 'success');
      } catch (error) {
        showMessage('Failed to parse item data: ' + error.message, 'error');
      }
    }
    
    function parseWikiItemData(html, url) {
      // Debug logging for Wyrmsbane
      const isWyrmsbane = url.includes('Wyrmsbane_Lieutenant');
      if (isWyrmsbane) {
      }
      
      // Parse item data from wiki HTML page
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
      
      // Get item name from h1
      const h1 = doc.querySelector('h1');
      if (!h1) {
        return null;
      }
      
      const itemName = h1.textContent.trim();
      
      // Check if this is actually an item page (not quest, NPC, etc)
      const pageText = doc.body ? doc.body.textContent : '';
      const pageTextLower = pageText.toLowerCase();
      
      // Skip quest pages
      if (pageTextLower.includes('quest giver') || pageTextLower.includes('quest type') || 
          pageTextLower.includes('start zone') || pageTextLower.includes('quest text')) {
        return null;
      }
      
      // Skip NPC pages
      if ((pageTextLower.includes('level:') && pageTextLower.includes('race:') && 
           (pageTextLower.includes('health:') || pageTextLower.includes('damage per hit:'))) ||
          pageTextLower.includes('spawn location') || pageTextLower.includes('respawn time')) {
        return null;
      }
      
      // Create item with defaults
      const item = createDefaultItem(itemName, Date.now(), true); // Skip inference initially
      
      // Look for item-details div which contains all item data
      const itemDetailsDiv = doc.querySelector('.item-details');
      let itemDataText = '';
      
      if (itemDetailsDiv) {
        // Get all text from the item-details div
        itemDataText = itemDetailsDiv.textContent.trim();
      } else {
        // Fallback to pre blocks if item-details div not found
        const preBlocks = doc.querySelectorAll('pre, code');
        for (const pre of preBlocks) {
          const preText = pre.textContent;
          // Look for item stats pattern
          if (preText.match(/Slot:\s*\w+/i) || preText.match(/Class:\s*\w+/i) || 
              preText.match(/Weapon\s+DMG:\s*\d+/i)) {
            itemDataText = preText;
            break;
          }
        }
      }
      
      if (isWyrmsbane) {
        if (itemDataText) {
        }
      }
      
      // Also look for data in tables that are within item-details div if it exists
      const tablesToSearch = itemDetailsDiv ? itemDetailsDiv.querySelectorAll('table') : doc.querySelectorAll('table');
      for (const table of tablesToSearch) {
        const rows = table.querySelectorAll('tr');
        for (const row of rows) {
          const cells = row.querySelectorAll('td, th');
          if (cells.length >= 2) {
            const label = cells[0].textContent.trim().toLowerCase();
            const value = cells[1].textContent.trim().replace(/\n+/g, ' ');
            
            // Map common labels to item properties
            if (label.includes('slot')) {
              // Append to itemDataText
              itemDataText += `\nSlot: ${value}`;
            } else if (label.includes('class')) {
              itemDataText += `\nClass: ${value}`;
            } else if (label.includes('race')) {
              itemDataText += `\nRace: ${value}`;
            } else if (label.includes('damage')) {
              itemDataText += `\nDamage: ${value}`;
            } else if (label.includes('delay')) {
              itemDataText += `\nDelay: ${value}`;
            } else if (label.includes('weight')) {
              itemDataText += `\nWeight: ${value}`;
            } else if (label.includes('size')) {
              itemDataText += `\nSize: ${value}`;
            }
            // Stats
            else if (label === 'str' || label.includes('strength')) {
              itemDataText += `\nSTR: ${value}`;
            } else if (label === 'sta' || label.includes('stamina')) {
              itemDataText += `\nSTA: ${value}`;
            } else if (label === 'agi' || label.includes('agility')) {
              itemDataText += `\nAGI: ${value}`;
            } else if (label === 'dex' || label.includes('dexterity')) {
              itemDataText += `\nDEX: ${value}`;
            } else if (label === 'wis' || label.includes('wisdom')) {
              itemDataText += `\nWIS: ${value}`;
            } else if (label === 'int' || label.includes('intelligence')) {
              itemDataText += `\nINT: ${value}`;
            } else if (label === 'cha' || label.includes('charisma')) {
              itemDataText += `\nCHA: ${value}`;
            } else if (label === 'ac' || label.includes('armor class')) {
              itemDataText += `\nAC: ${value}`;
            } else if (label === 'hp' || label.includes('health') || label.includes('hit points')) {
              itemDataText += `\nHP: ${value}`;
            } else if (label.includes('mana')) {
              itemDataText += `\nMANA: ${value}`;
            }
          }
        }
      }
      
      // Use item-details content if available, otherwise use full page text
      const fullText = itemDetailsDiv ? itemDetailsDiv.textContent : pageText;
      // For parsing patterns, prefer item-details content when available
      const textToSearch = itemDetailsDiv ? itemDetailsDiv.textContent : pageText;
      
      // Look for weapon damage pattern if not already found
      if (!itemDataText.includes('Weapon DMG:')) {
        const weaponDmgMatch = textToSearch.match(/Weapon\s+DMG:\s*(\d+)\s+ATK\s+Delay:\s*(\d+)(?:\s+Skill:\s*(\w+))?/i);
        if (weaponDmgMatch) {
          itemDataText += `\nWeapon DMG: ${weaponDmgMatch[1]} ATK Delay: ${weaponDmgMatch[2]}`;
          if (weaponDmgMatch[3]) {
            itemDataText += ` Skill: ${weaponDmgMatch[3]}`;
          }
        }
      }
      
      // Look for class/race patterns with valid codes
      // Complete list of valid class abbreviations
      const validClasses = [
        'ARC', // Archer
        'WAR', // Warrior
        'PAL', // Paladin
        'RNG', // Ranger
        'ROG', // Rogue
        'CLR', // Cleric
        'DRU', // Druid
        'SHA', // Shaman (old)
        'SHM', // Shaman (new)
        'WIZ', // Wizard
        'NEC', // Necromancer
        'ENC', // Enchanter
        'MAG', // Magician
        'MNK', // Monk
        'BRD', // Bard
        'BST', // Beastlord
        'FTR', // Fighter
        'INQ', // Inquisitor
        'SHD', // Shadow Knight
        'SPB', // Spellblade
        'ELE', // Elementalist
        'ALL'  // All classes
      ];
      const validRaces = ['HUM', 'ELF', 'DEF', 'HEF', 'DWF', 'HFL', 'GNM', 'OGR', 'TRL', 'BAR', 'ALL'];
      
      // Always check for multi-line class values and normalize them
      const classMatch = textToSearch.match(/Class:\s*([\s\S]*?)(?=\s*(?:Race:|Slot:|Weight:|Size:|$))/i);
      if (classMatch) {
        // Extract all valid class codes from the raw text
        const validClasses = ['ARC', 'WAR', 'PAL', 'RNG', 'ROG', 'CLR', 'DRU', 'SHA', 'SHM', 'WIZ', 'NEC', 'ENC', 'MAG', 'MNK', 'BRD', 'BST', 'FTR', 'INQ', 'SHD', 'SPB', 'ELE', 'ALL'];
        const classText = classMatch[1];
        const foundClasses = [];
        
        // Search for each class code in the text, being more flexible with spacing and newlines
        validClasses.forEach(classCode => {
          // Look for the class code with various spacing/line break patterns
          const patterns = [
            new RegExp('\\b' + classCode + '\\b', 'i'),           // Standard word boundary
            new RegExp(classCode + '(?=\\s|\\n|$)', 'i'),          // At end of line or followed by space/newline
            new RegExp('(?<=\\s|^|\\n)' + classCode + '(?=\\s|\\n|$)', 'i')  // Surrounded by whitespace/newlines
          ];
          
          for (const pattern of patterns) {
            try {
              if (pattern.test(classText)) {
                foundClasses.push(classCode);
                break; // Only add once
              }
            } catch (e) {
              // Fallback for browsers that don't support lookbehind
              if (classText.toUpperCase().includes(classCode)) {
                foundClasses.push(classCode);
                break;
              }
            }
          }
        });
        
        if (foundClasses.length > 0) {
          const classString = foundClasses.join(' ');
          
          // Replace any existing Class: line in itemDataText or add new one
          if (itemDataText.includes('Class:')) {
            // Replace existing multi-line class with normalized single-line version
            itemDataText = itemDataText.replace(/Class:\s*[\s\S]*?(?=\n(?:Race:|Slot:|Weight:|Size:|DMG:|$))/i, `Class: ${classString}`);
          } else {
            itemDataText += `\nClass: ${classString}`;
          }
        }
      }
      
      if (!itemDataText.includes('Race:')) {
        // Handle multi-line race values
        const raceMatch = textToSearch.match(/Race:\s*([\s\S]*?)(?=\s*(?:Class:|Slot:|Weight:|Size:|$))/i);
        if (raceMatch) {
          // Extract all valid race codes
          const validRaces = ['HUM', 'ELF', 'DEF', 'HEF', 'DWF', 'HFL', 'GNM', 'OGR', 'TRL', 'BAR', 'ALL'];
          const raceText = raceMatch[1];
          const foundRaces = [];
          
          // Find all valid race codes in the text
          validRaces.forEach(raceCode => {
            if (raceText.toUpperCase().includes(raceCode)) {
              foundRaces.push(raceCode);
            }
          });
          
          if (foundRaces.length > 0) {
            itemDataText += `\nRace: ${foundRaces.join(' ')}`;
          }
        }
      }
      
      // Look for slot pattern with better detection
      if (!itemDataText.includes('Slot:')) {
        // Only look for slot if there's actually a Slot: label
        const slotMatch = textToSearch.match(/Slot:\s*([^\n]*?)(?=\s*(?:Class:|Race:|Weight:|Size:|$))/i);
        if (slotMatch) {
          const slotValue = slotMatch[1].trim();
          // Only add slot if it's not empty and has actual content
          if (slotValue && slotValue.length > 0 && !slotValue.toLowerCase().includes('none')) {
            itemDataText += `\nSlot: ${slotValue}`;
          }
        }
      }
      
      // Look for weight/size patterns
      if (!itemDataText.includes('Weight:')) {
        const weightMatch = textToSearch.match(/Weight:\s*([\d.]+)/i);
        if (weightMatch) {
          itemDataText += `\nWeight: ${weightMatch[1]}`;
        }
      }
      
      if (!itemDataText.includes('Size:')) {
        const sizeMatch = textToSearch.match(/Size:\s*(\w+)/i);
        if (sizeMatch) {
          itemDataText += `\nSize: ${sizeMatch[1]}`;
        }
      }
      
      // Look for stats patterns if not found in pre blocks (with or without colons)
      const statPatterns = {
        'STR': /STR(?::)?\s*([+-]?\d+)/i,
        'STA': /STA(?::)?\s*([+-]?\d+)/i,
        'AGI': /AGI(?::)?\s*([+-]?\d+)/i,
        'DEX': /DEX(?::)?\s*([+-]?\d+)/i,
        'WIS': /WIS(?::)?\s*([+-]?\d+)/i,
        'INT': /INT(?::)?\s*([+-]?\d+)/i,
        'CHA': /CHA(?::)?\s*([+-]?\d+)/i,
        'AC': /AC(?::)?\s*([+-]?\d+)/i,
        'HP': /HP(?::)?\s*([+-]?\d+)/i,
        'MANA': /MANA(?::)?\s*([+-]?\d+)/i
      };
      
      for (const [stat, pattern] of Object.entries(statPatterns)) {
        if (!itemDataText.includes(`${stat}:`)) {
          const match = textToSearch.match(pattern);
          if (match) {
            itemDataText += `\n${stat}: ${match[1]}`;
          }
        }
      }
      
      // Look for resistance patterns
      const resistPatterns = {
        'SV Magic': /SV\s+Magic(?::)?\s*([+-]?\d+)/i,
        'SV Fire': /SV\s+Fire(?::)?\s*([+-]?\d+)/i,
        'SV Cold': /SV\s+Cold(?::)?\s*([+-]?\d+)/i,
        'SV Poison': /SV\s+Poison(?::)?\s*([+-]?\d+)/i,
        'SV Disease': /SV\s+Disease(?::)?\s*([+-]?\d+)/i,
        'SV Electricity': /SV\s+Electricity(?::)?\s*([+-]?\d+)/i,
        'SV Corruption': /SV\s+Corruption(?::)?\s*([+-]?\d+)/i
      };
      
      for (const [resist, pattern] of Object.entries(resistPatterns)) {
        const match = textToSearch.match(pattern);
        if (match) {
          itemDataText += `\n${resist}: ${match[1]}`;
        }
      }
      
      // If we found item data, parse it
      if (itemDataText) {
        parseItemDataString(itemDataText, item);
      }
      
      // Infer any missing fields
      inferItemFields(item);
      
      // Debug logging for Wyrmsbane
      if (isWyrmsbane) {
      }
      
      return item;
    }
    
    function parseItemDataString(dataString, item) {
      const lines = dataString.split('\n').map(line => line.trim()).filter(line => line);
      
      // Mark that this item has direct data source
      item.dataSource = 'direct';
      item.parsedFields = []; // Track which fields were parsed from data
      
      for (const line of lines) {
        // Skip empty lines and item name
        if (!line || line === item.name) continue;
        
        // Parse slot
        if (line.match(/^Slot:\s*/i)) {
          const slotValue = line.replace(/^Slot:\s*/i, '').trim();
          
          // Handle two-handed weapons or multiple slots
          if (slotValue.match(/PRIMARY\s+SECONDARY/i)) {
            item.slot = 'Primary/Secondary';
            item.slots = ['Primary', 'Secondary'];
          } else if (slotValue.match(/PRIMARY/i)) {
            item.slot = 'Primary';
            item.slots = ['Primary'];
          } else if (slotValue.match(/SECONDARY/i)) {
            item.slot = 'Secondary';
            item.slots = ['Secondary'];
          } else if (slotValue.match(/RANGE/i)) {
            item.slot = 'Range';
            item.slots = ['Range'];
          } else {
            // Try to match specific slot names directly
            const slotNameLower = slotValue.toLowerCase();
            
            // Map common slot names to our expected values
            const slotMap = {
              'head': 'Head',
              'face': 'Face',
              'ears': 'Ears',
              'ear': 'Ears',
              'neck': 'Neck',
              'shoulders': 'Shoulders',
              'shoulder': 'Shoulders',
              'arms': 'Arms',
              'arm': 'Arms',
              'back': 'Back',
              'wrist': 'Wrist1',
              'wrists': 'Wrist1',
              'wrist1': 'Wrist1',
              'wrist2': 'Wrist2',
              'hands': 'Hands',
              'hand': 'Hands',
              'finger': 'Finger1',
              'finger1': 'Finger1',
              'finger2': 'Finger2',
              'chest': 'Chest',
              'body': 'Chest',
              'torso': 'Chest',
              'legs': 'Legs',
              'leg': 'Legs',
              'feet': 'Feet',
              'foot': 'Feet',
              'waist': 'Waist',
              'belt': 'Waist',
              'ammo': 'Ammo',
              'container': 'Container1',
              'container1': 'Container1',
              'container2': 'Container2',
              'container3': 'Container3',
              'container4': 'Container4',
              'container5': 'Container5',
              'container6': 'Container6'
            };
            
            const mappedSlot = slotMap[slotNameLower];
            if (mappedSlot) {
              item.slot = mappedSlot;
              item.slots = [mappedSlot];
            } else {
              // Use the value as-is if no mapping found
              item.slot = slotValue;
              item.slots = [slotValue];
            }
          }
          if (item.parsedFields) item.parsedFields.push('slot');
          continue;
        }
        
        // Parse class
        if (line.match(/^Class:\s*/i)) {
          const classValue = line.replace(/^Class:\s*/i, '').trim();
          item.class = classValue;
          if (item.parsedFields) item.parsedFields.push('class');
          continue;
        }
        
        // Parse race
        if (line.match(/^Race:\s*/i)) {
          const raceValue = line.replace(/^Race:\s*/i, '').trim();
          item.race = raceValue;
          if (item.parsedFields) item.parsedFields.push('race');
          continue;
        }
        
        // Parse weapon damage, delay, skill
        if (line.match(/Weapon\s+DMG:/i)) {
          const dmgMatch = line.match(/DMG:\s*(\d+)/i);
          if (dmgMatch) {
            item.damage = parseInt(dmgMatch[1]);
            if (item.parsedFields) item.parsedFields.push('damage');
          }
          
          const delayMatch = line.match(/ATK\s+Delay:\s*(\d+)/i);
          if (delayMatch) {
            item.delay = parseInt(delayMatch[1]);
            if (item.parsedFields) item.parsedFields.push('delay');
          }
          
          const skillMatch = line.match(/Skill:\s*(\w+)/i);
          if (skillMatch) {
            const skillMap = {
              'SLA': 'Slashing',
              '2HS': 'Slashing',
              '1HS': 'Slashing',
              '1HB': 'Bludgeoning',
              '2HB': 'Bludgeoning',
              'BLD': 'Bludgeoning',
              'BLG': 'Bludgeoning',
              'BLU': 'Bludgeoning',
              'PIE': 'Piercing',
              'STA': 'Piercing',  // STA = Piercing (for now)
              '2HP': 'Piercing',
              '1HP': 'Piercing',
              'ARC': 'Archery',
              'H2H': null, // No valid equivalent in database constraint
              'THR': 'Throwing'
            };
            const mappedSkill = skillMap[skillMatch[1].toUpperCase()];
            if (mappedSkill !== undefined) {
              item.skill = mappedSkill;
              if (item.parsedFields) item.parsedFields.push('skill');
            }
          }
          continue;
        }
        
        // Parse weight
        if (line.match(/^Weight:\s*/i)) {
          const weightMatch = line.match(/Weight:\s*([\d.]+)/i);
          if (weightMatch) {
            item.weight = parseFloat(weightMatch[1]);
            if (item.parsedFields) item.parsedFields.push('weight');
          }
          continue;
        }
        
        // Parse size
        if (line.match(/^Size:\s*/i)) {
          const sizeValue = line.replace(/^Size:\s*/i, '').trim();
          item.size = sizeValue.charAt(0).toUpperCase() + sizeValue.slice(1).toLowerCase();
          if (item.parsedFields) item.parsedFields.push('size');
          continue;
        }
        
        // Parse stats line - handle multiple stats in one line like "STR: +1 STA: +1 AGI: +1" or "STR +2 DEX +2"
        // First try to match multiple stats in one line (with or without colons)
        const multiStatMatches = line.matchAll(/(\w+)(?::)?\s*([+-]?\d+)/g);
        let foundStats = false;
        
        for (const statMatch of multiStatMatches) {
          const statName = statMatch[1].toLowerCase();
          const value = parseInt(statMatch[2]);
          
          const statMap = {
            'str': 'str',
            'sta': 'sta', 
            'agi': 'agi',
            'dex': 'dex',
            'wis': 'wis',
            'int': 'int',
            'cha': 'cha',
            'ac': 'ac',
            'hp': 'health',
            'mana': 'mana',
            'dmg': 'damage',
            'delay': 'delay',
            'health': 'health',
            'armor': 'ac',
            'attack': 'attack_speed'
          };
          
          if (statMap[statName]) {
            item[statMap[statName]] = value;
            if (item.parsedFields && ['str', 'sta', 'agi', 'dex', 'wis', 'int', 'cha', 'ac', 'health', 'mana'].includes(statMap[statName])) {
              item.parsedFields.push(statMap[statName]);
            }
            foundStats = true;
          }
        }
        
        // If we found stats on this line, continue to next line
        if (foundStats) {
          continue;
        }
        
        // Parse resistances - handle formats like "SV Magic: +5" or "Magic Resist: +10"
        const resistancePatterns = [
          { pattern: /SV\s+Magic(?::)?\s*([+-]?\d+)/i, field: 'resist_magic' },
          { pattern: /Magic\s+Resist(?::)?\s*([+-]?\d+)/i, field: 'resist_magic' },
          { pattern: /SV\s+Fire(?::)?\s*([+-]?\d+)/i, field: 'resist_fire' },
          { pattern: /Fire\s+Resist(?::)?\s*([+-]?\d+)/i, field: 'resist_fire' },
          { pattern: /SV\s+Cold(?::)?\s*([+-]?\d+)/i, field: 'resist_cold' },
          { pattern: /Cold\s+Resist(?::)?\s*([+-]?\d+)/i, field: 'resist_cold' },
          { pattern: /SV\s+Poison(?::)?\s*([+-]?\d+)/i, field: 'resist_poison' },
          { pattern: /Poison\s+Resist(?::)?\s*([+-]?\d+)/i, field: 'resist_poison' },
          { pattern: /SV\s+Disease(?::)?\s*([+-]?\d+)/i, field: 'resist_disease' },
          { pattern: /Disease\s+Resist(?::)?\s*([+-]?\d+)/i, field: 'resist_disease' },
          { pattern: /SV\s+Electricity(?::)?\s*([+-]?\d+)/i, field: 'resist_electricity' },
          { pattern: /Electricity\s+Resist(?::)?\s*([+-]?\d+)/i, field: 'resist_electricity' },
          { pattern: /SV\s+Corruption(?::)?\s*([+-]?\d+)/i, field: 'resist_corruption' },
          { pattern: /Corruption\s+Resist(?::)?\s*([+-]?\d+)/i, field: 'resist_corruption' }
        ];
        
        let foundResist = false;
        for (const { pattern, field } of resistancePatterns) {
          const match = line.match(pattern);
          if (match) {
            item[field] = parseInt(match[1]);
            if (item.parsedFields) item.parsedFields.push(field);
            foundResist = true;
          }
        }
        
        if (foundResist) {
          continue;
        }
      }
    }
    
    async function reloadItemEditor() {
      if (itemChanges.size > 0) {
        if (!confirm('You have unsaved changes. Reload anyway?')) {
          return;
        }
      }
      itemChanges.clear();
      await loadItemEditor();
      showMessage('Items reloaded', 'info');
    }
    
    // Staging functions for Item Editor
    function stageItemChange(itemId, field, newValue) {
      const row = document.getElementById(`item-row-${itemId}`);
      if (!row) return;
      
      // Special handling for race/class multi-select
      let cell, originalValue;
      if (field === 'race' || field === 'class') {
        const displayDiv = row.querySelector(`.${field}-display`);
        if (!displayDiv) return;
        cell = displayDiv.closest('td');
        
        // Get original value from the item data
        const itemData = gameItems.find(item => item.id === parseInt(itemId));
        originalValue = itemData ? (itemData[field] || '') : '';
      } else {
        const input = row.querySelector(`[data-field="${field}"]`);
        if (!input) return;
        originalValue = input.dataset.original;
        cell = input.closest('td');
      }
      
      // Convert values for comparison
      let original = originalValue;
      let current = newValue;
      
      // Handle numeric fields
      if (['str', 'sta', 'agi', 'dex', 'wis', 'int', 'cha', 'health', 'mana', 'ac',
          'resist_cold', 'resist_corruption', 'resist_disease', 'resist_electricity',
          'resist_fire', 'resist_magic', 'resist_poison'].includes(field)) {
        original = parseInt(original) || 0;
        current = parseInt(current) || 0;
      } else if (['attack_speed', 'weight'].includes(field)) {
        original = parseFloat(original) || 0;
        current = parseFloat(current) || 0;
      } else if (field === 'slots') {
        // Handle array comparison for slots
        original = JSON.stringify(original || []);
        current = JSON.stringify(current || []);
      }
      
      // Special handling for new items
      if (itemId === 'new') {
        if (!itemChanges.has(itemId)) {
          itemChanges.set(itemId, { _isNew: true });
        }
        const changes = itemChanges.get(itemId);
        changes[field] = current;
        
        // Ensure required fields are always present for new items
        if (!changes.icon_type) changes.icon_type = 'emoji';
        if (!changes.icon_value) changes.icon_value = '';
        
        cell.classList.add('changed');
        updateItemChangeButtons();
        return;
      }
      
      // Check if value changed
      if (String(original) === String(current)) {
        // Remove from changes if it's back to original
        if (itemChanges.has(itemId)) {
          const changes = itemChanges.get(itemId);
          delete changes[field];
          if (Object.keys(changes).length === 0) {
            itemChanges.delete(itemId);
          }
        }
        cell.classList.remove('cell-changed');
        
        // Special handling for race/class display divs
        if (field === 'race' || field === 'class') {
          const displayDiv = row.querySelector(`.${field}-display`);
          if (displayDiv) displayDiv.classList.remove('changed');
        }
      } else {
        // Add to changes
        if (!itemChanges.has(itemId)) {
          itemChanges.set(itemId, {});
        }
        itemChanges.get(itemId)[field] = current;
        cell.classList.add('cell-changed');
        
        // Special handling for race/class display divs
        if (field === 'race' || field === 'class') {
          const displayDiv = row.querySelector(`.${field}-display`);
          if (displayDiv) displayDiv.classList.add('changed');
        }
      }
      
      updateItemChangeButtons();
    }
    
    function updateItemChangeButtons() {
      const saveBtn = document.getElementById('item-save-btn');
      const resetBtn = document.getElementById('item-reset-btn');
      const changeCountSpan = document.getElementById('item-change-count');
      const changeCount = itemChanges.size;
      
      if (changeCount > 0) {
        saveBtn.disabled = false;
        resetBtn.disabled = false;
        if (changeCountSpan) changeCountSpan.textContent = changeCount;
      } else {
        saveBtn.disabled = true;
        resetBtn.disabled = true;
        if (changeCountSpan) changeCountSpan.textContent = '0';
      }
    }
    
    function updateStatInputColor(input) {
      const value = parseInt(input.value) || 0;
      if (value > 0) {
        input.style.color = '#4ade80';
      } else if (value < 0) {
        input.style.color = '#ef4444';
      } else {
        input.style.color = '';
      }
    }
    
    async function saveItemChanges() {
      if (itemChanges.size === 0) return;
      
      const creates = [];
      const updates = [];
      const deletes = [];
      
      for (const [itemId, changes] of itemChanges.entries()) {
        if (changes._delete) {
          deletes.push(itemId);
        } else if (changes._isNew) {
          // For new items, get current values from the form
          const addRow = document.getElementById('item-add-row');
          if (!addRow) {
            console.error('Add row not found!');
            continue;
          }
          
          // Get all current field values from the form
          const getCurrentValue = (field, defaultValue = '') => {
            const input = addRow.querySelector(`[data-field="${field}"]`);
            return input ? input.value : defaultValue;
          };
          
          const newItem = {
            name: getCurrentValue('name'),
            item_type: getCurrentValue('item_type', 'weapon'),
            slot: getCurrentValue('slot'),
            slots: changes.slots || [],
            weight: parseFloat(getCurrentValue('weight', 0)) || 0,
            size: getCurrentValue('size', 'Medium'),
            str: parseInt(getCurrentValue('str', 0)) || 0,
            sta: parseInt(getCurrentValue('sta', 0)) || 0,
            agi: parseInt(getCurrentValue('agi', 0)) || 0,
            dex: parseInt(getCurrentValue('dex', 0)) || 0,
            wis: parseInt(getCurrentValue('wis', 0)) || 0,
            int: parseInt(getCurrentValue('int', 0)) || 0,
            cha: parseInt(getCurrentValue('cha', 0)) || 0,
            attack_speed: parseFloat(getCurrentValue('attack_speed', 0)) || 0,
            health: parseInt(getCurrentValue('health', 0)) || 0,
            mana: parseInt(getCurrentValue('mana', 0)) || 0,
            ac: parseInt(getCurrentValue('ac', 0)) || 0,
            resist_cold: parseInt(getCurrentValue('resist_cold', 0)) || 0,
            resist_corruption: parseInt(getCurrentValue('resist_corruption', 0)) || 0,
            resist_disease: parseInt(getCurrentValue('resist_disease', 0)) || 0,
            resist_electricity: parseInt(getCurrentValue('resist_electricity', 0)) || 0,
            resist_fire: parseInt(getCurrentValue('resist_fire', 0)) || 0,
            resist_magic: parseInt(getCurrentValue('resist_magic', 0)) || 0,
            resist_poison: parseInt(getCurrentValue('resist_poison', 0)) || 0,
            description: getCurrentValue('description'),
            icon_type: changes.icon_type || 'emoji',
            icon_value: changes.icon_value || ''
          };
          
          creates.push(newItem);
        } else {
          const item = gameItems.find(i => i.id === parseInt(itemId));
          if (item) {
            updates.push({
              id: itemId,
              ...item,
              ...changes
            });
          }
        }
      }
      
      try {
        // Process creates
        for (const item of creates) {
          // Client-side validation
          if (!item.name || item.name.trim() === '') {
            throw new Error('Item name is required. Please enter a name for the new item.');
          }
          
          const response = await window.csrfHelper.fetchWithCSRF('/api/items', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(item)
          });
          
          if (!response.ok) {
            const data = await response.json();
            throw new Error(data.error || 'Failed to create item');
          }
        }
        
        // Process updates
        for (const item of updates) {
          const response = await window.csrfHelper.fetchWithCSRF(`/api/items/${item.id}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(item)
          });
          
          if (!response.ok) {
            const data = await response.json();
            throw new Error(data.error || 'Failed to update item');
          }
        }
        
        // Process deletes
        for (const itemId of deletes) {
          const response = await window.csrfHelper.fetchWithCSRF(`/api/items/${itemId}`, {
            method: 'DELETE'
          });
          
          if (!response.ok) {
            const data = await response.json();
            throw new Error(data.error || 'Failed to delete item');
          }
        }
        
        showMessage('All changes saved successfully', 'success');
        itemChanges.clear();
        await loadItemEditor();
      } catch (error) {
        showMessage(error.message, 'error');
      }
    }
    
    function resetItemChanges() {
      if (itemChanges.size === 0) return;
      
      if (!confirm('Discard all changes?')) return;
      
      // Reset all values and remove visual indicators
      for (const [itemId, changes] of itemChanges.entries()) {
        // Remove add row if it exists
        if (itemId === 'new' && changes._isNew) {
          const addRow = document.getElementById('item-add-row');
          if (addRow) addRow.remove();
          continue;
        }
        
        const row = document.getElementById(`item-row-${itemId}`);
        if (!row) continue;
        
        if (changes._delete) {
          row.classList.remove('marked-for-deletion');
          const deleteBtn = row.querySelector('.small-btn');
          if (deleteBtn) {
            deleteBtn.innerHTML = '';
            deleteBtn.title = 'Delete';
            deleteBtn.onclick = () => markItemForDeletion(itemId);
          }
        } else {
          for (const field of Object.keys(changes)) {
            // Special handling for race/class display divs
            if (field === 'race' || field === 'class') {
              const displayDiv = row.querySelector(`.${field}-display`);
              if (displayDiv) {
                const itemData = gameItems.find(item => item.id === parseInt(itemId));
                const originalValue = itemData ? (itemData[field] || '') : '';
                const isAll = !originalValue || originalValue === 'ALL';
                
                if (field === 'race') {
                  displayDiv.textContent = isAll ? 'All Races' : 
                    originalValue.split(' ').map(code => RACE_ABBREVIATIONS[code] || code).join(', ');
                } else {
                  displayDiv.textContent = isAll ? 'All Classes' : 
                    originalValue.split(' ').map(code => CLASS_ABBREVIATIONS[code] || code).join(', ');
                }
                
                displayDiv.classList.remove('changed');
                displayDiv.closest('td').classList.remove('cell-changed');
              }
            } else {
              const input = row.querySelector(`[data-field="${field}"]`);
              if (input) {
                input.value = input.dataset.original;
                if (input.classList.contains('stat-input')) {
                  updateStatInputColor(input);
                }
                input.closest('td').classList.remove('cell-changed');
              }
            }
          }
        }
      }
      
      itemChanges.clear();
      updateItemChangeButtons();
      showMessage('Changes discarded', 'info');
    }
    
    function markItemForDeletion(itemId) {
      const row = document.getElementById(`item-row-${itemId}`);
      if (!row) return;
      
      if (!itemChanges.has(itemId)) {
        itemChanges.set(itemId, {});
      }
      
      const changes = itemChanges.get(itemId);
      
      if (changes._delete) {
        // Undo deletion
        delete changes._delete;
        if (Object.keys(changes).length === 0) {
          itemChanges.delete(itemId);
        }
        row.classList.remove('marked-for-deletion');
        const deleteBtn = row.querySelector('.small-btn');
        deleteBtn.innerHTML = '';
        deleteBtn.title = 'Delete';
      } else {
        // Mark for deletion
        changes._delete = true;
        row.classList.add('marked-for-deletion');
        const deleteBtn = row.querySelector('.small-btn');
        deleteBtn.innerHTML = '';
        deleteBtn.title = 'Undo delete';
      }
      
      updateItemChangeButtons();
    }
    
    function showAddItemForm() {
      const tbody = document.getElementById('item-editor-tbody');
      
      // Check if add row already exists
      if (document.getElementById('item-add-row')) {
        showMessage('Add item form is already open', 'warning');
        return;
      }
      
      // Create a new item object with default values
      const newItem = {
        id: 'new',
        name: '',
        item_type: 'weapon',
        slot: '',
        weight: 0,
        size: 'Medium',
        str: 0,
        sta: 0,
        agi: 0,
        dex: 0,
        wis: 0,
        int: 0,
        cha: 0,
        attack_speed: 0,
        health: 0,
        mana: 0,
        ac: 0,
        block: 0,
        resist_cold: 0,
        resist_corruption: 0,
        resist_disease: 0,
        resist_electricity: 0,
        resist_fire: 0,
        resist_magic: 0,
        resist_poison: 0,
        race: null,
        class: null,
        description: '',
        icon_type: 'emoji',
        icon_value: ''
      };
      
      // Create the add row
      const addRow = createItemEditorRow(newItem);
      addRow.id = 'item-add-row';
      addRow.style.background = '#2d4a2d'; // Green tint for new item
      
      // Insert at the beginning of the table
      tbody.insertBefore(addRow, tbody.firstChild);
      
      // Focus on the name field and add placeholder
      const nameInput = addRow.querySelector('[data-field="name"]');
      if (nameInput) {
        nameInput.focus();
        nameInput.style.border = '2px solid #4ade80';
        nameInput.placeholder = 'Enter item name (required)';
        nameInput.style.backgroundColor = '#3a3a3a';
      }
      
      // Mark as a new item in changes - only set the flag and default icon
      itemChanges.set('new', {
        _isNew: true,
        icon_type: newItem.icon_type,
        icon_value: newItem.icon_value
      });
      updateItemChangeButtons();
      
      showMessage('Fill in the item details and click Save Changes to create', 'info');
    }
    
    function showItemIconPicker(itemId) {
      const row = document.getElementById(`item-row-${itemId}`);
      if (!row) return;
      
      const iconCell = row.querySelector('td:nth-child(2)'); // Icon is the 2nd column
      if (!iconCell) return;
      
      // Create a simple emoji picker for now
      const emojis = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''];
      
      const picker = document.createElement('div');
      picker.style.cssText = `
        position: absolute;
        background: #2d2d2d;
        border: 1px solid #555;
        border-radius: 8px;
        padding: 10px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        z-index: 1000;
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: 5px;
        max-width: 250px;
      `;
      
      emojis.forEach(emoji => {
        const btn = document.createElement('button');
        btn.textContent = emoji;
        btn.style.cssText = `
          background: #444;
          border: 1px solid #666;
          border-radius: 4px;
          padding: 8px;
          cursor: pointer;
          font-size: 1.5rem;
          transition: all 0.2s;
        `;
        btn.onmouseover = () => btn.style.background = '#555';
        btn.onmouseout = () => btn.style.background = '#444';
        btn.onclick = () => {
          // Update the icon
          iconCell.textContent = emoji;
          iconCell.style.fontSize = '1.5rem';
          
          // Stage the change
          if (!itemChanges.has(itemId)) {
            itemChanges.set(itemId, {});
          }
          const changes = itemChanges.get(itemId);
          changes.icon_type = 'emoji';
          changes.icon_value = emoji;
          
          if (itemId === 'new' && !changes._isNew) {
            changes._isNew = true;
          }
          
          updateItemChangeButtons();
          picker.remove();
        };
        picker.appendChild(btn);
      });
      
      // Position the picker
      const rect = iconCell.getBoundingClientRect();
      picker.style.left = rect.left + 'px';
      picker.style.top = (rect.bottom + 5) + 'px';
      
      // Close on click outside
      const closeHandler = (e) => {
        if (!picker.contains(e.target) && e.target !== iconCell) {
          picker.remove();
          document.removeEventListener('click', closeHandler);
        }
      };
      
      document.body.appendChild(picker);
      setTimeout(() => document.addEventListener('click', closeHandler), 0);
    }
    
    // Helper functions for polished Item modal
    function updateStatColor(input) {
      const value = parseInt(input.value) || 0;
      if (value > 0) {
        input.style.color = '#4ade80'; // Green for positive
        input.style.fontWeight = 'bold';
      } else if (value < 0) {
        input.style.color = '#ef4444'; // Red for negative
        input.style.fontWeight = 'bold';
      } else {
        input.style.color = '#ccc'; // Default for zero
        input.style.fontWeight = 'normal';
      }
    }
    
    function updateSlotOptions() {
      const itemType = document.getElementById('item-type').value;
      const slotSelect = document.getElementById('item-slot');
      
      // Clear current options
      slotSelect.innerHTML = '<option value="">None</option>';
      
      // Define slot options based on item type
      const slotOptions = {
        weapon: ['main_hand', 'off_hand', 'two_handed'],
        armor: ['head', 'chest', 'legs', 'feet', 'hands', 'shoulders', 'belt', 'cloak'],
        jewelry: ['ring', 'necklace', 'bracelet', 'earring'],
        consumable: [],
        material: [],
        misc: []
      };
      
      const slots = slotOptions[itemType] || [];
      slots.forEach(slot => {
        const option = document.createElement('option');
        option.value = slot;
        // Abbreviate Primary/Secondary as Pri/Sec in UI
        let displayText = slot.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
        if (slot === 'Primary/Secondary') {
          displayText = 'Pri/Sec';
        }
        option.textContent = displayText;
        slotSelect.appendChild(option);
      });
      
      // If editing and the current slot is in the new options, select it
      if (editingGameItem && slots.includes(editingGameItem.slot)) {
        slotSelect.value = editingGameItem.slot;
      }
    }
    
    function updateItemPreview() {
      const previewIcon = document.getElementById('item-preview-icon');
      const previewName = document.getElementById('item-preview-name');
      const previewStats = document.getElementById('item-preview-stats');
      
      if (!previewIcon || !previewName || !previewStats) return;
      
      const name = document.getElementById('item-name').value || 'New Item';
      const iconType = document.querySelector('input[name="item-icon-type"]:checked')?.value || 'emoji';
      const emoji = document.getElementById('item-emoji').value || '';
      
      // Update icon
      if (iconType === 'emoji') {
        previewIcon.textContent = emoji;
      }
      
      // Update name
      previewName.textContent = name;
      
      // Update stats
      const stats = {
        STR: parseInt(document.getElementById('item-str').value) || 0,
        STA: parseInt(document.getElementById('item-sta').value) || 0,
        AGI: parseInt(document.getElementById('item-agi').value) || 0,
        DEX: parseInt(document.getElementById('item-dex').value) || 0,
        WIS: parseInt(document.getElementById('item-wis').value) || 0,
        INT: parseInt(document.getElementById('item-int').value) || 0,
        CHA: parseInt(document.getElementById('item-cha').value) || 0
      };
      
      const attackSpeed = parseFloat(document.getElementById('item-attack-speed').value) || 0;
      const health = parseInt(document.getElementById('item-health').value) || 0;
      const mana = parseInt(document.getElementById('item-mana').value) || 0;
      const ac = parseInt(document.getElementById('item-ac').value) || 0;
      
      // Build stats display
      let statsHTML = '';
      const hasStats = Object.values(stats).some(v => v !== 0);
      
      if (hasStats || attackSpeed || health || mana || ac) {
        const statParts = [];
        
        // Add attribute stats
        for (const [stat, value] of Object.entries(stats)) {
          if (value !== 0) {
            const color = value > 0 ? '#4ade80' : '#ef4444';
            const sign = value > 0 ? '+' : '';
            statParts.push(`<span style="color: ${color};">${stat}: ${sign}${value}</span>`);
          }
        }
        
        // Add AC if present
        if (ac !== 0) {
          const color = ac > 0 ? '#4ade80' : '#ef4444';
          const sign = ac > 0 ? '+' : '';
          statParts.push(`<span style="color: ${color};">AC: ${sign}${ac}</span>`);
        }
        
        // Add combat stats
        if (attackSpeed) statParts.push(`<span style="color: #94a3b8;"> ${attackSpeed}</span>`);
        if (health) statParts.push(`<span style="color: #94a3b8;"> ${health}</span>`);
        if (mana) statParts.push(`<span style="color: #94a3b8;"> ${mana}</span>`);
        
        statsHTML = statParts.join(' ');
      } else {
        statsHTML = 'No stats';
      }
      
      previewStats.innerHTML = statsHTML;
    }
    
    // Initialize stat color updates when modal opens
    function initializeItemModalEvents() {
      // Add event listeners for stat inputs
      const statInputs = ['str', 'sta', 'agi', 'dex', 'wis', 'int', 'cha', 'ac'];
      statInputs.forEach(stat => {
        const input = document.getElementById(`item-${stat}`);
        if (input) {
          input.addEventListener('input', function() {
            updateStatColor(this);
            updateItemPreview();
          });
          // Initialize color on load
          updateStatColor(input);
        }
      });
      
      // Add event listeners for other inputs
      document.getElementById('item-name')?.addEventListener('input', updateItemPreview);
      document.getElementById('item-emoji')?.addEventListener('input', updateItemPreview);
      document.getElementById('item-attack-speed')?.addEventListener('input', updateItemPreview);
      document.getElementById('item-health')?.addEventListener('input', updateItemPreview);
      document.getElementById('item-mana')?.addEventListener('input', updateItemPreview);
      document.getElementById('item-ac')?.addEventListener('input', updateItemPreview);
      document.getElementById('item-type')?.addEventListener('change', updateSlotOptions);
      
      // Initialize preview
      updateItemPreview();
    }
    
    // XP Configuration Functions
    async function loadXPConfig() {
      const loading = document.getElementById('xp-config-loading');
      const content = document.getElementById('xp-config-content');
      const tbody = document.getElementById('xp-config-tbody');
      
      if (!loading || !content || !tbody) {
        console.error('XP config elements not found:', { loading, content, tbody });
        return;
      }
      
      loading.style.display = 'block';
      content.style.display = 'none';
      
      try {
        const response = await fetch('/api/admin/xp-config');
        if (response.ok) {
          const configs = await response.json();
          
          tbody.innerHTML = '';
          configs.forEach(config => {
            const row = document.createElement('tr');
            const displayName = getXPActionName(config.key);
            
            // Action name cell
            row.appendChild(createTextCell(displayName));
            
            // Description cell
            row.appendChild(createTextCell(config.description));
            
            // XP input cell
            const inputCell = document.createElement('td');
            const input = document.createElement('input');
            input.type = 'number';
            input.id = `xp-${config.key}`;
            input.value = config.value;
            input.className = 'xp-input';
            input.min = '-100';
            input.max = '100';
            inputCell.appendChild(input);
            row.appendChild(inputCell);
            
            // Update button cell
            const btnCell = document.createElement('td');
            const btn = document.createElement('button');
            btn.className = 'btn btn-sm';
            btn.textContent = 'Update';
            btn.onclick = () => updateXPConfig(config.key);
            btnCell.appendChild(btn);
            row.appendChild(btnCell);
            
            tbody.appendChild(row);
          });
          
          loading.style.display = 'none';
          content.style.display = 'block';
        }
      } catch (error) {
        console.error('Error loading XP config:', error);
        loading.innerHTML = '<p style="color: #dc3545;">Failed to load XP configuration</p>';
      }
    }
    
    function getXPActionName(key) {
      const names = {
        'poi_publish': 'Publish POI',
        'poi_pending_remove': 'Remove from Pending',
        'poi_approved': 'POI Approved',
        'proposal_vote': 'Vote on Proposal',
        'change_approved': 'Change Approved'
      };
      return names[key] || key;
    }
    
    async function updateXPConfig(key) {
      const input = document.getElementById(`xp-${key}`);
      const value = parseInt(input.value);
      
      if (isNaN(value)) {
        showMessage('Please enter a valid number', 'error');
        return;
      }
      
      try {
        const response = await window.csrfHelper.fetchWithCSRF(`/api/admin/xp-config/${key}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ value })
        });
        
        if (response.ok) {
          showMessage('XP configuration updated successfully', 'success');
        } else {
          showMessage('Failed to update XP configuration', 'error');
        }
      } catch (error) {
        console.error('Error updating XP config:', error);
        showMessage('Failed to update XP configuration', 'error');
      }
    }

    // Welcome Message Functions
    async function loadWelcomeMessage() {
      const loading = document.getElementById('welcome-message-loading');
      const content = document.getElementById('welcome-message-content');
      const textarea = document.getElementById('welcome-message-input');
      
      if (!loading || !content || !textarea) {
        console.error('Welcome message elements not found');
        return;
      }
      
      loading.style.display = 'block';
      content.style.display = 'none';
      
      try {
        const response = await fetch('/api/welcome-message');
        if (response.ok) {
          const data = await response.json();
          textarea.value = data.message || '';
          
          loading.style.display = 'none';
          content.style.display = 'block';
        }
      } catch (error) {
        console.error('Error loading welcome message:', error);
        loading.innerHTML = '<p style="color: #dc3545;">Failed to load welcome message</p>';
      }
    }
    
    async function saveWelcomeMessage() {
      const textarea = document.getElementById('welcome-message-input');
      const message = textarea.value.trim();
      
      if (!message) {
        showMessage('Please enter a welcome message', 'error');
        return;
      }
      
      try {
        const response = await window.csrfHelper.fetchWithCSRF('/api/admin/welcome-message', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ message })
        });
        
        if (response.ok) {
          showMessage('Welcome message saved successfully', 'success');
        } else {
          showMessage('Failed to save welcome message', 'error');
        }
      } catch (error) {
        console.error('Error saving welcome message:', error);
        showMessage('Failed to save welcome message', 'error');
      }
    }
    
    async function clearWelcomeMessage() {
      if (!confirm('Are you sure you want to clear the welcome message? Users will not see any welcome message.')) {
        return;
      }
      
      try {
        const response = await window.csrfHelper.fetchWithCSRF('/api/admin/welcome-message', {
          method: 'DELETE'
        });
        
        if (response.ok) {
          document.getElementById('welcome-message-input').value = '';
          showMessage('Welcome message cleared successfully', 'success');
        } else {
          showMessage('Failed to clear welcome message', 'error');
        }
      } catch (error) {
        console.error('Error clearing welcome message:', error);
        showMessage('Failed to clear welcome message', 'error');
      }
    }
    
    function previewWelcomeMessage() {
      const message = document.getElementById('welcome-message-input').value.trim();
      
      if (!message) {
        showMessage('Please enter a message to preview', 'error');
        return;
      }
      
      // Create a temporary modal to preview the message
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.style.cssText = 'display: flex; position: fixed; z-index: 3000; left: 0; top: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); align-items: center; justify-content: center;';
      
      const modalContent = document.createElement('div');
      modalContent.style.cssText = 'background: rgba(30, 30, 30, 0.98); border: 1px solid #555; border-radius: 8px; max-width: 600px; max-height: 80vh; margin: 1rem;';
      
      // Use marked if available, otherwise show plain text
      let formattedMessage = message;
      if (typeof marked !== 'undefined') {
        marked.setOptions({ breaks: true, gfm: true });
        formattedMessage = marked.parse(message);
      }
      
      modalContent.innerHTML = `
        <div style="padding: 1rem 1.5rem; border-bottom: 1px solid #444;">
          <h3 style="margin: 0; color: #fff; font-size: 1.3rem;">Welcome to MMC!</h3>
        </div>
        <div style="padding: 1.5rem; overflow-y: auto; max-height: 60vh;">
          <div class="markdown-content">${formattedMessage}</div>
        </div>
        <div style="padding: 1rem 1.5rem; text-align: center; border-top: 1px solid #444;">
          <button onclick="this.closest('.modal').remove()" class="primary-btn" style="padding: 0.6rem 2rem;">OK</button>
        </div>
      `;
      
      modal.appendChild(modalContent);
      document.body.appendChild(modal);
      
      // Add markdown styles
      const style = document.createElement('style');
      style.textContent = `
        .markdown-content p { margin: 0 0 1rem 0; color: #e0e0e0; line-height: 1.6; }
        .markdown-content p:last-child { margin-bottom: 0; }
        .markdown-content h1, .markdown-content h2, .markdown-content h3 { color: #fff; margin: 1rem 0 0.5rem 0; }
        .markdown-content ul, .markdown-content ol { margin: 0.5rem 0; padding-left: 1.5rem; color: #e0e0e0; }
        .markdown-content li { margin: 0.25rem 0; }
        .markdown-content a { color: #7fb069; text-decoration: none; }
        .markdown-content a:hover { text-decoration: underline; }
        .markdown-content code { background: rgba(255,255,255,0.1); padding: 0.2rem 0.4rem; border-radius: 3px; font-family: monospace; }
        .markdown-content pre { background: rgba(0,0,0,0.3); padding: 1rem; border-radius: 4px; overflow-x: auto; }
        .markdown-content blockquote { border-left: 3px solid #7fb069; padding-left: 1rem; margin: 1rem 0; color: #ccc; }
      `;
      document.head.appendChild(style);
    }
    
    // Apply markdown formatting to selected text
    function applyMarkdownFormat(format) {
      const textarea = document.getElementById('welcome-message-input');
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      const text = textarea.value;
      const selectedText = text.substring(start, end);
      
      let newText = '';
      let cursorOffset = 0;
      
      switch(format) {
        case 'bold':
          if (selectedText) {
            newText = `**${selectedText}**`;
            cursorOffset = newText.length;
          } else {
            newText = '****';
            cursorOffset = 2;
          }
          break;
          
        case 'italic':
          if (selectedText) {
            newText = `*${selectedText}*`;
            cursorOffset = newText.length;
          } else {
            newText = '**';
            cursorOffset = 1;
          }
          break;
          
        case 'code':
          if (selectedText && selectedText.includes('\n')) {
            newText = `\`\`\`\n${selectedText}\n\`\`\``;
            cursorOffset = newText.length;
          } else if (selectedText) {
            newText = `\`${selectedText}\``;
            cursorOffset = newText.length;
          } else {
            newText = '``';
            cursorOffset = 1;
          }
          break;
          
        case 'link':
          if (selectedText && selectedText.startsWith('http')) {
            newText = `[](${selectedText})`;
            cursorOffset = 1;
          } else if (selectedText) {
            newText = `[${selectedText}]()`;
            cursorOffset = newText.length - 1;
          } else {
            newText = '[]()';
            cursorOffset = 1;
          }
          break;
          
        case 'h1':
          if (selectedText) {
            newText = `# ${selectedText}`;
            cursorOffset = newText.length;
          } else {
            newText = '# ';
            cursorOffset = 2;
          }
          break;
          
        case 'h2':
          if (selectedText) {
            newText = `## ${selectedText}`;
            cursorOffset = newText.length;
          } else {
            newText = '## ';
            cursorOffset = 3;
          }
          break;
          
        case 'h3':
          if (selectedText) {
            newText = `### ${selectedText}`;
            cursorOffset = newText.length;
          } else {
            newText = '### ';
            cursorOffset = 4;
          }
          break;
          
        case 'ul':
          if (selectedText) {
            // Convert each line to a bullet point
            newText = selectedText.split('\n').map(line => `- ${line}`).join('\n');
            cursorOffset = newText.length;
          } else {
            newText = '- ';
            cursorOffset = 2;
          }
          break;
          
        case 'ol':
          if (selectedText) {
            // Convert each line to a numbered list
            newText = selectedText.split('\n').map((line, i) => `${i + 1}. ${line}`).join('\n');
            cursorOffset = newText.length;
          } else {
            newText = '1. ';
            cursorOffset = 3;
          }
          break;
          
        case 'quote':
          if (selectedText) {
            // Add > to each line
            newText = selectedText.split('\n').map(line => `> ${line}`).join('\n');
            cursorOffset = newText.length;
          } else {
            newText = '> ';
            cursorOffset = 2;
          }
          break;
      }
      
      // Replace the selected text
      textarea.value = text.substring(0, start) + newText + text.substring(end);
      
      // Set cursor position
      textarea.focus();
      textarea.selectionStart = start + cursorOffset;
      textarea.selectionEnd = start + cursorOffset;
      
      // Trigger input event for any listeners
      textarea.dispatchEvent(new Event('input'));
    }

    // Calculate level from XP
    function calculateLevelFromXP(xp) {
      if (xp <= 0) return 1;
      
      let level = 1;
      let totalXPNeeded = 0;
      
      // Keep adding XP requirements until we exceed the player's XP
      while (totalXPNeeded <= xp) {
        totalXPNeeded += level * level * 100;
        if (totalXPNeeded <= xp) {
          level++;
        }
      }
      
      return level;
    }

    // Format relative time helper
    function formatRelativeTime(dateString) {
      const date = new Date(dateString);
      const now = new Date();
      const diffMs = now - date;
      const diffSecs = Math.floor(diffMs / 1000);
      const diffMins = Math.floor(diffSecs / 60);
      const diffHours = Math.floor(diffMins / 60);
      const diffDays = Math.floor(diffHours / 24);
      
      if (diffSecs < 60) {
        return 'just now';
      } else if (diffMins < 60) {
        return `${diffMins} minute${diffMins !== 1 ? 's' : ''} ago`;
      } else if (diffHours < 24) {
        return `${diffHours} hour${diffHours !== 1 ? 's' : ''} ago`;
      } else if (diffDays < 7) {
        return `${diffDays} day${diffDays !== 1 ? 's' : ''} ago`;
      } else {
        // For older dates, show the actual date
        return `on ${date.toLocaleDateString('en-US', { 
          month: 'short', 
          day: 'numeric', 
          year: date.getFullYear() !== now.getFullYear() ? 'numeric' : undefined 
        })}`;
      }
    }

    // User Management Functions
    let allUsers = [];
    let filteredUsers = [];
    let usersCurrentPage = 1;
    let selectedUser = null;
    
    async function loadUsers() {
      const loading = document.getElementById('user-management-loading');
      const content = document.getElementById('user-management-content');
      
      loading.style.display = 'block';
      content.style.display = 'none';
      
      try {
        const response = await fetch('/api/admin/users');
        if (response.ok) {
          allUsers = await response.json();
          filteredUsers = [...allUsers];
          displayUsers();
          
          loading.style.display = 'none';
          content.style.display = 'block';
        }
      } catch (error) {
        console.error('Error loading users:', error);
        loading.innerHTML = '<p style="color: #dc3545;">Failed to load users</p>';
      }
    }
    
    function refreshUsers() {
      // Clear search when refreshing
      document.getElementById('user-search').value = '';
      // Reload users
      loadUsers();
    }
    
    function searchUsers() {
      const searchTerm = document.getElementById('user-search').value.toLowerCase();
      
      if (searchTerm) {
        filteredUsers = allUsers.filter(user => 
          user.name.toLowerCase().includes(searchTerm) || 
          user.email.toLowerCase().includes(searchTerm)
        );
      } else {
        filteredUsers = [...allUsers];
      }
      
      usersCurrentPage = 1;
      displayUsers();
    }
    
    function displayUsers() {
      const totalPages = Math.ceil(filteredUsers.length / ITEMS_PER_PAGE);
      usersCurrentPage = Math.max(1, Math.min(usersCurrentPage, totalPages || 1));
      
      const tbody = document.getElementById('users-tbody');
      tbody.innerHTML = '';
      
      if (filteredUsers.length === 0) {
        document.getElementById('users-pagination').style.display = 'none';
        const row = document.createElement('tr');
        const noDataCell = document.createElement('td');
        noDataCell.colSpan = 8;
        noDataCell.style.textAlign = 'center';
        noDataCell.style.color = '#666';
        noDataCell.style.padding = '2rem';
        noDataCell.textContent = 'No users found';
        row.appendChild(noDataCell);
        tbody.appendChild(row);
      } else {
        document.getElementById('users-pagination').style.display = totalPages > 1 ? 'flex' : 'none';
        
        const startIndex = (usersCurrentPage - 1) * ITEMS_PER_PAGE;
        const endIndex = startIndex + ITEMS_PER_PAGE;
        const pageUsers = filteredUsers.slice(startIndex, endIndex);
        
        pageUsers.forEach(user => {
          const row = document.createElement('tr');
          
          // Add background color based on status
          if (user.is_banned) {
            row.style.background = 'rgba(220, 53, 69, 0.15)';
          } else if (user.unacknowledged_warnings > 0) {
            row.style.background = 'rgba(255, 193, 7, 0.15)';
          }
          
          const statusBadge = getUserStatusBadge(user);
          
          // Always use DOM manipulation for consistent rendering
          const cells = [
            createImageCell(user.custom_avatar, user.picture, user.display_name || user.name),
            createTextCell(user.display_name || user.name),
            createTextCell(user.email),
            createXPCell(user.xp || 0),
            createTextCell(user.poi_count || 0),
            createHTMLCell(statusBadge),
            createTextCell(new Date(user.created_at).toLocaleDateString()),
            createButtonCell(user.id)
          ];
          cells.forEach(cell => row.appendChild(cell));
          tbody.appendChild(row);
        });
        
        document.getElementById('users-page-info').textContent = `Page ${usersCurrentPage} of ${totalPages}`;
        document.getElementById('users-prev').disabled = usersCurrentPage === 1;
        document.getElementById('users-next').disabled = usersCurrentPage === totalPages;
      }
    }
    
    function getUserStatusBadge(user) {
      let badges = [];
      
      if (user.is_banned) {
        badges.push('<span style="background: #dc3545; color: white; padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.8rem; margin-right: 0.25rem;">Banned</span>');
      } else {
        if (user.is_admin) {
          badges.push('<span style="background: #FFD700; color: #2a1810; padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.8rem; margin-right: 0.25rem;">Admin</span>');
        } else {
          badges.push('<span style="background: #28a745; color: white; padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.8rem; margin-right: 0.25rem;">Active</span>');
        }
      }
      
      if (!user.visible) {
        badges.push('<span style="background: #6c757d; color: white; padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.8rem; margin-right: 0.25rem;" title="Hidden from leaderboards"> Hidden</span>');
      }
      
      if (user.unacknowledged_warnings > 0) {
        badges.push(`<span style="background: #ffc107; color: #2a1810; padding: 0.2rem 0.5rem; border-radius: 4px; font-size: 0.8rem;" title="${user.unacknowledged_warnings} unacknowledged warning${user.unacknowledged_warnings > 1 ? 's' : ''}"> ${user.unacknowledged_warnings}</span>`);
      }
      
      return badges.join('');
    }
    
    function changeUsersPage(direction) {
      const totalPages = Math.ceil(filteredUsers.length / ITEMS_PER_PAGE);
      usersCurrentPage += direction;
      usersCurrentPage = Math.max(1, Math.min(usersCurrentPage, totalPages));
      displayUsers();
    }
    
    async function viewUserDetails(userId) {
      try {
        const response = await fetch(`/api/admin/users/${userId}`);
        if (response.ok) {
          selectedUser = await response.json();
          displayUserModal(selectedUser);
        }
      } catch (error) {
        showMessage('Failed to load user details', 'error');
      }
    }
    
    function displayUserModal(user) {
      const detailAvatar = document.getElementById('detail-user-avatar');
      // custom_avatar already contains the full URL from the API
      detailAvatar.src = user.custom_avatar || user.picture;
      
      // Add fallback to Google picture
      detailAvatar.onerror = function() {
        if (user.picture && this.src !== user.picture) {
          this.src = user.picture;
          this.onerror = null; // Prevent infinite loop
        } else {
          this.style.display = 'none';
        }
      };
      document.getElementById('detail-user-name').textContent = user.display_name || user.name;
      document.getElementById('detail-user-email').textContent = user.email;
      document.getElementById('detail-user-id').textContent = user.id;
      document.getElementById('detail-user-joined').textContent = new Date(user.created_at).toLocaleString();
      document.getElementById('detail-user-last-active').textContent = user.last_visit ? new Date(user.last_visit).toLocaleString() : 'Never';
      document.getElementById('detail-user-xp').textContent = user.xp || 0;
      
      // Calculate and display level
      const userXP = user.xp || 0;
      const level = calculateLevelFromXP(userXP);
      const levelBadge = document.getElementById('detail-user-level');
      if (levelBadge) {
        levelBadge.textContent = level;
      }
      
      // Display nickname
      const nicknameEl = document.getElementById('detail-user-nickname');
      if (nicknameEl) {
        nicknameEl.textContent = user.nickname || '(none)';
      }
      
      // Display donation tier
      const tierEl = document.getElementById('detail-user-tier');
      if (tierEl && user.donation_tier) {
        tierEl.textContent = user.donation_tier.name;
        tierEl.style.background = user.donation_tier.color || '#6c757d';
        tierEl.style.display = 'inline-block';
      } else if (tierEl) {
        tierEl.style.display = 'none';
      }
      
      document.getElementById('detail-user-total-pois').textContent = user.total_pois || 0;
      document.getElementById('detail-user-published-pois').textContent = user.published_pois || 0;
      document.getElementById('detail-user-votes').textContent = user.votes_cast || 0;
      
      // Update status
      const statusEl = document.getElementById('detail-user-status');
      if (user.is_banned) {
        statusEl.textContent = 'Banned';
        statusEl.style.background = '#dc3545';
        statusEl.style.color = 'white';
        document.getElementById('ban-user-btn').style.display = 'none';
        document.getElementById('unban-user-btn').style.display = 'inline-flex';
      } else {
        statusEl.textContent = 'Active';
        statusEl.style.background = '#28a745';
        statusEl.style.color = 'white';
        document.getElementById('ban-user-btn').style.display = 'inline-flex';
        document.getElementById('unban-user-btn').style.display = 'none';
      }
      
      // Update admin toggle button
      const toggleBtn = document.getElementById('toggle-admin-text');
      toggleBtn.textContent = user.is_admin ? 'Remove Admin' : 'Make Admin';
      
      // Show warnings if any
      if (user.warnings && user.warnings.length > 0) {
        document.getElementById('user-warnings-section').style.display = 'block';
        const warningsList = document.getElementById('user-warnings-list');
        warningsList.innerHTML = user.warnings.map(w => `
          <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: rgba(0, 0, 0, 0.3); border-radius: 6px; border-left: 3px solid ${w.acknowledged_at ? '#28a745' : '#ffc107'};">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.25rem;">
              <strong style="color: ${w.acknowledged_at ? '#28a745' : '#ffc107'};">Warned ${formatRelativeTime(w.created_at)}</strong>
              <span style="color: #888; font-size: 0.85rem;">by ${w.admin_name}</span>
            </div>
            <p style="margin: 0; color: #e0e0e0; line-height: 1.4;">${w.reason}</p>
            ${w.acknowledged_at ? `
              <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #444;">
                <span style="color: #28a745; font-size: 0.85rem;">
                   Acknowledged ${formatRelativeTime(w.acknowledged_at)}
                </span>
              </div>
            ` : `
              <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #444;">
                <span style="color: #ffc107; font-size: 0.85rem;">
                   Not yet acknowledged
                </span>
              </div>
            `}
          </div>
        `).join('');
      } else {
        document.getElementById('user-warnings-section').style.display = 'none';
      }
      
      // Show ban history if any
      if (user.banHistory && user.banHistory.length > 0) {
        document.getElementById('user-ban-history-section').style.display = 'block';
        const banHistoryList = document.getElementById('user-ban-history-list');
        banHistoryList.innerHTML = user.banHistory.map(bh => `
          <div style="margin-bottom: 0.75rem; padding: 0.75rem; background: rgba(0, 0, 0, 0.3); border-radius: 6px; border-left: 3px solid ${bh.action === 'ban' ? '#dc3545' : '#28a745'};">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.25rem;">
              <strong style="color: ${bh.action === 'ban' ? '#dc3545' : '#28a745'};">
                ${bh.action === 'ban' ? ' Banned' : ' Unbanned'} ${formatRelativeTime(bh.created_at)}
              </strong>
              <span style="color: #888; font-size: 0.85rem;">by ${bh.admin_name}</span>
            </div>
            ${bh.reason ? `<p style="margin: 0; color: #e0e0e0; line-height: 1.4;">${bh.reason}</p>` : ''}
          </div>
        `).join('');
      } else {
        document.getElementById('user-ban-history-section').style.display = 'none';
      }
      
      document.getElementById('user-detail-modal').style.display = 'block';
    }
    
    function closeUserModal() {
      document.getElementById('user-detail-modal').style.display = 'none';
      selectedUser = null;
    }
    
    async function banUser() {
      if (!confirm('Are you sure you want to ban this user? They will be immediately logged out and unable to access their account.')) return;
      
      const reason = prompt('Enter reason for ban:');
      if (!reason) return;
      
      try {
        const response = await window.csrfHelper.fetchWithCSRF(`/api/admin/users/${selectedUser.id}/ban`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ reason })
        });
        
        if (response.ok) {
          showMessage('User banned successfully', 'success');
          closeUserModal();
          loadUsers();
        }
      } catch (error) {
        showMessage('Failed to ban user', 'error');
      }
    }
    
    async function unbanUser() {
      if (!confirm('Are you sure you want to unban this user?')) return;
      
      try {
        const response = await window.csrfHelper.fetchWithCSRF(`/api/admin/users/${selectedUser.id}/unban`, {
          method: 'POST'
        });
        
        if (response.ok) {
          showMessage('User unbanned successfully', 'success');
          closeUserModal();
          loadUsers();
        }
      } catch (error) {
        showMessage('Failed to unban user', 'error');
      }
    }
    
    async function warnUser() {
      if (!confirm('Are you sure you want to send a warning to this user?')) return;
      
      const reason = prompt('Enter warning message:');
      if (!reason) return;
      
      try {
        const response = await window.csrfHelper.fetchWithCSRF(`/api/admin/users/${selectedUser.id}/warn`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ reason })
        });
        
        if (response.ok) {
          showMessage('Warning sent to user', 'success');
          viewUserDetails(selectedUser.id); // Reload to show new warning
        }
      } catch (error) {
        showMessage('Failed to warn user', 'error');
      }
    }
    
    async function logoutUser() {
      if (!confirm('Are you sure you want to force logout this user from all sessions? They will need to sign in again to access their account.')) return;
      
      try {
        const response = await window.csrfHelper.fetchWithCSRF(`/api/admin/users/${selectedUser.id}/logout`, {
          method: 'POST'
        });
        
        if (response.ok) {
          showMessage('User logged out from all sessions', 'success');
        }
      } catch (error) {
        showMessage('Failed to logout user', 'error');
      }
    }
    
    async function toggleAdminStatus() {
      const action = selectedUser.is_admin ? 'remove admin privileges from' : 'grant admin privileges to';
      if (!confirm(`Are you sure you want to ${action} this user?`)) return;
      
      try {
        const response = await window.csrfHelper.fetchWithCSRF(`/api/admin/users/${selectedUser.id}/admin`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ is_admin: !selectedUser.is_admin })
        });
        
        if (response.ok) {
          showMessage(`Admin status ${selectedUser.is_admin ? 'removed' : 'granted'}`, 'success');
          closeUserModal();
          loadUsers();
        }
      } catch (error) {
        showMessage('Failed to update admin status', 'error');
      }
    }
    
    function viewUserPois() {
      if (!confirm(`View all POIs created by ${selectedUser.name}?`)) return;
      sessionStorage.setItem('viewUserPois', selectedUser.id);
      window.open('/', '_blank');
    }
    
    // XP Adjustment functions
    function showXPAdjustment() {
      if (!selectedUser) return;
      
      const xpAvatar = document.getElementById('xp-user-avatar');
      const xpAvatarUrl = selectedUser.custom_avatar ? `/avatars/${selectedUser.custom_avatar}` : selectedUser.picture;
      xpAvatar.src = xpAvatarUrl;
      
      // Add fallback to Google picture
      xpAvatar.onerror = function() {
        if (selectedUser.picture && this.src !== selectedUser.picture) {
          this.src = selectedUser.picture;
        } else {
          this.style.display = 'none';
        }
      };
      document.getElementById('xp-user-name').textContent = selectedUser.display_name || selectedUser.name;
      document.getElementById('xp-current').textContent = selectedUser.xp || 0;
      document.getElementById('xp-new-value').value = selectedUser.xp || 0;
      document.getElementById('xp-reason').value = '';
      
      document.getElementById('xp-adjustment-modal').style.display = 'block';
    }
    
    function closeXPModal() {
      document.getElementById('xp-adjustment-modal').style.display = 'none';
    }
    
    async function updateUserXP() {
      const newXP = parseInt(document.getElementById('xp-new-value').value);
      const reason = document.getElementById('xp-reason').value;
      
      if (isNaN(newXP) || newXP < 0) {
        showMessage('Please enter a valid XP value', 'error');
        return;
      }
      
      const currentXP = selectedUser.xp || 0;
      if (newXP === currentXP) {
        showMessage('XP value unchanged', 'error');
        return;
      }
      
      const xpChange = newXP - currentXP;
      const changeText = xpChange > 0 ? `+${xpChange}` : `${xpChange}`;
      
      if (!confirm(`Are you sure you want to change ${selectedUser.name}'s XP from ${currentXP} to ${newXP} (${changeText})?`)) return;
      
      try {
        const response = await window.csrfHelper.fetchWithCSRF(`/api/admin/users/${selectedUser.id}/xp`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ xp: newXP, reason })
        });
        
        if (response.ok) {
          showMessage('XP updated successfully', 'success');
          closeXPModal();
          // Refresh user details to show new XP
          viewUserDetails(selectedUser.id);
        } else {
          const data = await response.json();
          showMessage(data.error || 'Failed to update XP', 'error');
        }
      } catch (error) {
        showMessage('Failed to update XP', 'error');
      }
    }
    
    // Update close modal handler
    window.onclick = function(event) {
      const userModal = document.getElementById('user-detail-modal');
      const xpModal = document.getElementById('xp-adjustment-modal');
      
      if (event.target === userModal) {
        closeUserModal();
      } else if (event.target === xpModal) {
        closeXPModal();
      }
    }

    // Profile customization functions
    async function handleAvatarUpload(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      // Validate file size
      if (file.size > 5 * 1024 * 1024) {
        showMessage('File size must be less than 5MB', 'error');
        return;
      }
      
      // Show loading
      document.getElementById('avatar-loading').style.display = 'flex';
      document.getElementById('upload-progress-bar').style.width = '0%';
      document.getElementById('upload-status').textContent = '';
      
      const formData = new FormData();
      formData.append('avatar', file);
      
      try {
        // Simulate upload progress
        const progressBar = document.getElementById('upload-progress-bar');
        const statusText = document.getElementById('upload-status');
        
        // Upload phase (0-60%)
        progressBar.style.width = '20%';
        statusText.textContent = 'Uploading...';
        
        const xhr = new XMLHttpRequest();
        
        // Track upload progress
        xhr.upload.addEventListener('progress', (e) => {
          if (e.lengthComputable) {
            const percentComplete = Math.round((e.loaded / e.total) * 60);
            progressBar.style.width = percentComplete + '%';
          }
        });
        
        // Create a promise for the XHR request
        const uploadPromise = new Promise((resolve, reject) => {
          xhr.onload = () => {
            if (xhr.status >= 200 && xhr.status < 300) {
              resolve(JSON.parse(xhr.responseText));
            } else {
              reject(new Error(xhr.statusText));
            }
          };
          xhr.onerror = () => reject(new Error('Network error'));
        });
        
        // Get CSRF token first
        const csrfResponse = await fetch('/api/csrf-token');
        const csrfData = await csrfResponse.json();
        
        xhr.open('POST', '/api/user/profile/avatar');
        xhr.setRequestHeader('X-CSRF-Token', csrfData.csrfToken);
        xhr.send(formData);
        
        const data = await uploadPromise;
        
        // Processing phase (60-80%)
        progressBar.style.width = '80%';
        statusText.textContent = 'Processing image...';
        await new Promise(resolve => setTimeout(resolve, 500));
        
        // Verification phase (80-100%)
        progressBar.style.width = '90%';
        statusText.textContent = 'Verifying upload...';
        
        // Verify the uploaded avatar
        const verifyResponse = await fetch('/api/user/profile/avatar/verify');
        const verifyData = await verifyResponse.json();
        
        if (verifyData.verified) {
          progressBar.style.width = '100%';
          statusText.textContent = ' Upload verified!';
          
          // Update all avatar displays
          const newAvatarUrl = data.avatarUrl;
          
          // Add timestamp to force reload
          const timestampedUrl = newAvatarUrl + (newAvatarUrl.includes('?') ? '&' : '?') + 't=' + Date.now();
          
          document.getElementById('user-avatar').src = timestampedUrl;
          document.getElementById('preview-avatar').src = timestampedUrl;
          
          // Update current user data
          currentUser.custom_avatar = newAvatarUrl;
          currentUser.picture = newAvatarUrl;
          
          // Show reset button
          document.getElementById('reset-avatar-btn').style.display = 'inline-block';
          
          // Wait a moment to show completion
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          showMessage('Profile picture updated and verified successfully', 'success');
          
          // Trigger auth status refresh to update main app
          window.dispatchEvent(new Event('avatar-updated'));
        } else {
          progressBar.style.width = '90%';
          statusText.textContent = ' Verification failed';
          showMessage('Avatar upload failed verification. Please try again.', 'error');
        }
      } catch (error) {
        document.getElementById('upload-progress-bar').style.width = '0%';
        document.getElementById('upload-status').textContent = ' Upload failed';
        showMessage('Failed to upload image: ' + error.message, 'error');
      } finally {
        // Hide loading after a delay
        setTimeout(() => {
          document.getElementById('avatar-loading').style.display = 'none';
          document.getElementById('upload-progress-bar').style.width = '0%';
          document.getElementById('upload-status').textContent = '';
        }, 1500);
        
        // Reset file input
        document.getElementById('avatar-upload').value = '';
      }
    }
    
    async function resetAvatar() {
      if (!confirm('Reset to your Google profile picture? This will permanently delete all your custom avatars.')) return;
      
      try {
        const response = await window.csrfHelper.fetchWithCSRF('/api/user/profile/avatar/reset', {
          method: 'POST'
        });
        
        if (response.ok) {
          const data = await response.json();
          
          // Fetch user profile to get original Google picture
          const profileResponse = await fetch('/api/user/profile');
          const profile = await profileResponse.json();
          
          // Revert to Google picture
          const googlePicture = profile.picture;
          document.getElementById('user-avatar').src = googlePicture;
          document.getElementById('preview-avatar').src = googlePicture;
          
          // Update current user data
          currentUser.custom_avatar = null;
          currentUser.avatar_filename = null;
          
          // Hide reset button
          document.getElementById('reset-avatar-btn').style.display = 'none';
          
          showMessage(`Profile picture reset successfully. ${data.filesDeleted} avatar file(s) deleted.`, 'success');
        } else {
          const error = await response.json();
          showMessage(error.error || 'Failed to reset profile picture', 'error');
        }
      } catch (error) {
        showMessage('Failed to reset profile picture', 'error');
      }
    }
    
    async function updateNickname() {
      const nickname = document.getElementById('nickname-input').value.trim();
      const errorEl = document.getElementById('nickname-error');
      
      // Clear previous error
      errorEl.style.display = 'none';
      errorEl.textContent = '';
      
      // Client-side validation
      if (nickname) {
        if (nickname.length < 3) {
          errorEl.textContent = 'Nickname must be at least 3 characters long';
          errorEl.style.display = 'block';
          return;
        }
        
        if (nickname.length > 50) {
          errorEl.textContent = 'Nickname must be 50 characters or less';
          errorEl.style.display = 'block';
          return;
        }
        
        if (!/^[a-zA-Z0-9_\-\s]+$/.test(nickname)) {
          errorEl.textContent = 'Nickname can only contain letters, numbers, spaces, underscores, and hyphens';
          errorEl.style.display = 'block';
          return;
        }
      }
      
      try {
        const response = await window.csrfHelper.fetchWithCSRF('/api/user/profile/nickname', {
          method: 'PUT',
          body: { nickname }
        });
        
        if (response.ok) {
          const data = await response.json();
          
          // Update display name
          const newDisplayName = nickname || currentUser.name;
          document.getElementById('user-name').textContent = newDisplayName;
          
          // Update current user data
          currentUser.nickname = nickname;
          currentUser.displayName = newDisplayName;
          
          showMessage('Display name updated successfully', 'success');
          errorEl.style.display = 'none';
        } else {
          const error = await response.json();
          errorEl.textContent = error.error || 'Failed to update nickname';
          errorEl.style.display = 'block';
        }
      } catch (error) {
        errorEl.textContent = 'Failed to update nickname';
        errorEl.style.display = 'block';
      }
    }

    // Helper functions for safe DOM manipulation
    function createTextCell(text) {
      const cell = document.createElement('td');
      cell.textContent = text;
      return cell;
    }
    
    function createImageCell(avatarUrl, googleUrl, alt) {
      const cell = document.createElement('td');
      cell.style.textAlign = 'center';
      const img = document.createElement('img');
      img.src = avatarUrl || googleUrl;
      img.alt = alt;
      img.style.width = '32px';
      img.style.height = '32px';
      img.style.borderRadius = '50%';
      img.style.objectFit = 'cover';
      
      // Add fallback to Google avatar on error
      if (avatarUrl && googleUrl && avatarUrl !== googleUrl) {
        img.onerror = function() {
          this.onerror = null; // Prevent infinite loop
          this.src = googleUrl;
        };
      }
      
      cell.appendChild(img);
      return cell;
    }
    
    function createXPCell(xp) {
      const cell = document.createElement('td');
      cell.style.color = '#FFD700';
      cell.style.fontWeight = 'bold';
      cell.textContent = xp;
      return cell;
    }
    
    function createHTMLCell(html) {
      const cell = document.createElement('td');
      cell.innerHTML = html; // This is safe because statusBadge is generated by our code
      return cell;
    }
    
    function createButtonCell(userId) {
      const cell = document.createElement('td');
      const button = document.createElement('button');
      button.className = 'small-btn info-btn';
      button.onclick = () => viewUserDetails(userId);
      const span = document.createElement('span');
      span.className = 'btn-icon';
      span.textContent = '';
      button.appendChild(span);
      button.appendChild(document.createTextNode('Details'));
      cell.appendChild(button);
      return cell;
    }

    // Setup event listeners after DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      // Expose POI action functions to window for event delegation
      window.goToPoi = goToPoi;
      window.sharePoi = sharePoi;
      window.deletePoi = deletePoi;
      window.publishPoi = publishPoi;
      window.votePoi = votePoi;
      
      // Expose modal and admin functions to window for event delegation
      window.closeVoteModal = closeVoteModal;
      window.closeXPModal = closeXPModal;
      window.updateUserXP = updateUserXP;
      window.closeUserModal = closeUserModal;
      window.showXPAdjustment = showXPAdjustment;
      window.banUser = banUser;
      window.unbanUser = unbanUser;
      window.warnUser = warnUser;
      window.logoutUser = logoutUser;
      window.viewUserPois = viewUserPois;
      window.toggleAdminStatus = toggleAdminStatus;
      window.changeUsersPage = changeUsersPage;
      
      // Note: Voting functions will be exposed after they are defined
      
      // Handle all data-action elements
      document.addEventListener('click', function(e) {
        
        // Find the closest element with data-action attribute
        const actionElement = e.target.closest('[data-action]');
        if (!actionElement) {
          return;
        }
        
        const action = actionElement.getAttribute('data-action');
        if (action) {
          e.preventDefault();
          const args = actionElement.getAttribute('data-args');
          
          // Call the appropriate function
          if (window[action]) {
            if (args) {
              // Parse arguments and call function
              try {
                // Handle multiple comma-separated arguments
                if (args.includes(',')) {
                  // Split by comma and trim whitespace
                  const argArray = args.split(',').map(arg => {
                    arg = arg.trim();
                    // Convert to number if it's a number
                    if (arg.match(/^-?\d+$/)) {
                      return parseInt(arg);
                    }
                    // Handle boolean strings
                    if (arg === 'true') return true;
                    if (arg === 'false') return false;
                    // Remove quotes if present
                    if ((arg.startsWith("'") && arg.endsWith("'")) || 
                        (arg.startsWith('"') && arg.endsWith('"'))) {
                      return arg.slice(1, -1);
                    }
                    return arg;
                  });
                  // Call function with spread arguments
                  window[action](...argArray);
                } else {
                  // Single argument
                  if (args.match(/^-?\d+$/)) {
                    window[action](parseInt(args));
                  } else if (args.match(/^'.*'$/) || args.match(/^".*"$/)) {
                    window[action](args.slice(1, -1));
                  } else {
                    window[action](args);
                  }
                }
              } catch (error) {
                console.error('Error calling function:', action, error);
              }
            } else {
              window[action]();
            }
          } else {
            console.error('Function not found:', action);
          }
        }
      });
      
      // Tab navigation
      document.querySelectorAll('.nav-item').forEach(button => {
        const tabName = button.textContent.includes('Profile') ? 'profile' :
                       button.textContent.includes('Preferences') ? 'preferences' :
                       button.textContent.includes('Privacy') ? 'privacy' :
                       button.textContent.includes('Custom POIs') ? 'custom-pois' :
                       button.textContent.includes('Voting') ? 'voting' :
                       button.textContent.includes('Admin') ? 'admin' : null;
        
        if (tabName) {
          button.addEventListener('click', () => showTab(tabName));
        }
      });
      
      // Preferences tab buttons
      const resetAvatarBtn = document.getElementById('reset-avatar-btn');
      if (resetAvatarBtn) {
        resetAvatarBtn.addEventListener('click', resetAvatar);
      }
      
      // Save nickname button
      const saveNicknameBtn = document.getElementById('save-nickname-btn');
      if (saveNicknameBtn) {
        saveNicknameBtn.addEventListener('click', updateNickname);
      }
      
      // Privacy tab buttons
      const deleteAccountBtn = document.getElementById('delete-account-btn');
      if (deleteAccountBtn) {
        deleteAccountBtn.addEventListener('click', deleteAccount);
      }
      
      const logoutAllBtn = document.getElementById('logout-all-btn');
      if (logoutAllBtn) {
        logoutAllBtn.addEventListener('click', logoutAll);
      }
      
      // Pagination buttons
      const myPoisPrev = document.getElementById('my-pois-prev');
      if (myPoisPrev) {
        myPoisPrev.addEventListener('click', () => changeMyPoisPage(-1));
      }
      
      const myPoisNext = document.getElementById('my-pois-next');
      if (myPoisNext) {
        myPoisNext.addEventListener('click', () => changeMyPoisPage(1));
      }
      
      const sharedPoisPrev = document.getElementById('shared-pois-prev');
      if (sharedPoisPrev) {
        sharedPoisPrev.addEventListener('click', () => changeSharedPoisPage(-1));
      }
      
      const sharedPoisNext = document.getElementById('shared-pois-next');
      if (sharedPoisNext) {
        sharedPoisNext.addEventListener('click', () => changeSharedPoisPage(1));
      }
      
      // Admin search button
      const adminSearchBtn = document.querySelector('.admin-controls button');
      if (adminSearchBtn && adminSearchBtn.textContent === 'Search') {
        adminSearchBtn.addEventListener('click', searchUsers);
      }
      
      // Users pagination
      const usersPrev = document.getElementById('users-prev');
      if (usersPrev) {
        usersPrev.addEventListener('click', () => changeUsersPage(-1));
      }
      
      const usersNext = document.getElementById('users-next');
      if (usersNext) {
        usersNext.addEventListener('click', () => changeUsersPage(1));
      }
    });

    // Function to load initial proposal count
    async function loadInitialProposalCount() {
      try {
        const response = await fetch('/api/change-proposals');
        if (response.ok) {
          const proposals = await response.json();
          updateVotingTabCount(proposals.length);
        }
      } catch (error) {
        console.error('Error loading initial proposal count:', error);
      }
    }
    
    // Helper function to update voting tab count
    function updateVotingTabCount(count) {
      const votingTabBtn = document.getElementById('voting-tab-btn');
      if (votingTabBtn) {
        if (count > 0) {
          votingTabBtn.innerHTML = ` Voting (${count})`;
        } else {
          votingTabBtn.innerHTML = ' Voting';
        }
      }
    }

    // Initialize
    checkAuth().then(() => {
      // Check for hash navigation after auth is complete
      if (window.location.hash) {
        const tab = window.location.hash.substring(1); // Remove the # symbol
        if (tab === 'voting') {
          // Ensure user is authenticated before showing voting tab
          if (document.getElementById('voting-tab')) {
            showTab('voting');
          }
        }
      }
    });
    
    // Load initial proposal count for voting tab
    loadInitialProposalCount();
    
    // Handle hash changes for navigation
    window.addEventListener('hashchange', () => {
      if (window.location.hash) {
        const tab = window.location.hash.substring(1);
        if (tab === 'voting' && document.getElementById('voting-tab')) {
          showTab('voting');
        }
      }
    });
    
    // Set up periodic ban checks
    setInterval(checkBanStatus, 30000); // Check every 30 seconds
    
    // Check ban status on visibility change
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden) {
        checkBanStatus();
      }
    });
    
    // Check ban status on window focus
    window.addEventListener('focus', checkBanStatus);
    
    // Intercept clicks on interactive elements
    document.addEventListener('click', async (event) => {
      // Check if clicked element is interactive
      const target = event.target;
      if (target.matches('button, a, input[type="submit"], .tab-btn, .admin-section-header') || 
          target.closest('button, a, input[type="submit"], .tab-btn, .admin-section-header')) {
        // Check ban status before allowing action
        const isBanned = await checkBanStatus();
        if (isBanned) {
          event.preventDefault();
          event.stopPropagation();
        }
      }
    }, true); // Use capture phase
    
    // Handle URL parameters
    const urlParams = new URLSearchParams(window.location.search);
    const tab = urlParams.get('tab');
    const section = urlParams.get('section');
    const highlightId = urlParams.get('highlight');
    
    // Store highlight ID for later use
    window.poiEditorHighlightId = highlightId;
    
    // Add click handlers for sortable table headers
    document.addEventListener('click', (e) => {
      if (e.target.matches('.poi-editor-table th[data-sort]')) {
        const field = e.target.dataset.sort;
        
        // Update sort direction
        if (sortField === field) {
          sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
        } else {
          sortField = field;
          sortDirection = 'asc';
        }
        
        // Update header classes
        document.querySelectorAll('.poi-editor-table th').forEach(th => {
          th.classList.remove('sorted-asc', 'sorted-desc');
        });
        e.target.classList.add(sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');
        
        // Re-apply filters and display
        applySearchFilter();
      }
    });
  </script>

  <!-- Share Code Modal -->
  <div id="share-code-modal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 500px;">
      <div class="modal-header">
        <h3>Share POI</h3>
        <button class="close-btn" onclick="closeShareCodeModal()"></button>
      </div>
      <div class="modal-body">
        <p style="margin-bottom: 1rem;">Share this code with others to let them add this POI to their map:</p>
        
        <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 1.5rem;">
          <input type="text" id="share-code-display" readonly 
                 style="flex: 1; padding: 1rem; font-size: 1.5rem; font-family: monospace; 
                        text-align: center; letter-spacing: 2px; background: #2d2d2d; 
                        border: 2px solid #4a7c59; border-radius: 8px; color: #4dff4d;">
          <button class="btn" onclick="copyShareCode()" style="padding: 1rem;">
             Copy
          </button>
        </div>
        
        <div id="share-users-section" style="display: none; margin-top: 2rem; padding-top: 2rem; border-top: 1px solid #444;">
          <h4 style="color: #FFD700; margin-bottom: 1rem;">Users sharing this POI:</h4>
          <div id="share-users-list" style="max-height: 200px; overflow-y: auto;"></div>
        </div>
        
        <div style="margin-top: 2rem; padding-top: 2rem; border-top: 1px solid #444;">
          <p style="color: #999; font-size: 0.9rem; margin-bottom: 1rem;">
             Creating a new share code will invalidate the previous code and remove access for all users who were using it.
          </p>
          <div style="display: flex; gap: 1rem;">
            <button class="btn secondary-btn" onclick="regenerateShareCode()">
               Generate New Code
            </button>
            <button class="btn danger-btn" onclick="revokeShareCode()">
               Revoke Share
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Share Users Modal -->
  <div id="share-users-modal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 500px;">
      <div class="modal-header">
        <h3 id="share-users-title">Users Sharing This POI</h3>
        <button class="close-btn" onclick="closeShareUsersModal()"></button>
      </div>
      <div class="modal-body">
        <div id="share-users-loading" style="text-align: center; padding: 2rem;">
          Loading users...
        </div>
        <div id="share-users-content" style="display: none;">
          <div id="share-users-list-modal" style="max-height: 400px; overflow-y: auto;"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Add Shared POI Modal -->
  <div id="add-shared-poi-modal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 400px; height: auto; margin-top: 10%; margin-bottom: auto;">
      <div class="modal-header">
        <h3>Add Shared POI</h3>
        <button class="close-btn" onclick="closeAddSharedPOIModal()"></button>
      </div>
      <div class="modal-body">
        <p style="margin-bottom: 1rem;">Enter the share code you received:</p>
        
        <input type="text" id="share-code-input" placeholder="Enter share code" maxlength="10"
               style="width: 100%; padding: 1rem; font-size: 1.2rem; font-family: monospace; 
                      text-align: center; letter-spacing: 2px; text-transform: uppercase;
                      background: #2d2d2d; border: 2px solid #555; border-radius: 8px; 
                      color: #e0e0e0; margin-bottom: 1.5rem;"
               onkeyup="this.value = this.value.toUpperCase().replace(/[^A-Z0-9]/g, '')"
               onkeypress="if(event.key === 'Enter') addSharedPOI()">
        
        <!-- Admin Test Button -->
        <div id="admin-test-share-container" style="display: none; margin-bottom: 1rem; text-align: center;">
          <button class="btn btn-sm" onclick="insertSystemShareCode()" style="background: #dc3545; font-size: 0.85rem;">
             Insert System Test Code
          </button>
          <p style="font-size: 0.8rem; color: #999; margin-top: 0.5rem;">
            Admin only: Inserts test POIs from System account
          </p>
        </div>
        
        <div style="display: flex; gap: 1rem;">
          <button class="btn" onclick="addSharedPOI()" style="flex: 1;">
             Add POI
          </button>
          <button class="btn secondary-btn" onclick="closeAddSharedPOIModal()">
            Cancel
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Batch NPC Import Modal -->
  <div id="batch-npc-import-modal" class="modal" style="display: none;">
    <div id="batch-import-modal-content" class="modal-content" style="max-width: 1200px; width: 90%; max-height: 90vh; display: flex; flex-direction: column;">
      <div class="modal-header" style="padding: 1.5rem;">
        <h2 style="margin: 0;">Batch Import NPCs from Wiki</h2>
        <span class="close" onclick="closeBatchNPCImport()" style="font-size: 2rem;">&times;</span>
      </div>
      <div class="modal-body" style="padding: 2rem; flex: 1; overflow-y: auto;">
        <!-- Step 1: URL Input -->
        <div id="batch-import-step1" style="display: block;">
          <p style="margin-bottom: 1rem;">Enter the URL of a Monsters & Memories wiki page containing NPCs:</p>
          <div style="display: flex; gap: 1rem; align-items: center;">
            <input 
              type="url" 
              id="batch-import-url" 
              placeholder="https://monstersandmemories.miraheze.org/wiki/Category:NPCs"
              value="https://monstersandmemories.miraheze.org/wiki/Category:NPCs"
              style="flex: 1; padding: 0.5rem; border: 1px solid #555; border-radius: 4px; background: #2d2d2d; color: #e0e0e0;"
            />
            <button onclick="scanWikiPage()" class="primary-btn">
              <span style="margin-right: 0.5rem;"></span>Scan
            </button>
          </div>
          <div id="scan-status" style="margin-top: 1rem; display: none;">
            <div class="loading-spinner"></div>
            <p>Scanning wiki page...</p>
          </div>
        </div>

        <!-- Step 2: NPC Selection -->
        <div id="batch-import-npc-step2" style="display: none; height: 100%; flex-direction: column;">
          <div id="scan-results-summary" style="padding: 1rem; background: #2d2d2d; border-radius: 4px; flex-shrink: 0;">
            <h3>Scan Results</h3>
            <p>Found <span id="total-npcs-found">0</span> NPCs on the page</p>
            <p style="color: #4ade80;"> New NPCs: <span id="new-npcs-count">0</span></p>
            <p style="color: #fbbf24;"> Existing NPCs: <span id="existing-npcs-count">0</span></p>
          </div>
          
          <div id="npc-lists" style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin: 1rem 0; flex: 1; min-height: 0;">
            <div style="display: flex; flex-direction: column; min-height: 0;">
              <h4 style="color: #4ade80; margin-bottom: 0.5rem; flex-shrink: 0;">New NPCs</h4>
              <div id="new-npcs-list" style="flex: 1; overflow-y: auto; background: #2d2d2d; padding: 0.5rem; border-radius: 4px; min-height: 200px;">
                <!-- Will be populated dynamically -->
              </div>
            </div>
            <div style="display: flex; flex-direction: column; min-height: 0;">
              <h4 style="color: #fbbf24; margin-bottom: 0.5rem; flex-shrink: 0;">Existing NPCs (will be updated)</h4>
              <div id="existing-npcs-list" style="flex: 1; overflow-y: auto; background: #2d2d2d; padding: 0.5rem; border-radius: 4px; min-height: 200px;">
                <!-- Will be populated dynamically -->
              </div>
            </div>
          </div>
          
          <div style="display: flex; gap: 1rem; justify-content: center; padding: 1rem 0; flex-shrink: 0;">
            <button onclick="extractNPCs('all')" class="primary-btn">
              <span style="margin-right: 0.5rem;"></span>Extract All
            </button>
            <button onclick="extractNPCs('new')" class="secondary-btn">
              <span style="margin-right: 0.5rem;"></span>Extract New Only
            </button>
            <button onclick="closeBatchNPCImport()" class="secondary-btn">
              Cancel
            </button>
          </div>
          
          <div id="extraction-status" style="margin-top: 2rem; display: none;">
            <div style="margin-bottom: 1rem;">
              <div style="display: flex; align-items: center; gap: 1rem;">
                <div class="loading-spinner"></div>
                <h4 style="margin: 0;">Extracting NPC Data</h4>
              </div>
              <p style="margin-top: 0.5rem;">Progress: <span id="extraction-progress">0</span> / <span id="extraction-total">0</span> NPCs</p>
            </div>
            <div id="extraction-details" style="background: #1a1a1a; border: 1px solid #333; border-radius: 4px; padding: 1rem; max-height: 350px; overflow-y: auto; font-family: monospace; font-size: 0.9rem;">
              <!-- Extraction logs will appear here -->
            </div>
          </div>
        </div>

        <!-- Step 3: Review and Save -->
        <div id="batch-import-step3" style="display: none; height: 100%; flex-direction: column;">
          <h3 style="margin-bottom: 1.5rem; flex-shrink: 0;">Review Extracted NPCs</h3>
          <p style="margin-bottom: 1rem; font-size: 1.1rem; flex-shrink: 0;">Select which NPCs to import:</p>
          <div style="background: #2d2d2d; border: 1px solid #555; border-radius: 4px; padding: 1rem; margin-bottom: 1rem; flex-shrink: 0;">
            <p style="margin: 0; color: #60a5fa;">
              <strong>Note:</strong> For existing NPCs, only non-zero values will be updated. 
              Existing data like custom loot tables, manually entered stats, or other fields will be preserved if the imported value is 0 or empty.
            </p>
          </div>
          
          <div style="margin-bottom: 1.5rem; flex-shrink: 0;">
            <button onclick="selectAllNPCs(true)" class="btn" style="margin-right: 0.5rem; padding: 0.75rem 1.5rem;">Select All</button>
            <button onclick="selectAllNPCs(false)" class="btn" style="padding: 0.75rem 1.5rem;">Deselect All</button>
          </div>
          
          <div style="overflow-x: auto; overflow-y: auto; border: 1px solid #333; border-radius: 4px; flex: 1; min-height: 0;">
            <table id="extracted-npcs-table" class="npc-editor-table" style="width: 100%;">
              <thead style="position: sticky; top: 0; background: #1a1a1a; z-index: 10;">
                <tr>
                  <th style="width: 50px; padding: 1rem;">
                    <input type="checkbox" id="select-all-npcs" onchange="selectAllNPCs(this.checked)">
                  </th>
                  <th style="padding: 1rem; min-width: 200px;">Name</th>
                  <th style="padding: 1rem; min-width: 100px;">Type</th>
                  <th style="padding: 1rem; min-width: 80px;">Level</th>
                  <th style="padding: 1rem; min-width: 80px;">HP</th>
                  <th style="padding: 1rem; min-width: 80px;">AC</th>
                  <th style="padding: 1rem; min-width: 100px;">Status</th>
                  <th style="padding: 1rem; min-width: 100px;">Wiki Link</th>
                </tr>
              </thead>
              <tbody id="extracted-npcs-tbody">
                <!-- Will be populated dynamically -->
              </tbody>
            </table>
          </div>
          
          <div style="margin-top: 1rem; display: flex; gap: 1rem; justify-content: center; flex-shrink: 0; padding: 1rem 0;">
            <button onclick="saveExtractedNPCs()" class="primary-btn">
              <span style="margin-right: 0.5rem;"></span>Save Selected NPCs
            </button>
            <button onclick="closeBatchNPCImport()" class="secondary-btn">
              Cancel
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Share code modal functions
    let currentSharePoiId = null;

    function showShareCodeModal(shareCode, poiId) {
      currentSharePoiId = poiId;
      document.getElementById('share-code-display').value = shareCode;
      document.getElementById('share-code-modal').style.display = 'flex';
      
      // Load users who have this POI shared
      loadShareUsers(poiId);
    }

    function closeShareCodeModal() {
      document.getElementById('share-code-modal').style.display = 'none';
      currentSharePoiId = null;
    }

    function copyShareCode() {
      const shareCode = document.getElementById('share-code-display').value;
      navigator.clipboard.writeText(shareCode).then(() => {
        showMessage('Share code copied to clipboard!', 'success');
      }).catch(() => {
        // Fallback
        document.getElementById('share-code-display').select();
        document.execCommand('copy');
        showMessage('Share code copied!', 'success');
      });
    }

    async function loadShareUsers(poiId) {
      try {
        const response = await fetch(`/api/custom-pois/${poiId}/shared-users`);
        if (response.ok) {
          const data = await response.json();
          const section = document.getElementById('share-users-section');
          const list = document.getElementById('share-users-list');
          
          if (data.users.length > 0) {
            section.style.display = 'block';
            list.innerHTML = data.users.map(user => `
              <div style="padding: 0.5rem; border-bottom: 1px solid #333;">
                <span style="color: #FFD700;">${window.escapeHTML(user.display_name)}</span>
                <span style="color: #999; font-size: 0.85rem; margin-left: 1rem;">
                  Added ${new Date(user.added_at).toLocaleDateString()}
                </span>
              </div>
            `).join('');
          } else {
            section.style.display = 'none';
          }
        }
      } catch (error) {
        console.error('Error loading share users:', error);
      }
    }

    async function regenerateShareCode() {
      if (!confirm('Are you sure? This will invalidate the current share code and remove access for all users currently using it.')) {
        return;
      }
      
      try {
        const response = await window.csrfHelper.fetchWithCSRF(`/api/custom-pois/${currentSharePoiId}/share`, {
          method: 'POST'
        });
        
        if (response.ok) {
          const data = await response.json();
          document.getElementById('share-code-display').value = data.shareCode;
          showMessage('New share code generated', 'success');
          loadShareUsers(currentSharePoiId);
        } else {
          const error = await response.json();
          showMessage(error.error || 'Failed to generate new code', 'error');
        }
      } catch (error) {
        showMessage('Failed to generate new code', 'error');
      }
    }

    async function revokeShareCode() {
      if (!confirm('Are you sure? This will revoke the share code and remove access for all users currently using it.')) {
        return;
      }
      
      try {
        const response = await window.csrfHelper.fetchWithCSRF(`/api/custom-pois/${currentSharePoiId}/revoke-share`, {
          method: 'POST'
        });
        
        if (response.ok) {
          showMessage('Share code revoked', 'success');
          closeShareCodeModal();
          loadCustomPois(); // Refresh the list
        } else {
          const error = await response.json();
          showMessage(error.error || 'Failed to revoke share', 'error');
        }
      } catch (error) {
        showMessage('Failed to revoke share', 'error');
      }
    }

    // Add shared POI modal functions
    function showAddSharedPOIModal() {
      document.getElementById('share-code-input').value = '';
      document.getElementById('add-shared-poi-modal').style.display = 'flex';
      document.getElementById('share-code-input').focus();
      
      // Show admin test button if user is admin
      const adminContainer = document.getElementById('admin-test-share-container');
      if (currentUser && currentUser.is_admin) {
        adminContainer.style.display = 'block';
      } else {
        adminContainer.style.display = 'none';
      }
    }

    function closeAddSharedPOIModal() {
      document.getElementById('add-shared-poi-modal').style.display = 'none';
    }
    
    // System test share code - for admins only
    const SYSTEM_SHARE_CODE = 'SYSTEST001';
    
    function insertSystemShareCode() {
      document.getElementById('share-code-input').value = SYSTEM_SHARE_CODE;
      document.getElementById('share-code-input').focus();
    }

    async function addSharedPOI() {
      const shareCode = document.getElementById('share-code-input').value.trim();
      
      if (!shareCode) {
        showMessage('Please enter a share code', 'error');
        return;
      }
      
      try {
        const response = await window.csrfHelper.fetchWithCSRF('/api/custom-pois/add-shared', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ shareCode })
        });
        
        if (response.ok) {
          const data = await response.json();
          showMessage(`Added "${data.poi.name}" from ${data.poi.owner_name}`, 'success');
          closeAddSharedPOIModal();
          loadCustomPois(); // Refresh the list
        } else {
          let errorMessage = 'Failed to add shared POI';
          try {
            const error = await response.json();
            errorMessage = error.error || errorMessage;
          } catch (e) {
            // If response isn't JSON, use default error message
          }
          showMessage(errorMessage, 'error');
        }
      } catch (error) {
        showMessage('Failed to add shared POI', 'error');
      }
    }

    // Share users modal functions
    async function showShareUsersModal(poiId, poiName) {
      document.getElementById('share-users-title').textContent = `Users Sharing "${poiName}"`;
      document.getElementById('share-users-modal').style.display = 'flex';
      document.getElementById('share-users-loading').style.display = 'block';
      document.getElementById('share-users-content').style.display = 'none';
      
      try {
        const response = await fetch(`/api/custom-pois/${poiId}/shared-users`);
        if (response.ok) {
          const data = await response.json();
          const listEl = document.getElementById('share-users-list-modal');
          
          if (data.users.length > 0) {
            listEl.innerHTML = data.users.map(user => `
              <div style="padding: 1rem; border-bottom: 1px solid #333;">
                <div style="font-size: 1.1rem; color: #FFD700; margin-bottom: 0.25rem;">
                  ${window.escapeHTML(user.display_name)}
                </div>
                <div style="color: #999; font-size: 0.9rem;">
                  Added ${new Date(user.added_at).toLocaleDateString()} at ${new Date(user.added_at).toLocaleTimeString()}
                </div>
              </div>
            `).join('');
          } else {
            listEl.innerHTML = '<div style="text-align: center; padding: 2rem; color: #999;">No users have added this POI yet.</div>';
          }
          
          document.getElementById('share-users-loading').style.display = 'none';
          document.getElementById('share-users-content').style.display = 'block';
        } else {
          showMessage('Failed to load users', 'error');
          closeShareUsersModal();
        }
      } catch (error) {
        console.error('Error loading share users:', error);
        showMessage('Failed to load users', 'error');
        closeShareUsersModal();
      }
    }

    function closeShareUsersModal() {
      document.getElementById('share-users-modal').style.display = 'none';
    }
    
    // Helper function to view shared users from the table
    function viewSharedUsers(poiId) {
      const poi = customPois.find(p => p.id === poiId);
      if (poi) {
        showShareUsersModal(poiId, poi.name);
      }
    }

    // POI Type Management Functions
    let poiTypes = [];
    let editingPOIType = null;
    let currentEmojiCategory = 'harvest';
    let currentPOITypePage = 0;
    const POI_TYPES_PER_PAGE = 10;
    
    const emojiCategories = {
      harvest: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''],
      plants: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''],
      rpg: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''],
      locations: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''],
      map: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''],
      creatures: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''],
      weather: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''],
      items: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''],
      food: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''],
      symbols: ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '']
    };
    
    // NPC Editor Functions
    let npcs = [];
    let filteredNpcs = [];
    let currentNpcPage = 0;
    const NPCS_PER_PAGE = 20;
    let npcChanges = new Map(); // Track staged changes for NPCs
    let selectedItemsForLoot = []; // For loot selection modal
    
    // Toast notification function
    function showToast(message, type = 'info') {
      // Create toast container if it doesn't exist
      let toastContainer = document.getElementById('toast-container');
      if (!toastContainer) {
        toastContainer = document.createElement('div');
        toastContainer.id = 'toast-container';
        toastContainer.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          z-index: 20000;
          display: flex;
          flex-direction: column;
          gap: 10px;
        `;
        document.body.appendChild(toastContainer);
      }
      
      // Create toast element
      const toast = document.createElement('div');
      toast.className = 'toast toast-' + type;
      
      // Set colors based on type
      const colors = {
        success: '#4CAF50',
        error: '#f44336',
        warning: '#FF9800',
        info: '#2196F3'
      };
      
      toast.style.cssText = `
        background: ${colors[type] || colors.info};
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        font-size: 14px;
        font-weight: 500;
        animation: slideIn 0.3s ease-out;
        cursor: pointer;
        max-width: 350px;
        word-wrap: break-word;
      `;
      
      toast.textContent = message;
      
      // Add click to dismiss
      toast.addEventListener('click', () => {
        toast.style.animation = 'slideOut 0.3s ease-out';
        setTimeout(() => toast.remove(), 300);
      });
      
      // Add to container
      toastContainer.appendChild(toast);
      
      // Auto remove after 5 seconds
      setTimeout(() => {
        if (toast.parentNode) {
          toast.style.animation = 'slideOut 0.3s ease-out';
          setTimeout(() => toast.remove(), 300);
        }
      }, 5000);
    }
    
    // Add CSS animations for toast
    if (!document.getElementById('toast-animations')) {
      const style = document.createElement('style');
      style.id = 'toast-animations';
      style.textContent = `
        @keyframes slideIn {
          from {
            transform: translateX(100%);
            opacity: 0;
          }
          to {
            transform: translateX(0);
            opacity: 1;
          }
        }
        @keyframes slideOut {
          from {
            transform: translateX(0);
            opacity: 1;
          }
          to {
            transform: translateX(100%);
            opacity: 0;
          }
        }
      `;
      document.head.appendChild(style);
    }
    
    // Batch Import Variables
    let scannedNPCs = [];
    let extractedNPCs = [];
    
    // Batch Import Functions
    function showBatchNPCImport() {
      const modal = document.getElementById('batch-npc-import-modal');
      const modalContent = document.getElementById('batch-import-modal-content');
      
      modal.style.display = 'block';
      document.getElementById('batch-import-step1').style.display = 'block';
      document.getElementById('batch-import-npc-step2').style.display = 'none';
      document.getElementById('batch-import-step3').style.display = 'none';
      
      // Start with smaller height for step 1
      modalContent.style.height = 'auto';
      
      // Prevent body scroll when modal is open
      document.body.style.overflow = 'hidden';
    }
    
    function closeBatchNPCImport() {
      document.getElementById('batch-npc-import-modal').style.display = 'none';
      scannedNPCs = [];
      extractedNPCs = [];
      
      // Re-enable body scroll
      document.body.style.overflow = '';
    }
    
    async function scanWikiPage() {
      const url = document.getElementById('batch-import-url').value;
      if (!url) {
        showToast('Please enter a URL', 'error');
        return;
      }
      
      document.getElementById('scan-status').style.display = 'block';
      
      try {
        const response = await window.csrfHelper.fetchWithCSRF('/api/npcs/scan-wiki', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ url })
        });
        
        if (!response.ok) throw new Error('Failed to scan wiki page');
        
        const data = await response.json();
        scannedNPCs = data.npcs || [];
        
        // Check which NPCs already exist
        const existingNames = npcs.map(n => n.name.toLowerCase());
        const newNPCs = scannedNPCs.filter(n => !existingNames.includes(n.name.toLowerCase()));
        const existingNPCs = scannedNPCs.filter(n => existingNames.includes(n.name.toLowerCase()));
        
        // Update UI
        document.getElementById('total-npcs-found').textContent = scannedNPCs.length;
        document.getElementById('new-npcs-count').textContent = newNPCs.length;
        document.getElementById('existing-npcs-count').textContent = existingNPCs.length;
        
        // Populate lists
        const newList = document.getElementById('new-npcs-list');
        const existingList = document.getElementById('existing-npcs-list');
        
        newList.innerHTML = newNPCs.length > 0 
          ? newNPCs.map(n => `<div style="padding: 0.25rem;">${n.name}</div>`).join('')
          : '<div style="color: #666;">No new NPCs found</div>';
        
        existingList.innerHTML = existingNPCs.length > 0
          ? existingNPCs.map(n => `<div style="padding: 0.25rem;">${n.name}</div>`).join('')
          : '<div style="color: #666;">No existing NPCs found</div>';
        
        // Show step 2 and expand modal
        document.getElementById('scan-status').style.display = 'none';
        document.getElementById('batch-import-step1').style.display = 'none';
        const step2 = document.getElementById('batch-import-npc-step2');
        step2.style.display = 'flex'; // Use flex instead of block
        
        // Expand modal to full height for step 2
        const modalContent = document.getElementById('batch-import-modal-content');
        modalContent.style.height = '90vh';
        
      } catch (error) {
        console.error('Error scanning wiki:', error);
        showToast('Failed to scan wiki page: ' + error.message, 'error');
        document.getElementById('scan-status').style.display = 'none';
      }
    }
    
    async function extractNPCs(mode) {
      const npcsToExtract = mode === 'new' 
        ? scannedNPCs.filter(n => !npcs.some(existing => existing.name.toLowerCase() === n.name.toLowerCase()))
        : scannedNPCs;
      
      if (npcsToExtract.length === 0) {
        showToast('No NPCs to extract', 'warning');
        return;
      }
      
      document.getElementById('extraction-status').style.display = 'block';
      document.getElementById('extraction-progress').textContent = '0';
      document.getElementById('extraction-total').textContent = npcsToExtract.length;
      
      const detailsDiv = document.getElementById('extraction-details');
      detailsDiv.innerHTML = '';
      extractedNPCs = [];
      
      for (let i = 0; i < npcsToExtract.length; i++) {
        const npc = npcsToExtract[i];
        document.getElementById('extraction-progress').textContent = i + 1;
        
        // Add status message
        const statusMsg = document.createElement('div');
        statusMsg.innerHTML = `<span style="color: #60a5fa;">[${i + 1}/${npcsToExtract.length}]</span> Extracting: ${npc.name}...`;
        detailsDiv.appendChild(statusMsg);
        detailsDiv.scrollTop = detailsDiv.scrollHeight;
        
        try {
          const response = await window.csrfHelper.fetchWithCSRF('/api/npcs/extract-wiki', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ url: npc.url })
          });
          
          if (response.ok) {
            const extractedData = await response.json();
            extractedNPCs.push({
              ...extractedData,
              selected: true,
              status: npcs.some(e => e.name.toLowerCase() === extractedData.name.toLowerCase()) ? 'update' : 'new'
            });
            
            // Update status with success
            statusMsg.innerHTML = `<span style="color: #60a5fa;">[${i + 1}/${npcsToExtract.length}]</span> <span style="color: #4ade80;"></span> ${npc.name} - Level ${extractedData.level}, HP: ${extractedData.hp}, AC: ${extractedData.ac}`;
          } else {
            // Update status with error
            statusMsg.innerHTML = `<span style="color: #60a5fa;">[${i + 1}/${npcsToExtract.length}]</span> <span style="color: #ef4444;"></span> ${npc.name} - Failed to extract`;
          }
        } catch (error) {
          console.error(`Failed to extract ${npc.name}:`, error);
          statusMsg.innerHTML = `<span style="color: #60a5fa;">[${i + 1}/${npcsToExtract.length}]</span> <span style="color: #ef4444;"></span> ${npc.name} - Error: ${error.message}`;
        }
      }
      
      // Populate review table
      populateExtractedNPCsTable();
      
      // Show step 3
      document.getElementById('extraction-status').style.display = 'none';
      document.getElementById('batch-import-npc-step2').style.display = 'none';
      const step3 = document.getElementById('batch-import-step3');
      step3.style.display = 'flex'; // Use flex for proper layout
      
      // Keep modal at full height for step 3
      const modalContent = document.getElementById('batch-import-modal-content');
      modalContent.style.height = '90vh';
    }
    
    function populateExtractedNPCsTable() {
      const tbody = document.getElementById('extracted-npcs-tbody');
      tbody.innerHTML = extractedNPCs.map((npc, index) => `
        <tr>
          <td style="padding: 0.75rem;"><input type="checkbox" ${npc.selected ? 'checked' : ''} onchange="toggleNPCSelection(${index})"></td>
          <td style="padding: 0.75rem; font-weight: bold;">${npc.name}</td>
          <td style="padding: 0.75rem;">${npc.npc_type || 'unknown'}</td>
          <td style="padding: 0.75rem; text-align: center;">${npc.level || 0}</td>
          <td style="padding: 0.75rem; text-align: center;">${npc.hp || 0}</td>
          <td style="padding: 0.75rem; text-align: center;">${npc.ac || 0}</td>
          <td style="padding: 0.75rem;">
            <span style="color: ${npc.status === 'new' ? '#4ade80' : '#fbbf24'}; font-weight: bold;">
              ${npc.status === 'new' ? ' New' : ' Update'}
            </span>
          </td>
          <td style="padding: 0.75rem;">
            <a href="${npc.description}" target="_blank" style="color: #60a5fa; text-decoration: none;"> View</a>
          </td>
        </tr>
      `).join('');
    }
    
    function toggleNPCSelection(index) {
      extractedNPCs[index].selected = !extractedNPCs[index].selected;
    }
    
    function selectAllNPCs(selected) {
      extractedNPCs.forEach(npc => npc.selected = selected);
      populateExtractedNPCsTable();
    }
    
    async function saveExtractedNPCs() {
      const selectedNPCs = extractedNPCs.filter(npc => npc.selected);
      
      if (selectedNPCs.length === 0) {
        showToast('No NPCs selected', 'warning');
        return;
      }
      
      try {
        const response = await window.csrfHelper.fetchWithCSRF('/api/npcs/batch-import', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ npcs: selectedNPCs })
        });
        
        if (!response.ok) throw new Error('Failed to save NPCs');
        
        const result = await response.json();
        showToast(`Successfully imported ${result.created} new and updated ${result.updated} existing NPCs`, 'success');
        
        closeBatchNPCImport();
        await loadNPCEditor(); // Reload the NPC editor
        
      } catch (error) {
        console.error('Error saving NPCs:', error);
        showToast('Failed to save NPCs: ' + error.message, 'error');
      }
    }
    
    async function loadNPCEditor() {
      const loading = document.getElementById('npc-editor-loading');
      const content = document.getElementById('npc-editor-content');
      
      try {
        loading.style.display = 'block';
        content.style.display = 'none';
        
        const response = await window.csrfHelper.fetchWithCSRF('/api/npcs');
        if (!response.ok) throw new Error('Failed to load NPCs');
        
        npcs = await response.json();
        filteredNpcs = [...npcs];
        currentNpcPage = 0;
        
        displayNPCs();
        
        loading.style.display = 'none';
        content.style.display = 'block';
      } catch (error) {
        console.error('Error loading NPCs:', error);
        loading.innerHTML = `<p style="color: #ef4444;">Error loading NPCs: ${error.message}</p>`;
      }
    }
    
    function filterNPCsByType() {
      const filterValue = document.getElementById('npc-type-filter').value;
      const searchValue = document.getElementById('npc-search').value.toLowerCase();
      
      filteredNpcs = npcs.filter(npc => {
        const matchesType = filterValue === 'all' || npc.npc_type === filterValue;
        const matchesSearch = !searchValue || 
          npc.name.toLowerCase().includes(searchValue) ||
          (npc.description && npc.description.toLowerCase().includes(searchValue)) ||
          npc.id.toString().includes(searchValue);
        
        return matchesType && matchesSearch;
      });
      
      currentNpcPage = 0;
      displayNPCs();
    }
    
    function searchNPCs() {
      filterNPCsByType();
    }
    
    function displayNPCs() {
      const tbody = document.getElementById('npc-editor-tbody');
      if (!tbody) return; // Element not ready yet
      tbody.innerHTML = '';
      
      const totalPages = Math.ceil(filteredNpcs.length / NPCS_PER_PAGE);
      const startIndex = currentNpcPage * NPCS_PER_PAGE;
      const endIndex = Math.min(startIndex + NPCS_PER_PAGE, filteredNpcs.length);
      const pageNpcs = filteredNpcs.slice(startIndex, endIndex);
      
      // Update counts
      const totalCount = document.getElementById('npc-total-count');
      const filteredCount = document.getElementById('npc-filtered-count');
      if (totalCount) totalCount.textContent = npcs.length;
      if (filteredCount) filteredCount.textContent = filteredNpcs.length;
      
      // Update pagination info
      const paginationInfo = document.getElementById('npc-editor-pagination-info');
      if (paginationInfo) {
        if (filteredNpcs.length > 0) {
          paginationInfo.textContent = `Showing ${startIndex + 1}-${endIndex} of ${filteredNpcs.length} NPCs`;
        } else {
          paginationInfo.textContent = 'No NPCs found';
        }
      }
      
      pageNpcs.forEach(npc => {
        const row = createNPCEditorRow(npc);
        tbody.appendChild(row);
      });
      
      // Update pagination
      displayNPCPagination();
      updateNPCChangeButtons();
    }
    
    function createNPCEditorRow(npc) {
      const row = document.createElement('tr');
      row.id = `npc-row-${npc.id}`;
      
      // Check if marked for deletion
      const change = npcChanges.get(npc.id);
      if (change && change._delete) {
        row.classList.add('marked-for-deletion');
      }
      
      // ID
      const idCell = document.createElement('td');
      idCell.textContent = npc.id;
      row.appendChild(idCell);
      
      // NPC ID
      const npcIdCell = document.createElement('td');
      npcIdCell.textContent = npc.npcid || '-';
      row.appendChild(npcIdCell);
      
      // Type
      const typeCell = document.createElement('td');
      const typeSelect = document.createElement('select');
      typeSelect.className = 'inline-edit';
      typeSelect.dataset.field = 'npc_type';
      typeSelect.dataset.original = npc.npc_type || '';
      
      const npcTypes = [
        'humanoid', 'beast', 'undead', 'elemental', 'dragon',
        'demon', 'construct', 'aberration', 'plant', 'fey'
      ];
      
      npcTypes.forEach(type => {
        const option = document.createElement('option');
        option.value = type;
        option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
        if (type === npc.npc_type) option.selected = true;
        typeSelect.appendChild(option);
      });
      
      typeSelect.onchange = () => stageNPCChange(npc.id, 'npc_type', typeSelect.value);
      typeCell.appendChild(typeSelect);
      row.appendChild(typeCell);
      
      // Name
      const nameCell = document.createElement('td');
      const nameInput = document.createElement('input');
      nameInput.type = 'text';
      nameInput.value = npc.name || '';
      nameInput.className = 'inline-edit';
      nameInput.dataset.field = 'name';
      nameInput.dataset.original = npc.name || '';
      nameInput.onblur = () => stageNPCChange(npc.id, 'name', nameInput.value);
      nameInput.onkeypress = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          nameInput.blur();
        }
      };
      nameCell.appendChild(nameInput);
      row.appendChild(nameCell);
      
      // Description
      const descCell = document.createElement('td');
      const descTextarea = document.createElement('textarea');
      descTextarea.value = npc.description || '';
      descTextarea.className = 'inline-edit';
      descTextarea.style.minHeight = '50px';
      descTextarea.style.resize = 'vertical';
      descTextarea.dataset.field = 'description';
      descTextarea.dataset.original = npc.description || '';
      descTextarea.onblur = () => stageNPCChange(npc.id, 'description', descTextarea.value);
      descCell.appendChild(descTextarea);
      row.appendChild(descCell);
      
      // Loot
      const lootCell = document.createElement('td');
      lootCell.style.cursor = 'pointer';
      lootCell.setAttribute('data-field', 'loot');
      lootCell.setAttribute('data-original', JSON.stringify(npc.loot || []));
      lootCell.onclick = () => showLootSelector(npc.id, npc.loot || []);
      
      // Display loot items if any
      if (npc.loot_items && npc.loot_items.length > 0) {
        const lootDisplay = document.createElement('div');
        lootDisplay.style.display = 'flex';
        lootDisplay.style.flexWrap = 'wrap';
        lootDisplay.style.gap = '4px';
        lootDisplay.style.maxHeight = '60px';
        lootDisplay.style.overflowY = 'auto';
        lootDisplay.style.padding = '4px';
        lootDisplay.style.background = 'rgba(0, 0, 0, 0.2)';
        lootDisplay.style.borderRadius = '4px';
        
        // Add custom scrollbar styles
        lootDisplay.style.cssText += `
          scrollbar-width: thin;
          scrollbar-color: #4a4a4a #2a2a2a;
        `;
        
        // Show item count if many items
        if (npc.loot_items.length > 5) {
          const countBadge = document.createElement('div');
          countBadge.style.cssText = `
            position: absolute;
            top: 2px;
            right: 2px;
            background: #FFD700;
            color: #000;
            padding: 2px 6px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: bold;
            z-index: 1;
          `;
          countBadge.textContent = npc.loot_items.length;
          lootCell.style.position = 'relative';
          lootCell.appendChild(countBadge);
        }
        
        npc.loot_items.forEach((item, index) => {
          const itemChip = document.createElement('span');
          itemChip.style.cssText = `
            padding: 2px 6px;
            background: #4a4a4a;
            border-radius: 3px;
            font-size: 0.8rem;
            white-space: nowrap;
            cursor: default;
            display: inline-flex;
            align-items: center;
            gap: 4px;
          `;
          
          // Add item icon if available
          if (item.icon_type === 'emoji') {
            const icon = document.createElement('span');
            icon.textContent = item.icon_value;
            icon.style.fontSize = '0.9rem';
            itemChip.appendChild(icon);
          }
          
          const itemName = document.createElement('span');
          itemName.textContent = item.name;
          itemChip.appendChild(itemName);
          
          itemChip.title = `${item.name} (ID: ${item.id})`;
          lootDisplay.appendChild(itemChip);
        });
        
        lootCell.appendChild(lootDisplay);
      } else {
        lootCell.innerHTML = '<span style="color: #666;">Click to add loot</span>';
      }
      
      row.appendChild(lootCell);
      
      // HP
      const hpCell = document.createElement('td');
      const hpInput = document.createElement('input');
      hpInput.type = 'number';
      hpInput.value = npc.hp || 0;
      hpInput.className = 'inline-edit';
      hpInput.min = '0';
      hpInput.max = '99999';
      hpInput.dataset.field = 'hp';
      hpInput.dataset.original = npc.hp || 0;
      hpInput.onblur = () => stageNPCChange(npc.id, 'hp', parseInt(hpInput.value) || 0);
      hpInput.onkeypress = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          hpInput.blur();
        }
      };
      hpCell.appendChild(hpInput);
      row.appendChild(hpCell);
      
      // MP
      const mpCell = document.createElement('td');
      const mpInput = document.createElement('input');
      mpInput.type = 'number';
      mpInput.value = npc.mp || 0;
      mpInput.className = 'inline-edit';
      mpInput.min = '0';
      mpInput.max = '99999';
      mpInput.dataset.field = 'mp';
      mpInput.dataset.original = npc.mp || 0;
      mpInput.onblur = () => stageNPCChange(npc.id, 'mp', parseInt(mpInput.value) || 0);
      mpInput.onkeypress = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          mpInput.blur();
        }
      };
      mpCell.appendChild(mpInput);
      row.appendChild(mpCell);
      
      // AC
      const acCell = document.createElement('td');
      const acInput = document.createElement('input');
      acInput.type = 'number';
      acInput.value = npc.ac || 0;
      acInput.className = 'inline-edit stat-input';
      acInput.min = '-50';
      acInput.max = '50';
      acInput.dataset.field = 'ac';
      acInput.dataset.original = npc.ac || 0;
      acInput.onblur = () => stageNPCChange(npc.id, 'ac', parseInt(acInput.value) || 0);
      acInput.onkeypress = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          acInput.blur();
        }
      };
      updateStatInputColor(acInput);
      acCell.appendChild(acInput);
      row.appendChild(acCell);
      
      // Stats (STR, STA, AGI, DEX, WIS, INT, CHA)
      ['str', 'sta', 'agi', 'dex', 'wis', 'int', 'cha'].forEach(stat => {
        const statCell = document.createElement('td');
        const statInput = document.createElement('input');
        statInput.type = 'number';
        statInput.value = npc[stat] || 0;
        statInput.className = 'inline-edit stat-input';
        statInput.min = '-999';
        statInput.max = '999';
        statInput.dataset.field = stat;
        statInput.dataset.original = npc[stat] || 0;
        statInput.onblur = () => stageNPCChange(npc.id, stat, parseInt(statInput.value) || 0);
        statInput.onkeypress = (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            statInput.blur();
          }
        };
        updateStatInputColor(statInput);
        statCell.appendChild(statInput);
        row.appendChild(statCell);
      });
      
      // Attack Speed
      const asCell = document.createElement('td');
      const asInput = document.createElement('input');
      asInput.type = 'number';
      asInput.value = npc.attack_speed || 0;
      asInput.className = 'inline-edit';
      asInput.min = '0';
      asInput.max = '99.9';
      asInput.step = '0.1';
      asInput.dataset.field = 'attack_speed';
      asInput.dataset.original = npc.attack_speed || 0;
      asInput.onblur = () => stageNPCChange(npc.id, 'attack_speed', parseFloat(asInput.value) || 0);
      asInput.onkeypress = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          asInput.blur();
        }
      };
      asCell.appendChild(asInput);
      row.appendChild(asCell);
      
      // Min Damage
      const minDmgCell = document.createElement('td');
      const minDmgInput = document.createElement('input');
      minDmgInput.type = 'number';
      minDmgInput.value = npc.min_dmg || 0;
      minDmgInput.className = 'inline-edit';
      minDmgInput.min = '0';
      minDmgInput.max = '9999';
      minDmgInput.dataset.field = 'min_dmg';
      minDmgInput.dataset.original = npc.min_dmg || 0;
      minDmgInput.onblur = () => stageNPCChange(npc.id, 'min_dmg', parseInt(minDmgInput.value) || 0);
      minDmgInput.onkeypress = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          minDmgInput.blur();
        }
      };
      minDmgCell.appendChild(minDmgInput);
      row.appendChild(minDmgCell);
      
      // Max Damage
      const maxDmgCell = document.createElement('td');
      const maxDmgInput = document.createElement('input');
      maxDmgInput.type = 'number';
      maxDmgInput.value = npc.max_dmg || 0;
      maxDmgInput.className = 'inline-edit';
      maxDmgInput.min = '0';
      maxDmgInput.max = '9999';
      maxDmgInput.dataset.field = 'max_dmg';
      maxDmgInput.dataset.original = npc.max_dmg || 0;
      maxDmgInput.onblur = () => stageNPCChange(npc.id, 'max_dmg', parseInt(maxDmgInput.value) || 0);
      maxDmgInput.onkeypress = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          maxDmgInput.blur();
        }
      };
      maxDmgCell.appendChild(maxDmgInput);
      row.appendChild(maxDmgCell);
      
      // Level
      const levelCell = document.createElement('td');
      const levelInput = document.createElement('input');
      levelInput.type = 'number';
      levelInput.value = npc.level || 1;
      levelInput.className = 'inline-edit';
      levelInput.min = '1';
      levelInput.max = '100';
      levelInput.dataset.field = 'level';
      levelInput.dataset.original = npc.level || 1;
      levelInput.onblur = () => stageNPCChange(npc.id, 'level', parseInt(levelInput.value) || 1);
      levelInput.onkeypress = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          levelInput.blur();
        }
      };
      levelCell.appendChild(levelInput);
      row.appendChild(levelCell);
      
      // Actions
      const actionsCell = document.createElement('td');
      actionsCell.style.cssText = `
        padding: 4px;
        vertical-align: middle;
      `;
      
      // Create inner flex container for buttons
      const actionsContainer = document.createElement('div');
      actionsContainer.style.cssText = `
        display: flex;
        gap: 4px;
        flex-wrap: wrap;
        align-items: center;
        justify-content: center;
        min-height: 30px;
      `;
      
      // Batch Add Items button (only if NPC has URL in description)
      if (npc.description && npc.description.includes('http')) {
        const batchBtn = document.createElement('button');
        batchBtn.className = 'small-btn info-btn';
        batchBtn.innerHTML = '';
        batchBtn.title = 'Open Batch Add Items with NPC URL';
        batchBtn.onclick = () => openBatchAddItemsForNPC(npc);
        actionsContainer.appendChild(batchBtn);
      }
      
      // Delete button
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'small-btn danger-btn';
      deleteBtn.innerHTML = '';
      deleteBtn.title = 'Delete NPC';
      deleteBtn.onclick = () => markNPCForDeletion(npc.id);
      actionsContainer.appendChild(deleteBtn);
      
      actionsCell.appendChild(actionsContainer);
      row.appendChild(actionsCell);
      
      // Apply changed cells styling
      if (change) {
        Object.keys(change).forEach(field => {
          if (field !== '_delete') {
            const input = row.querySelector(`[data-field="${field}"]`);
            if (input && input.closest('td')) {
              input.closest('td').classList.add('cell-changed');
            }
          }
        });
      }
      
      return row;
    }
    
    function stageNPCChange(npcId, field, value) {
      const npc = npcs.find(n => n.id === npcId);
      if (!npc) return;
      
      const originalValue = npc[field];
      let input = document.querySelector(`#npc-row-${npcId} [data-field="${field}"]`);
      
      // For loot field, the cell itself has the data-field attribute, not an input
      if (field === 'loot' && !input) {
        input = document.querySelector(`#npc-row-${npcId} td[data-field="loot"]`);
      }
      
      // Convert values for comparison
      let compareValue = value;
      let compareOriginal = originalValue;
      
      if (typeof originalValue === 'number') {
        compareValue = Number(value);
      } else if (field === 'loot') {
        // Special handling for loot arrays
        const origArray = Array.isArray(originalValue) ? [...originalValue].sort() : [];
        const newArray = Array.isArray(value) ? [...value].sort() : [];
        
        // Compare sorted arrays
        const arraysEqual = origArray.length === newArray.length && 
                           origArray.every((item, index) => item === newArray[index]);
        
        // If arrays are different (including empty vs non-empty), stage the change
        if (!arraysEqual) {
          compareValue = value;
          compareOriginal = null; // Force it to be seen as different
        } else {
          compareValue = compareOriginal; // Make them "equal" to skip staging
        }
      }
      
      if (!npcChanges.has(npcId)) {
        npcChanges.set(npcId, {});
      }
      
      const changes = npcChanges.get(npcId);
      
      if (compareValue !== compareOriginal) {
        // Store numeric fields as numbers
        if (typeof originalValue === 'number') {
          changes[field] = compareValue;
        } else {
          changes[field] = value;
        }
        if (input) {
          const cell = field === 'loot' ? input : input.closest('td');
          if (cell) {
            cell.classList.add('cell-changed');
          }
        }
      } else {
        delete changes[field];
        if (input) {
          const cell = field === 'loot' ? input : input.closest('td');
          if (cell) {
            cell.classList.remove('cell-changed');
          }
        }
      }
      
      // Remove from map if no changes
      if (Object.keys(changes).length === 0) {
        npcChanges.delete(npcId);
      }
      
      updateNPCChangeButtons();
    }
    
    function markNPCForDeletion(npcId) {
      const row = document.getElementById(`npc-row-${npcId}`);
      
      if (!npcChanges.has(npcId)) {
        npcChanges.set(npcId, {});
      }
      
      const changes = npcChanges.get(npcId);
      
      if (changes._delete) {
        // Unmark for deletion
        delete changes._delete;
        row.classList.remove('marked-for-deletion');
        
        // Re-enable inputs
        row.querySelectorAll('input, select, textarea').forEach(input => {
          input.disabled = false;
        });
        
        if (Object.keys(changes).length === 0) {
          npcChanges.delete(npcId);
        }
      } else {
        // Mark for deletion
        changes._delete = true;
        row.classList.add('marked-for-deletion');
        
        // Disable inputs
        row.querySelectorAll('input, select, textarea').forEach(input => {
          input.disabled = true;
        });
      }
      
      updateNPCChangeButtons();
    }
    
    function updateNPCChangeButtons() {
      const saveBtn = document.getElementById('npc-save-btn');
      const resetBtn = document.getElementById('npc-reset-btn');
      const changeCount = document.getElementById('npc-change-count');
      const pendingCount = document.getElementById('npc-pending-count');
      
      if (!saveBtn || !resetBtn || !changeCount || !pendingCount) {
        return; // Elements not ready yet
      }
      
      const totalChanges = npcChanges.size;
      
      saveBtn.disabled = totalChanges === 0;
      resetBtn.disabled = totalChanges === 0;
      changeCount.textContent = totalChanges;
      pendingCount.textContent = totalChanges;
    }
    
    async function saveNPCChanges() {
      if (npcChanges.size === 0) return;
      
      const saveBtn = document.getElementById('npc-save-btn');
      const originalText = saveBtn.innerHTML;
      saveBtn.innerHTML = '<span style="margin-right: 0.5rem;"></span>Saving...';
      saveBtn.disabled = true;
      
      try {
        const updates = [];
        const deletions = [];
        const creations = [];
        
        for (const [npcId, changes] of npcChanges) {
          if (changes._delete) {
            if (npcId > 0) { // Only delete if it's a real NPC
              deletions.push(npcId);
            }
          } else {
            const npc = npcs.find(n => n.id === npcId);
            if (npc) {
              if (npcId < 0) {
                // This is a new NPC
                creations.push(changes);
              } else {
                // This is an update to existing NPC
                updates.push({
                  ...npc,
                  ...changes,
                  id: npcId
                });
              }
            }
          }
        }
        
        // Process updates
        if (updates.length > 0) {
          const response = await window.csrfHelper.fetchWithCSRF('/api/npcs/batch/update', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ npcs: updates })
          });
          
          if (!response.ok) {
            throw new Error('Failed to update NPCs');
          }
        }
        
        // Process creations (new NPCs)
        if (creations.length > 0) {
          for (const newNpc of creations) {
            const response = await window.csrfHelper.fetchWithCSRF('/api/npcs', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(newNpc)
            });
            
            if (!response.ok) {
              throw new Error('Failed to create NPC');
            }
          }
        }
        
        // Process deletions
        if (deletions.length > 0) {
          const response = await window.csrfHelper.fetchWithCSRF('/api/npcs/batch/delete', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ ids: deletions })
          });
          
          if (!response.ok) {
            throw new Error('Failed to delete NPCs');
          }
        }
        
        // Clear changes and reload
        npcChanges.clear();
        await loadNPCEditor();
        
        showMessage('NPC changes saved successfully!', 'success');
      } catch (error) {
        console.error('Error saving NPC changes:', error);
        showMessage('Error saving changes: ' + error.message, 'error');
      } finally {
        saveBtn.innerHTML = originalText;
        saveBtn.disabled = npcChanges.size === 0;
      }
    }
    
    function resetNPCChanges() {
      if (!confirm('Are you sure you want to discard all unsaved changes?')) {
        return;
      }
      
      npcChanges.clear();
      displayNPCs();
    }
    
    async function reloadNPCEditor() {
      if (npcChanges.size > 0) {
        if (!confirm('You have unsaved changes. Are you sure you want to reload?')) {
          return;
        }
      }
      
      npcChanges.clear();
      await loadNPCEditor();
    }
    
    function displayNPCPagination() {
      const totalPages = Math.ceil(filteredNpcs.length / NPCS_PER_PAGE);
      if (totalPages <= 1) return;
      
      const paginationDiv = document.getElementById('npc-editor-pagination');
      
      if (totalPages <= 1) {
        paginationDiv.style.display = 'none';
        return;
      }
      
      paginationDiv.style.display = 'block';
      paginationDiv.innerHTML = '';
      
      // Previous button
      const prevBtn = document.createElement('button');
      prevBtn.className = 'pagination-btn';
      prevBtn.textContent = 'Previous';
      prevBtn.disabled = currentNpcPage === 0;
      prevBtn.onclick = () => {
        currentNpcPage--;
        displayNPCs();
      };
      paginationDiv.appendChild(prevBtn);
      
      // Page info
      const pageInfo = document.createElement('span');
      pageInfo.className = 'pagination-info';
      pageInfo.textContent = `Page ${currentNpcPage + 1} of ${totalPages}`;
      paginationDiv.appendChild(pageInfo);
      
      // Next button
      const nextBtn = document.createElement('button');
      nextBtn.className = 'pagination-btn';
      nextBtn.textContent = 'Next';
      nextBtn.disabled = currentNpcPage === totalPages - 1;
      nextBtn.onclick = () => {
        currentNpcPage++;
        displayNPCs();
      };
      paginationDiv.appendChild(nextBtn);
    }
    
    function showAddNPCForm() {
      // Create a new empty NPC at the top of the list
      const newNpc = {
        id: -Date.now(), // Temporary negative ID
        npc_type: 'humanoid',
        name: 'New NPC',
        description: '',
        loot: [],
        hp: 100,
        mp: 0,
        ac: 10,
        str: 10,
        sta: 10,
        agi: 10,
        dex: 10,
        wis: 10,
        int: 10,
        cha: 10,
        attack_speed: 2.0,
        min_dmg: 1,
        max_dmg: 5,
        level: 1,
        _isNew: true
      };
      
      // Add to beginning of arrays
      npcs.unshift(newNpc);
      filteredNpcs.unshift(newNpc);
      
      // Stage all fields as changes
      const changes = { ...newNpc };
      delete changes.id;
      delete changes._isNew;
      npcChanges.set(newNpc.id, changes);
      
      // Go to first page and display
      currentNpcPage = 0;
      displayNPCs();
      
      // Focus on name field
      setTimeout(() => {
        const nameInput = document.querySelector(`#npc-row-${newNpc.id} [data-field="name"]`);
        if (nameInput) {
          nameInput.select();
          nameInput.focus();
        }
      }, 100);
    }
    
    function exportNPCsToCSV() {
      const headers = ['ID', 'Type', 'Name', 'Description', 'Loot IDs', 'HP', 'MP', 'AC', 
                       'STR', 'STA', 'AGI', 'DEX', 'WIS', 'INT', 'CHA', 
                       'Attack Speed', 'Min Damage', 'Max Damage', 'Level'];
      const rows = [headers];
      
      filteredNpcs.forEach(npc => {
        rows.push([
          npc.id,
          npc.npc_type || '',
          npc.name,
          npc.description || '',
          (npc.loot || []).join(','),
          npc.hp || 0,
          npc.mp || 0,
          npc.ac || 0,
          npc.str || 0,
          npc.sta || 0,
          npc.agi || 0,
          npc.dex || 0,
          npc.wis || 0,
          npc.int || 0,
          npc.cha || 0,
          npc.attack_speed || 0,
          npc.min_dmg || 0,
          npc.max_dmg || 0,
          npc.level || 1
        ]);
      });
      
      const csv = rows.map(row => row.map(cell => {
        const value = cell.toString();
        return value.includes(',') || value.includes('"') || value.includes('\n') 
          ? `"${value.replace(/"/g, '""')}"` 
          : value;
      }).join(',')).join('\n');
      
      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `npcs_${new Date().toISOString().split('T')[0]}.csv`;
      a.click();
      URL.revokeObjectURL(url);
    }
    
    // Loot selector modal functions
    let lootSelectorPage = 1;
    let lootSelectorSelectedPage = 1;
    let lootSelectorItemsPerPage = 10;
    let lootSelectorAllItems = [];
    let lootSelectorFilterTimeout = null;
    
    function showProgressModal(title, message) {
      const modalId = 'progress-modal-' + Date.now();
      const modalHtml = `
        <div id="${modalId}" class="modal" style="display: flex;">
          <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
              <h2>${title}</h2>
            </div>
            <div class="modal-body">
              <div class="progress-message" style="margin-bottom: 1rem; color: #ccc;">
                ${message}
              </div>
              <div class="progress-bar-container" style="width: 100%; height: 30px; background: #1a1a1a; border-radius: 15px; overflow: hidden; position: relative;">
                <div class="progress-bar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #FFD700, #FFA500); transition: width 0.3s ease; position: relative;">
                  <div class="progress-bar-animation" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(45deg, rgba(255,255,255,0.1) 25%, transparent 25%, transparent 50%, rgba(255,255,255,0.1) 50%, rgba(255,255,255,0.1) 75%, transparent 75%, transparent); background-size: 30px 30px; animation: progressStripes 1s linear infinite;"></div>
                </div>
              </div>
              <div class="progress-status" style="margin-top: 1rem; font-size: 0.9rem; color: #999; text-align: center;">
                <span class="progress-percentage">0%</span>
              </div>
            </div>
          </div>
        </div>
      `;
      
      document.body.insertAdjacentHTML('beforeend', modalHtml);
      
      const modal = document.getElementById(modalId);
      const progressBar = modal.querySelector('.progress-bar');
      const progressMessage = modal.querySelector('.progress-message');
      const progressPercentage = modal.querySelector('.progress-percentage');
      
      return {
        updateProgress: (percentage, message) => {
          progressBar.style.width = percentage + '%';
          progressPercentage.textContent = percentage + '%';
          if (message) {
            progressMessage.innerHTML = message;
          }
        },
        close: () => {
          modal.remove();
        }
      };
    }
    
    // Open Batch Add Items modal with NPC URL pre-loaded
    function openBatchAddItemsForNPC(npc) {
      // Extract URL from description
      const urlMatch = npc.description.match(/https?:\/\/[^\s]+/);
      if (!urlMatch) {
        showMessage('No URL found in NPC description', 'warning');
        return;
      }
      
      const npcUrl = urlMatch[0];
      
      // Switch to Admin tab
      showTab('admin');
      
      // Expand Item Editor section if collapsed
      const itemSection = document.getElementById('item-editor-section');
      if (itemSection && itemSection.classList.contains('collapsed')) {
        const header = itemSection.querySelector('.admin-section-header');
        if (header) header.click();
      }
      
      // Open the batch import modal
      showBatchImportModal();
      
      // Wait a bit for the modal to open, then pre-fill the textarea
      setTimeout(() => {
        const textarea = document.getElementById('batch-import-textarea');
        if (textarea) {
          textarea.value = npcUrl;
          // Trigger the input event to activate the Data Inspector
          textarea.dispatchEvent(new Event('input', { bubbles: true }));
          
          // Also trigger keyup to ensure all handlers are called
          textarea.dispatchEvent(new KeyboardEvent('keyup', { bubbles: true }));
          
          // Auto-click the Analyze button after another short delay
          setTimeout(() => {
            const analyzeBtn = document.getElementById('batch-analyze-btn');
            if (analyzeBtn && !analyzeBtn.disabled) {
              analyzeBtn.click();
            }
          }, 100);
        }
      }, 300);
      
      showMessage(`Opened Batch Add Items with ${npc.name}'s URL`, 'info');
    }
    
    // extractLootFromNPC function removed - functionality moved to Data Inspector
    function showLootSelector(npcId, currentLoot) {
      selectedItemsForLoot = [...(currentLoot || [])];
      lootSelectorPage = 1;
      lootSelectorSelectedPage = 1;
      
      // Create modal HTML
      const modalHtml = `
        <div id="loot-selector-modal" class="modal" style="display: flex;">
          <div class="modal-content" style="max-width: 900px; height: 90vh; display: flex; flex-direction: column;">
            <div class="modal-header" style="flex-shrink: 0;">
              <h2>Select Loot Items</h2>
              <button class="close-btn" onclick="closeLootSelector()">&times;</button>
            </div>
            <div class="modal-body" style="flex: 1; display: flex; flex-direction: column; overflow: hidden; padding: 1.5rem;">
              <div style="margin-bottom: 1rem; display: flex; gap: 1rem; align-items: center; flex-shrink: 0;">
                <input type="text" id="loot-item-search" placeholder="Search items by name, type, or slot..." 
                       style="flex: 1; padding: 0.5rem; border: 1px solid #555; 
                              border-radius: 4px; background: #2d2d2d; color: #e0e0e0;"
                       onkeyup="filterLootItems()">
                <select id="loot-type-filter" onchange="filterLootItems()" 
                        style="padding: 0.5rem; border: 1px solid #555; 
                               border-radius: 4px; background: #2d2d2d; color: #e0e0e0;">
                  <option value="">All Types</option>
                  <option value="weapon">Weapons</option>
                  <option value="armor">Armor</option>
                  <option value="shield">Shields</option>
                  <option value="accessory">Accessories</option>
                  <option value="consumable">Consumables</option>
                  <option value="misc">Misc</option>
                </select>
              </div>
              <div style="flex: 1; display: flex; gap: 1rem; min-height: 0; overflow: hidden;">
                <div style="flex: 1; display: flex; flex-direction: column; border: 1px solid #444; 
                            border-radius: 4px; overflow: hidden;">
                  <div style="padding: 1rem; background: #2a2a2a; border-bottom: 1px solid #444; flex-shrink: 0;">
                    <h3 style="margin: 0;">Available Items (<span id="available-count">0</span>)</h3>
                  </div>
                  <div id="available-items-list" style="flex: 1; overflow-y: auto; padding: 1rem; min-height: 0;"></div>
                  <div id="available-pagination" style="padding: 0.5rem; background: #2a2a2a; 
                                                       border-top: 1px solid #444; text-align: center; flex-shrink: 0;"></div>
                </div>
                <div style="flex: 1; display: flex; flex-direction: column; border: 1px solid #444; 
                            border-radius: 4px; overflow: hidden;">
                  <div style="padding: 1rem; background: #2a2a2a; border-bottom: 1px solid #444; flex-shrink: 0;">
                    <h3 style="margin: 0;">Selected Items (<span id="selected-count">0</span>)</h3>
                  </div>
                  <div id="selected-items-list" style="flex: 1; overflow-y: auto; padding: 1rem; min-height: 0;"></div>
                  <div id="selected-pagination" style="padding: 0.5rem; background: #2a2a2a; 
                                                      border-top: 1px solid #444; text-align: center; flex-shrink: 0;"></div>
                  <div style="padding: 0.5rem; background: #2a2a2a; border-top: 1px solid #444; flex-shrink: 0;">
                    <button class="secondary-btn btn-sm" onclick="clearLootSelection()" 
                            style="width: 100%;">Clear All</button>
                  </div>
                </div>
              </div>
              <div style="margin-top: 1rem; text-align: right; padding-top: 1rem; border-top: 1px solid #444; flex-shrink: 0;">
                <button class="secondary-btn" onclick="closeLootSelector()">Cancel</button>
                <button class="primary-btn" onclick="saveLootSelection(${npcId})" 
                        style="margin-left: 0.5rem;">Save Selection</button>
              </div>
            </div>
          </div>
        </div>
      `;
      
      // Add modal to page
      const modalContainer = document.createElement('div');
      modalContainer.innerHTML = modalHtml;
      document.body.appendChild(modalContainer.firstElementChild);
      
      // Add custom scrollbar styles
      const style = document.createElement('style');
      style.textContent = `
        #available-items-list::-webkit-scrollbar,
        #selected-items-list::-webkit-scrollbar {
          width: 8px;
        }
        #available-items-list::-webkit-scrollbar-track,
        #selected-items-list::-webkit-scrollbar-track {
          background: #2a2a2a;
        }
        #available-items-list::-webkit-scrollbar-thumb,
        #selected-items-list::-webkit-scrollbar-thumb {
          background: #4a4a4a;
          border-radius: 4px;
        }
        #available-items-list::-webkit-scrollbar-thumb:hover,
        #selected-items-list::-webkit-scrollbar-thumb:hover {
          background: #5a5a5a;
        }
      `;
      document.getElementById('loot-selector-modal').appendChild(style);
      
      // Load items
      loadItemsForLootSelector();
    }
    
    async function loadItemsForLootSelector() {
      try {
        const response = await window.csrfHelper.fetchWithCSRF('/api/items');
        if (!response.ok) throw new Error('Failed to load items');
        
        lootSelectorAllItems = await response.json();
        displayLootItems();
      } catch (error) {
        console.error('Error loading items for loot selector:', error);
      }
    }
    
    function displayLootItems() {
      const availableList = document.getElementById('available-items-list');
      const selectedList = document.getElementById('selected-items-list');
      const searchValue = document.getElementById('loot-item-search').value.toLowerCase();
      const typeFilter = document.getElementById('loot-type-filter').value;
      
      availableList.innerHTML = '';
      selectedList.innerHTML = '';
      
      // Filter items
      let filteredItems = lootSelectorAllItems.filter(item => {
        // Text search
        const matchesSearch = !searchValue || 
          item.name.toLowerCase().includes(searchValue) ||
          item.id.toString().includes(searchValue) ||
          (item.slot && item.slot.toLowerCase().includes(searchValue));
        
        // Type filter
        const matchesType = !typeFilter || item.item_type === typeFilter;
        
        return matchesSearch && matchesType;
      });
      
      // Separate selected and available items
      const selectedItems = [];
      const availableItems = [];
      
      filteredItems.forEach(item => {
        if (selectedItemsForLoot.includes(item.id)) {
          selectedItems.push(item);
        } else {
          availableItems.push(item);
        }
      });
      
      // Calculate pagination for selected items
      const totalSelected = selectedItems.length;
      const totalSelectedPages = Math.ceil(totalSelected / lootSelectorItemsPerPage);
      const selectedStartIndex = (lootSelectorSelectedPage - 1) * lootSelectorItemsPerPage;
      const selectedEndIndex = Math.min(selectedStartIndex + lootSelectorItemsPerPage, totalSelected);
      
      // Display paginated selected items
      for (let i = selectedStartIndex; i < selectedEndIndex; i++) {
        const itemDiv = createLootItemDisplay(selectedItems[i], false);
        selectedList.appendChild(itemDiv);
      }
      
      // Calculate pagination for available items
      const totalAvailable = availableItems.length;
      const totalAvailablePages = Math.ceil(totalAvailable / lootSelectorItemsPerPage);
      const availableStartIndex = (lootSelectorPage - 1) * lootSelectorItemsPerPage;
      const availableEndIndex = Math.min(availableStartIndex + lootSelectorItemsPerPage, totalAvailable);
      
      // Display paginated available items
      for (let i = availableStartIndex; i < availableEndIndex; i++) {
        const itemDiv = createLootItemDisplay(availableItems[i], true);
        availableList.appendChild(itemDiv);
      }
      
      // Update counts
      document.getElementById('selected-count').textContent = selectedItemsForLoot.length;
      document.getElementById('available-count').textContent = totalAvailable;
      
      // Update pagination controls
      updateLootPagination('available', totalAvailablePages, lootSelectorPage);
      updateLootPagination('selected', totalSelectedPages, lootSelectorSelectedPage);
    }
    
    function updateLootPagination(type, totalPages, currentPage) {
      const paginationDiv = document.getElementById(`${type}-pagination`);
      paginationDiv.innerHTML = '';
      
      if (totalPages <= 1) return;
      
      // Previous button
      const prevBtn = document.createElement('button');
      prevBtn.className = 'pagination-btn btn-sm';
      prevBtn.textContent = '';
      prevBtn.disabled = currentPage === 1;
      prevBtn.onclick = () => {
        if (currentPage > 1) {
          if (type === 'available') {
            lootSelectorPage--;
          } else {
            lootSelectorSelectedPage--;
          }
          displayLootItems();
        }
      };
      paginationDiv.appendChild(prevBtn);
      
      // Page info
      const pageInfo = document.createElement('span');
      pageInfo.style.margin = '0 1rem';
      pageInfo.style.fontSize = '0.85rem';
      pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
      paginationDiv.appendChild(pageInfo);
      
      // Next button
      const nextBtn = document.createElement('button');
      nextBtn.className = 'pagination-btn btn-sm';
      nextBtn.textContent = '';
      nextBtn.disabled = currentPage === totalPages;
      nextBtn.onclick = () => {
        if (currentPage < totalPages) {
          if (type === 'available') {
            lootSelectorPage++;
          } else {
            lootSelectorSelectedPage++;
          }
          displayLootItems();
        }
      };
      paginationDiv.appendChild(nextBtn);
    }
    
    function createLootItemDisplay(item, canAdd) {
      const div = document.createElement('div');
      div.style.cssText = `
        padding: 0.75rem;
        margin-bottom: 0.5rem;
        background: #3a3a3a;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        cursor: pointer;
        transition: all 0.2s;
        border: 1px solid transparent;
      `;
      
      div.onmouseover = () => {
        div.style.background = '#444';
        div.style.borderColor = '#555';
      };
      div.onmouseout = () => {
        div.style.background = '#3a3a3a';
        div.style.borderColor = 'transparent';
      };
      
      // Left side - icon and info
      const leftSide = document.createElement('div');
      leftSide.style.cssText = 'display: flex; align-items: center; gap: 0.75rem; flex: 1;';
      
      // Item icon
      const iconDiv = document.createElement('div');
      iconDiv.style.cssText = `
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #2a2a2a;
        border-radius: 4px;
        flex-shrink: 0;
      `;
      
      if (item.icon_type === 'emoji') {
        iconDiv.style.fontSize = '1.5rem';
        iconDiv.textContent = item.icon_value;
      } else if (item.icon_type === 'iconify') {
        iconDiv.innerHTML = `<iconify-icon icon="${item.icon_value}" width="24" height="24"></iconify-icon>`;
      } else if (item.icon_type === 'upload') {
        const img = document.createElement('img');
        img.src = item.icon_value;
        img.style.cssText = 'width: 24px; height: 24px; object-fit: contain;';
        iconDiv.appendChild(img);
      }
      
      // Item info
      const info = document.createElement('div');
      info.style.cssText = 'flex: 1;';
      
      const nameDiv = document.createElement('div');
      nameDiv.style.cssText = 'font-weight: 500; color: #e0e0e0; margin-bottom: 0.25rem;';
      nameDiv.textContent = item.name;
      
      const detailsDiv = document.createElement('div');
      detailsDiv.style.cssText = 'font-size: 0.85rem; color: #999; display: flex; gap: 1rem; flex-wrap: wrap;';
      
      let details = [`ID: ${item.id}`];
      if (item.item_type) details.push(`Type: ${item.item_type}`);
      if (item.slot) details.push(`Slot: ${item.slot}`);
      
      detailsDiv.textContent = details.join('  ');
      
      info.appendChild(nameDiv);
      info.appendChild(detailsDiv);
      
      leftSide.appendChild(iconDiv);
      leftSide.appendChild(info);
      
      // Button
      const button = document.createElement('button');
      button.className = canAdd ? 'small-btn primary-btn' : 'small-btn danger-btn';
      button.style.cssText = 'white-space: nowrap;';
      button.innerHTML = canAdd ? '<span style="margin-right: 0.25rem;">+</span>Add' : '<span style="margin-right: 0.25rem;"></span>Remove';
      button.onclick = (e) => {
        e.stopPropagation();
        toggleLootItem(item.id);
      };
      
      div.appendChild(leftSide);
      div.appendChild(button);
      
      // Add click handler for the whole div
      div.onclick = () => toggleLootItem(item.id);
      
      return div;
    }
    
    function toggleLootItem(itemId) {
      const index = selectedItemsForLoot.indexOf(itemId);
      if (index > -1) {
        selectedItemsForLoot.splice(index, 1);
      } else {
        selectedItemsForLoot.push(itemId);
      }
      
      // Reload the display
      loadItemsForLootSelector();
    }
    
    function filterLootItems() {
      lootSelectorPage = 1;
      displayLootItems();
    }
    
    function clearLootSelection() {
      selectedItemsForLoot = [];
      lootSelectorSelectedPage = 1;
      displayLootItems();
    }
    
    function closeLootSelector() {
      const modal = document.getElementById('loot-selector-modal');
      if (modal) {
        modal.remove();
      }
    }
    
    function saveLootSelection(npcId) {
      // Always pass an array, even if empty
      const lootArray = selectedItemsForLoot || [];
      stageNPCChange(npcId, 'loot', lootArray);
      
      // Update the display in the table
      const npc = npcs.find(n => n.id === npcId);
      if (npc) {
        npc.loot = lootArray;
        // Also clear loot_items to reflect empty selection
        if (lootArray.length === 0) {
          npc.loot_items = [];
        }
        displayNPCs();
      }
      
      closeLootSelector();
    }

    // Voting Tab Functions
    let currentProposals = [];
    let proposalFilters = {
      type: '',
      show: 'not-voted',  // Default to showing only proposals not voted on
      sort: 'newest'      // Default sort by newest first
    };
    let proposalsPage = 1;
    const proposalsPerPage = 10;
    let expandedProposalId = null;

    async function loadVotingData() {
      // Load voting statistics
      loadVotingStats();
      
      // Load proposals
      loadProposals();
    }

    async function loadVotingStats() {
      try {
        const response = await fetch('/api/change-proposals');
        if (response.ok) {
          const proposals = await response.json();
          
          // Calculate stats
          const myProposals = proposals.filter(p => p.proposer_id === currentUser.id);
          document.getElementById('my-proposals-count').textContent = myProposals.length;
          
          // Calculate stats for each proposal type
          const proposalTypes = ['add_poi', 'edit_poi', 'move_poi', 'delete_poi', 
                                'add_npc', 'edit_npc', 'change_loot', 
                                'add_item', 'edit_item'];
          
          proposalTypes.forEach(type => {
            const typeProposals = proposals.filter(p => p.change_type === type);
            const unvotedTypeProposals = typeProposals.filter(p => !p.user_vote || p.user_vote === 0);
            
            const totalElement = document.getElementById(`${type.replace('_', '-')}-total`);
            const pendingElement = document.getElementById(`${type.replace('_', '-')}-pending`);
            
            if (totalElement) totalElement.textContent = typeProposals.length;
            
            if (pendingElement) {
              const pendingCount = unvotedTypeProposals.length;
              if (pendingCount === 0) {
                pendingElement.textContent = 'All voted!';
                pendingElement.classList.add('none');
              } else {
                pendingElement.textContent = `${pendingCount} pending vote!`;
                pendingElement.classList.remove('none');
              }
            }
          });
        }
      } catch (error) {
        console.error('Error loading voting stats:', error);
      }
    }

    function refreshProposals() {
      // Reset page to 1 when refreshing
      proposalsPage = 1;
      loadProposals();
    }
    
    function resetProposalFilters() {
      // Reset filters to default values
      document.getElementById('proposal-type-filter').value = '';
      document.getElementById('proposal-filter').value = 'not-voted';
      document.getElementById('proposal-sort').value = 'newest';
      
      // Update the filter state
      proposalFilters.type = '';
      proposalFilters.show = 'not-voted';
      proposalFilters.sort = 'newest';
      
      // Clear active card states
      clearActiveCards();
      
      // Reset page and reload
      proposalsPage = 1;
      loadProposals();
    }
    
    function filterByCard(filterType) {
      // Clear active states
      clearActiveCards();
      
      // Set the clicked card as active
      const clickedCard = document.querySelector(`[data-filter-type="${filterType}"]`);
      if (clickedCard) {
        clickedCard.classList.add('active');
      }
      
      if (filterType === 'mine') {
        // For "My Proposals", set show filter to "mine" and clear type filter
        document.getElementById('proposal-filter').value = 'mine';
        document.getElementById('proposal-type-filter').value = '';
        proposalFilters.show = 'mine';
        proposalFilters.type = '';
      } else {
        // For type-specific cards, check if there are pending votes
        const pendingElement = document.getElementById(`${filterType.replace('_', '-')}-pending`);
        const hasPendingVotes = pendingElement && !pendingElement.classList.contains('none');
        
        // Set type filter
        document.getElementById('proposal-type-filter').value = filterType;
        proposalFilters.type = filterType;
        
        // If there are pending votes, show only unvoted proposals
        // If no pending votes, show all proposals of that type
        if (hasPendingVotes) {
          document.getElementById('proposal-filter').value = 'not-voted';
          proposalFilters.show = 'not-voted';
        } else {
          document.getElementById('proposal-filter').value = 'all';
          proposalFilters.show = 'all';
        }
      }
      
      // Reset page and reload
      proposalsPage = 1;
      loadProposals();
    }
    
    function clearActiveCards() {
      document.querySelectorAll('.voting-stat-card').forEach(card => {
        card.classList.remove('active');
      });
    }

    async function loadProposals() {
      const loading = document.getElementById('proposals-loading');
      const container = document.getElementById('proposals-container');
      
      loading.style.display = 'block';
      container.style.display = 'none';
      
      try {
        const response = await fetch('/api/change-proposals');
        if (response.ok) {
          const proposals = await response.json();
          currentProposals = proposals;
          
          // Apply filters
          const filtered = getFilteredProposals();
          
          // Pagination
          const totalPages = Math.ceil(filtered.length / proposalsPerPage);
          const start = (proposalsPage - 1) * proposalsPerPage;
          const paginated = filtered.slice(start, start + proposalsPerPage);
          
          await displayProposals(paginated);
          updateProposalsPagination(totalPages);
          
          // Update voting tab with pending count
          updateVotingTabCount(proposals.length);
          
          loading.style.display = 'none';
          container.style.display = 'block';
        }
      } catch (error) {
        console.error('Error loading proposals:', error);
        loading.innerHTML = '<p style="color: #f44336;">Failed to load proposals</p>';
      }
    }

    async function toggleProposalExpansion(proposalId, event) {
      // Prevent event bubbling
      if (event) {
        event.stopPropagation();
      }
      
      // If clicking on the already expanded proposal, collapse it
      if (expandedProposalId === proposalId) {
        expandedProposalId = null;
      } else {
        // Otherwise, expand the clicked proposal and collapse others
        expandedProposalId = proposalId;
      }
      
      // Re-render the proposals list
      const filtered = getFilteredProposals();
      const totalPages = Math.ceil(filtered.length / proposalsPerPage);
      const start = (proposalsPage - 1) * proposalsPerPage;
      const paginated = filtered.slice(start, start + proposalsPerPage);
      await displayProposals(paginated);
    }
    
    function getFilteredProposals() {
      let filtered = currentProposals;
      
      if (proposalFilters.type) {
        filtered = filtered.filter(p => p.change_type === proposalFilters.type);
      }
      
      if (proposalFilters.show === 'mine') {
        filtered = filtered.filter(p => p.proposer_id === currentUser.id);
      } else if (proposalFilters.show === 'not-voted') {
        filtered = filtered.filter(p => !p.user_vote || p.user_vote === 0);
      }
      
      // Apply sorting
      filtered = sortProposalsList(filtered);
      
      return filtered;
    }
    
    function sortProposalsList(proposals) {
      const sorted = [...proposals]; // Create a copy to avoid mutating the original
      
      switch (proposalFilters.sort) {
        case 'newest':
          sorted.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
          break;
        case 'oldest':
          sorted.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
          break;
        case 'score-high':
          sorted.sort((a, b) => (b.vote_score || 0) - (a.vote_score || 0));
          break;
        case 'score-low':
          sorted.sort((a, b) => (a.vote_score || 0) - (b.vote_score || 0));
          break;
        case 'votes-most':
          sorted.sort((a, b) => {
            const totalVotesA = (a.upvotes || 0) + (a.downvotes || 0);
            const totalVotesB = (b.upvotes || 0) + (b.downvotes || 0);
            return totalVotesB - totalVotesA;
          });
          break;
        case 'votes-least':
          sorted.sort((a, b) => {
            const totalVotesA = (a.upvotes || 0) + (a.downvotes || 0);
            const totalVotesB = (b.upvotes || 0) + (b.downvotes || 0);
            return totalVotesA - totalVotesB;
          });
          break;
        case 'name-asc':
          sorted.sort((a, b) => {
            const nameA = getProposalTitle(a).toLowerCase();
            const nameB = getProposalTitle(b).toLowerCase();
            return nameA.localeCompare(nameB);
          });
          break;
        case 'name-desc':
          sorted.sort((a, b) => {
            const nameA = getProposalTitle(a).toLowerCase();
            const nameB = getProposalTitle(b).toLowerCase();
            return nameB.localeCompare(nameA);
          });
          break;
        case 'type':
          sorted.sort((a, b) => {
            const typeA = formatChangeType(a.change_type);
            const typeB = formatChangeType(b.change_type);
            return typeA.localeCompare(typeB);
          });
          break;
      }
      
      return sorted;
    }
    
    async function sortProposals() {
      // Update the sort filter
      proposalFilters.sort = document.getElementById('proposal-sort').value;
      
      // Reset to first page when sorting changes
      proposalsPage = 1;
      
      // Re-render the proposals with new sort
      const filtered = getFilteredProposals();
      const totalPages = Math.ceil(filtered.length / proposalsPerPage);
      const start = (proposalsPage - 1) * proposalsPerPage;
      const paginated = filtered.slice(start, start + proposalsPerPage);
      
      await displayProposals(paginated);
      updateProposalsPagination(totalPages);
    }

    async function displayProposals(proposals) {
      const list = document.getElementById('proposals-list');
      
      if (proposals.length === 0) {
        // Check if "Not Voted" filter is active
        const filterValue = document.getElementById('proposal-filter')?.value;
        let message = 'No proposals found';
        
        if (filterValue === 'not-voted') {
          message = 'There are no more proposals left to vote on! Good Work!';
        }
        
        list.innerHTML = `<div style="text-align: center; padding: 3rem; color: #999;">${message}</div>`;
        return;
      }
      
      // Generate HTML for each proposal asynchronously
      const proposalHtmlPromises = proposals.map(async proposal => {
        const isOwner = proposal.proposer_id === currentUser.id;
        const isExpanded = expandedProposalId === proposal.id;
        const voteClass = proposal.user_vote === 1 ? 'upvote active' : 
                         proposal.user_vote === -1 ? 'downvote active' : '';
        
        return `
          <div class="proposal-card ${isExpanded ? 'expanded' : 'collapsed'}" 
               onclick="toggleProposalExpansion(${proposal.id}, event)"
               style="cursor: pointer; transition: all 0.3s ease;">
            <div class="proposal-header">
              <div>
                <div class="proposal-title">${getProposalTitle(proposal)}</div>
                <div class="proposal-meta">
                  <span>by ${proposal.proposer_name}</span>
                  <span></span>
                  <span>${formatDate(proposal.created_at)}</span>
                  <span></span>
                  <span style="color: #888;">ID: ${proposal.id}</span>
                  <span></span>
                  <span class="proposal-type">${formatChangeType(proposal.change_type)}</span>
                </div>
              </div>
              <div style="display: flex; align-items: center; gap: 1rem;">
                ${!isExpanded ? `
                  <div class="vote-display" style="display: flex; gap: 0.5rem; align-items: center;">
                    <span style="color: #4caf50;"> ${proposal.upvotes || 0}</span>
                    <span style="color: #f44336;"> ${proposal.downvotes || 0}</span>
                    <span class="vote-score ${proposal.vote_score >= 0 ? 'positive' : 'negative'}" 
                          style="margin-left: 0.5rem;">
                      Score: ${proposal.vote_score >= 0 ? '+' : ''}${proposal.vote_score}
                    </span>
                  </div>
                ` : ''}
                <span style="color: #999; font-size: 1.2rem;">
                  ${isExpanded ? '' : ''}
                </span>
              </div>
            </div>
            
            ${isExpanded ? `
              <div class="proposal-content" style="margin-top: 1rem;">
                ${await getProposalDescription(proposal)}
              </div>
              
              <div class="proposal-voting">
                <div class="vote-buttons">
                  <button class="vote-btn upvote ${proposal.user_vote === 1 || isOwner ? 'active' : ''}" 
                          onclick="voteProposal(${proposal.id}, 1); event.stopPropagation();"
                          ${isOwner ? 'disabled title="Cannot vote on your own proposal"' : ''}>
                     ${proposal.upvotes || 0}
                  </button>
                  <button class="vote-btn downvote ${proposal.user_vote === -1 ? 'active' : ''}" 
                          onclick="voteProposal(${proposal.id}, -1); event.stopPropagation();"
                          ${isOwner && proposal.user_vote !== -1 ? '' : isOwner ? 'title="Click to withdraw proposal"' : ''}>
                     ${proposal.downvotes || 0}
                  </button>
                </div>
                
                <div class="vote-score ${proposal.vote_score >= 0 ? 'positive' : 'negative'}">
                  Score: ${proposal.vote_score >= 0 ? '+' : ''}${proposal.vote_score}
                </div>
                
                ${proposal.vote_score >= 10 ? '<span class="proposal-status approved">Auto-Approval Pending</span>' : ''}
                
                <div class="proposal-actions">
                  ${['add_poi', 'edit_poi', 'move_poi', 'delete_poi', 'change_loot', 'add_npc', 'edit_npc'].includes(proposal.change_type) ? 
                    `<button class="small-btn info-btn" onclick="viewProposalPOI(${proposal.id}); event.stopPropagation();">View on Map</button>` : ''}
                  ${isOwner && proposal.status === 'pending' ? 
                    `<button class="small-btn danger-btn" onclick="deleteProposal(${proposal.id}); event.stopPropagation();">Delete</button>` : ''}
                  ${currentUser.is_admin ? 
                    `<button class="small-btn admin-btn" onclick="showAdminProposalModal(${proposal.id}); event.stopPropagation();">Admin Review</button>` : ''}
                </div>
              </div>
              
              ${renderVoteStatusBar(proposal)}
            ` : ''}
          </div>
        `;
      });

    function renderVoteStatusBar(proposal) {
      const voteScore = proposal.vote_score || 0;
      const upvotes = proposal.upvotes || 0;
      const downvotes = proposal.downvotes || 0;
      const totalVotes = upvotes + downvotes;
      
      // Calculate percentage (0-100) for bar width
      // Score ranges from -10 to 10, so we map it to 0-100%
      const percentage = Math.min(100, Math.abs(voteScore) * 10);
      
      // Check if near threshold
      const nearThreshold = Math.abs(voteScore) >= 8;
      
      // Determine status
      let status = 'pending';
      let statusText = 'Pending';
      if (voteScore >= 10) {
        status = 'pass';
        statusText = 'Auto-Approval';
      } else if (voteScore <= -10) {
        status = 'fail';
        statusText = 'Auto-Rejection';
      }
      
      return `
        <div class="vote-status-bar">
          <div class="vote-bar-labels">
            <span class="label-left"> Rejected</span>
            <span class="label-center">Community Vote</span>
            <span class="label-right">Approved </span>
          </div>
          <div class="vote-bar-container">
            <div class="vote-bar-track">
              <div class="vote-bar-left"></div>
              <div class="vote-bar-right"></div>
            </div>
            ${voteScore !== 0 ? `
              <div class="vote-bar-fill ${voteScore > 0 ? 'positive' : 'negative'} ${nearThreshold ? 'near-threshold' : ''}" 
                   style="${voteScore > 0 ? 'left: 50%' : 'right: 50%'}; width: ${percentage / 2}%"></div>
            ` : ''}
            <div class="vote-bar-markers">
              <span class="vote-bar-marker left">-10</span>
              <span class="vote-bar-marker center">0</span>
              <span class="vote-bar-marker right">+10</span>
            </div>
          </div>
          <div class="vote-status-text">
            <span class="vote-score ${voteScore > 0 ? 'positive' : voteScore < 0 ? 'negative' : 'neutral'}">
              Vote Score: ${voteScore >= 0 ? '+' : ''}${voteScore}
            </span>
          </div>
        </div>
      `;
    }
      
      // Wait for all proposal HTML to be generated
      const proposalHtmlArray = await Promise.all(proposalHtmlPromises);
      
      // Set the innerHTML with all the generated HTML
      list.innerHTML = proposalHtmlArray.join('');
    }
    
    // Caches for NPC and Item names
    const npcsCache = {};
    const itemsCache = {};
    
    // Function to get NPC name with caching
    async function getNPCName(npcId) {
      if (!npcId) return null;
      
      if (npcsCache[npcId]) {
        return npcsCache[npcId];
      }
      
      try {
        const response = await fetch(`/api/npcs/${npcId}`);
        if (response.ok) {
          const npc = await response.json();
          if (npc && npc.name) {
            npcsCache[npcId] = npc.name;
            return npc.name;
          }
        }
      } catch (error) {
        console.warn('Failed to fetch NPC name:', error);
      }
      
      return null;
    }
    
    // Function to get Item name with caching
    async function getItemName(itemId) {
      if (!itemId) return null;
      
      if (itemsCache[itemId]) {
        return itemsCache[itemId];
      }
      
      try {
        const response = await fetch(`/api/items/${itemId}`);
        if (response.ok) {
          const item = await response.json();
          if (item && item.name) {
            itemsCache[itemId] = item.name;
            return item.name;
          }
        }
      } catch (error) {
        console.warn('Failed to fetch item name:', error);
      }
      
      return null;
    }
    
    function getProposalTitle(proposal) {
      const data = proposal.proposed_data;
      switch (proposal.change_type) {
        case 'add_poi':
          return `New POI: ${data.name}`;
        case 'edit_poi':
          return `Edit POI: ${proposal.current_data?.name || 'POI #' + proposal.target_id}`;
        case 'move_poi':
          return `Move POI: ${data.name || 'POI #' + data.poi_id}`;
        case 'add_npc':
          return `New NPC: ${data.name}`;
        case 'edit_npc':
          return `Edit NPC: ${data.name || 'NPC #' + data.npc_id}`;
        case 'add_item':
          return `New Item: ${data.name}`;
        case 'edit_item':
          return `Edit Item: ${data.name || 'Item #' + data.item_id}`;
        case 'delete_poi':
          return `Delete POI: ${proposal.current_data?.name || 'POI #' + proposal.target_id}`;
        case 'change_loot':
          const npcName = proposal.current_data?.npc_name || 'Unknown NPC';
          return `Change NPC Loot (${npcName})`;
        default:
          return 'Change Proposal';
      }
    }

    async function getProposalDescription(proposal) {
      const data = proposal.proposed_data;
      const current = proposal.current_data;
      let desc = '';
      
      // Debug log for multi-mob proposals
      if (proposal.change_type === 'add_poi' && proposal.is_multi_mob) {
        console.log('Multi-mob proposal:', {
          id: proposal.id,
          is_multi_mob: proposal.is_multi_mob,
          npc_associations: proposal.npc_associations,
          type_name: proposal.type_name
        });
      }
      
      if (proposal.notes) {
        desc += `<p style="color: #ccc; margin-bottom: 0.5rem;">${proposal.notes}</p>`;
      }
      
      switch (proposal.change_type) {
        case 'add_poi':
          desc += `<div style="background: rgba(0,0,0,0.3); padding: 0.75rem; border-radius: 4px; margin-bottom: 0.5rem;">`;
          desc += `<p><strong>Map:</strong> ${proposal.map_name || data.map_name || `Map ${data.map_id}`}</p>`;
          desc += `<p><strong>Location:</strong> ${data.x}, ${data.y}</p>`;
          if (proposal.type_name || data.type_name) {
            let typeIcon = '';
            if (proposal.type_icon_type === 'emoji' && proposal.type_icon_value) {
              typeIcon = `<span style="font-size: 1.2em; margin-right: 0.25rem;">${proposal.type_icon_value}</span>`;
            } else if (proposal.type_icon_type === 'iconify' && proposal.type_icon_value) {
              typeIcon = `<iconify-icon icon="${proposal.type_icon_value}" width="20" style="vertical-align: middle; margin-right: 0.25rem;"></iconify-icon>`;
            }
            desc += `<p><strong>Type:</strong> ${typeIcon}${proposal.type_name || data.type_name}</p>`;
          }
          if (proposal.npc_name || data.npc_name) desc += `<p><strong>NPC:</strong> ${proposal.npc_name || data.npc_name}</p>`;
          
          // Add NPC list button for multi-mob POIs
          if (proposal.is_multi_mob && proposal.npc_associations && proposal.npc_associations.length > 0) {
            desc += `<div style="margin-top: 0.5rem;">`;
            desc += `<button class="small-btn info-btn" onclick="showProposalNPCs(${proposal.id}); event.stopPropagation();">`;
            desc += `<span style="margin-right: 0.5rem;"></span>Show NPCs (${proposal.npc_associations.length})`;
            desc += `</button>`;
            desc += `</div>`;
          }
          if (proposal.item_name || data.item_name) desc += `<p><strong>Item:</strong> ${proposal.item_name || data.item_name}</p>`;
          desc += `</div>`;
          if (data.description) desc += `<p><strong>Description:</strong> ${data.description}</p>`;
          break;
          
        case 'edit_poi':
          // Show map name for context
          if (proposal.map_name) {
            desc += `<p style="margin-bottom: 1rem;"><strong>Zone:</strong> ${proposal.map_name}</p>`;
          }
          desc += `<div class="proposal-diff-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 0.5rem;">`;
          desc += `<div style="background: rgba(255,0,0,0.1); padding: 0.75rem; border-radius: 4px;">`;
          desc += `<h4 style="margin: 0 0 0.5rem 0; color: #ff6b6b;">Current</h4>`;
          
          // Only show fields that are being changed
          if (data.name !== undefined && data.name !== current?.name) {
            desc += `<p><strong>Name:</strong> ${current?.name || 'None'}</p>`;
          }
          if (data.description !== undefined && data.description !== current?.description) {
            desc += `<p><strong>Description:</strong> ${current?.description || 'None'}</p>`;
          }
          if (data.type_id !== undefined && data.type_id !== current?.type_id) {
            const currentTypeName = proposal.current_type_name || 
                                   (current?.type_id ? 'Type #' + current.type_id : 'None');
            desc += `<p><strong>Type:</strong> ${currentTypeName}</p>`;
          }
          if (data.npc_id !== undefined && data.npc_id !== current?.npc_id) {
            let currentNPC = 'None';
            if (current?.npc_id) {
              const npcName = await getNPCName(current.npc_id);
              currentNPC = npcName || proposal.current_npc_name || `NPC #${current.npc_id}`;
            }
            desc += `<p><strong>NPC:</strong> ${currentNPC}</p>`;
          }
          if (data.item_id !== undefined && data.item_id !== current?.item_id) {
            let currentItem = 'None';
            if (current?.item_id) {
              const itemName = await getItemName(current.item_id);
              currentItem = itemName || proposal.current_item_name || `Item #${current.item_id}`;
            }
            desc += `<p><strong>Item:</strong> ${currentItem}</p>`;
          }
          
          desc += `</div>`;
          desc += `<div style="background: rgba(0,255,0,0.1); padding: 0.75rem; border-radius: 4px;">`;
          desc += `<h4 style="margin: 0 0 0.5rem 0; color: #51cf66;">Proposed</h4>`;
          
          // Show the proposed values for the same fields
          if (data.name !== undefined && data.name !== current?.name) {
            desc += `<p><strong>Name:</strong> ${data.name}</p>`;
          }
          if (data.description !== undefined && data.description !== current?.description) {
            desc += `<p><strong>Description:</strong> ${data.description || 'None'}</p>`;
          }
          if (data.type_id !== undefined && data.type_id !== current?.type_id) {
            desc += `<p><strong>Type:</strong> ${proposal.type_name || 'Type #' + data.type_id}</p>`;
          }
          if (data.npc_id !== undefined && data.npc_id !== current?.npc_id) {
            let proposedNPC = 'None';
            if (data.npc_id) {
              const npcName = await getNPCName(data.npc_id);
              proposedNPC = npcName || proposal.npc_name || `NPC #${data.npc_id}`;
            }
            desc += `<p><strong>NPC:</strong> ${proposedNPC}</p>`;
          }
          if (data.item_id !== undefined && data.item_id !== current?.item_id) {
            let proposedItem = 'None';
            if (data.item_id) {
              const itemName = await getItemName(data.item_id);
              proposedItem = itemName || proposal.item_name || `Item #${data.item_id}`;
            }
            desc += `<p><strong>Item:</strong> ${proposedItem}</p>`;
          }
          
          desc += `</div>`;
          desc += `</div>`;
          break;
          
        case 'move_poi':
          desc += `<div style="background: rgba(0,0,0,0.3); padding: 0.75rem; border-radius: 4px; margin-bottom: 0.5rem;">`;
          desc += `<p><strong>POI:</strong> ${data.name || 'Unnamed POI'}</p>`;
          desc += `<p><strong>Map:</strong> ${proposal.map_name || `Map ${data.map_id}`}</p>`;
          if (proposal.type_name) {
            let typeIcon = '';
            if (proposal.type_icon_type === 'emoji' && proposal.type_icon_value) {
              typeIcon = `<span style="font-size: 1.2em; margin-right: 0.25rem;">${proposal.type_icon_value}</span>`;
            } else if (proposal.type_icon_type === 'iconify' && proposal.type_icon_value) {
              typeIcon = `<iconify-icon icon="${proposal.type_icon_value}" width="20" style="vertical-align: middle; margin-right: 0.25rem;"></iconify-icon>`;
            }
            desc += `<p><strong>Type:</strong> ${typeIcon}${proposal.type_name}</p>`;
          }
          desc += `</div>`;
          desc += `<div class="proposal-diff-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 0.5rem;">`;
          desc += `<div style="background: rgba(255,0,0,0.1); padding: 0.75rem; border-radius: 4px;">`;
          desc += `<h4 style="margin: 0 0 0.5rem 0; color: #ff6b6b;">Current Location</h4>`;
          desc += `<p><strong>X:</strong> ${current.x}, <strong>Y:</strong> ${current.y}</p>`;
          desc += `</div>`;
          desc += `<div style="background: rgba(0,255,0,0.1); padding: 0.75rem; border-radius: 4px;">`;
          desc += `<h4 style="margin: 0 0 0.5rem 0; color: #51cf66;">Proposed Location</h4>`;
          desc += `<p><strong>X:</strong> ${data.x}, <strong>Y:</strong> ${data.y}</p>`;
          desc += `</div>`;
          desc += `</div>`;
          break;
          
        case 'delete_poi':
          // Debug log for delete_poi
          
          desc += `<div style="background: rgba(255,0,0,0.15); padding: 1rem; border-radius: 8px; border: 2px solid rgba(255,0,0,0.3);">`;
          desc += `<div style="display: flex; align-items: center; margin-bottom: 1rem;">`;
          desc += `<span style="font-size: 2rem; margin-right: 0.5rem;"></span>`;
          desc += `<h3 style="margin: 0; color: #ff6b6b;">This POI will be permanently deleted</h3>`;
          desc += `</div>`;
          
          desc += `<div style="background: rgba(0,0,0,0.3); padding: 0.75rem; border-radius: 4px;">`;
          desc += `<p><strong>POI Name:</strong> ${current?.name || 'Unnamed POI'}</p>`;
          desc += `<p><strong>Zone:</strong> ${proposal.map_name || 'Unknown'}</p>`;
          
          if (proposal.type_name || current?.type_id) {
            let typeIcon = '';
            if (proposal.type_icon_type === 'emoji' && proposal.type_icon_value) {
              typeIcon = `<span style="font-size: 1.2em; margin-right: 0.25rem;">${proposal.type_icon_value}</span>`;
            } else if (proposal.type_icon_type === 'iconify' && proposal.type_icon_value) {
              typeIcon = `<iconify-icon icon="${proposal.type_icon_value}" width="20" style="vertical-align: middle; margin-right: 0.25rem;"></iconify-icon>`;
            }
            desc += `<p><strong>Type:</strong> ${typeIcon}${proposal.type_name || proposal.current_type_name || current?.type_name || 'Type #' + (current?.type_id || 'Unknown')}</p>`;
          }
          
          if (proposal.poi_x !== null && proposal.poi_y !== null) {
            desc += `<p><strong>Location:</strong> ${proposal.poi_x}, ${proposal.poi_y}</p>`;
          }
          
          if (current?.description) {
            desc += `<p><strong>Description:</strong> ${current.description}</p>`;
          }
          
          if (proposal.npc_name || current?.npc_id) {
            desc += `<p><strong>Associated NPC:</strong> ${proposal.npc_name || 'NPC #' + current.npc_id}</p>`;
          }
          
          if (proposal.item_name || current?.item_id) {
            desc += `<p><strong>Associated Item:</strong> ${proposal.item_name || 'Item #' + current.item_id}</p>`;
          }
          
          desc += `</div>`;
          desc += `</div>`;
          break;
          
        case 'add_npc':
          desc += `<div style="background: rgba(0,0,0,0.3); padding: 0.75rem; border-radius: 4px; margin-bottom: 0.5rem;">`;
          
          // Show NPC icon based on type (Combat NPC = , Quest NPC = )
          const npcIcon = data.npc_type === 'Combat NPC' ? '' : '';
          desc += `<p style="display: flex; align-items: center;">`;
          desc += `<span style="font-size: 2em; margin-right: 0.5rem;">${npcIcon}</span>`;
          desc += `<strong>${data.name}</strong>`;
          desc += `</p>`;
          
          desc += `<p><strong>Type:</strong> ${data.npc_type || 'NPC'}</p>`;
          desc += `<p><strong>Level:</strong> ${data.level}  <strong>HP:</strong> ${data.hp}  <strong>AC:</strong> ${data.ac}</p>`;
          
          // Show damage if specified
          if (data.min_dmg || data.max_dmg) {
            desc += `<p><strong>Damage:</strong> ${data.min_dmg || 0}-${data.max_dmg || 0}</p>`;
          }
          
          // Show stats if any are non-zero
          const npcStats = [];
          if (data.str && data.str !== 10) npcStats.push(`STR: ${data.str}`);
          if (data.sta && data.sta !== 10) npcStats.push(`STA: ${data.sta}`);
          if (data.agi && data.agi !== 10) npcStats.push(`AGI: ${data.agi}`);
          if (data.dex && data.dex !== 10) npcStats.push(`DEX: ${data.dex}`);
          if (data.wis && data.wis !== 10) npcStats.push(`WIS: ${data.wis}`);
          if (data.int && data.int !== 10) npcStats.push(`INT: ${data.int}`);
          if (data.cha && data.cha !== 10) npcStats.push(`CHA: ${data.cha}`);
          
          if (npcStats.length > 0) {
            desc += `<p><strong>Stats:</strong> ${npcStats.join(', ')}</p>`;
          }
          
          desc += `</div>`;
          
          if (data.description) desc += `<p><strong>Description:</strong> ${data.description}</p>`;
          break;
          
        case 'add_item':
          desc += `<div style="background: rgba(0,0,0,0.3); padding: 0.75rem; border-radius: 4px; margin-bottom: 0.5rem;">`;
          
          // Show item icon if available
          if (data.icon_value) {
            let iconHtml = '';
            if (data.icon_type === 'emoji') {
              iconHtml = `<span style="font-size: 2em; margin-right: 0.5rem;">${data.icon_value}</span>`;
            } else if (data.icon_type === 'iconify') {
              iconHtml = `<iconify-icon icon="${data.icon_value}" width="32" style="vertical-align: middle; margin-right: 0.5rem;"></iconify-icon>`;
            }
            if (iconHtml) {
              desc += `<p style="display: flex; align-items: center;">${iconHtml}<strong>${data.name}</strong></p>`;
            }
          }
          
          if (data.item_type) desc += `<p><strong>Type:</strong> ${data.item_type}</p>`;
          if (data.slot) desc += `<p><strong>Slot:</strong> ${data.slot}</p>`;
          
          // Show stats if any are non-zero
          const stats = [];
          if (data.str) stats.push(`STR: ${data.str}`);
          if (data.sta) stats.push(`STA: ${data.sta}`);
          if (data.agi) stats.push(`AGI: ${data.agi}`);
          if (data.dex) stats.push(`DEX: ${data.dex}`);
          if (data.wis) stats.push(`WIS: ${data.wis}`);
          if (data.int) stats.push(`INT: ${data.int}`);
          if (data.cha) stats.push(`CHA: ${data.cha}`);
          
          if (stats.length > 0) {
            desc += `<p><strong>Stats:</strong> ${stats.join(', ')}</p>`;
          }
          
          // Show other modifiers
          const mods = [];
          if (data.ac) mods.push(`AC: ${data.ac}`);
          if (data.health) mods.push(`Health: +${data.health}`);
          if (data.mana) mods.push(`Mana: +${data.mana}`);
          if (data.attack_speed) mods.push(`Attack Speed: ${data.attack_speed}`);
          
          if (mods.length > 0) {
            desc += `<p><strong>Modifiers:</strong> ${mods.join(', ')}</p>`;
          }
          desc += `</div>`;
          
          if (data.description) desc += `<p><strong>Description:</strong> ${data.description}</p>`;
          break;
          
        case 'edit_item':
          // Show item name and info at the top
          desc += `<div style="margin-bottom: 1rem; padding: 0.5rem; background: rgba(255,215,0,0.1); border-radius: 4px;">`;
          desc += `<p style="margin: 0;"><strong>Item:</strong> ${data.name || 'Unknown'}</p>`;
          if (data.item_type) desc += `<p style="margin: 0.25rem 0 0 0;"><strong>Type:</strong> ${data.item_type}</p>`;
          if (data.slot) desc += `<p style="margin: 0.25rem 0 0 0;"><strong>Slot:</strong> ${data.slot}</p>`;
          desc += `</div>`;
          
          // Create comparison grid for changed fields
          desc += `<div class="proposal-diff-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 0.5rem;">`;
          desc += `<div style="background: rgba(255,0,0,0.1); padding: 0.75rem; border-radius: 4px;">`;
          desc += `<h4 style="margin: 0 0 0.5rem 0; color: #ff6b6b;">Current</h4>`;
          
          // Show all fields that could be changed
          const itemFields = {
            'name': 'Name',
            'description': 'Description',
            'item_type': 'Type',
            'slot': 'Slot',
            'str': 'STR',
            'sta': 'STA',
            'agi': 'AGI',
            'dex': 'DEX',
            'wis': 'WIS',
            'int': 'INT',
            'cha': 'CHA',
            'ac': 'AC',
            'health': 'HP',
            'mana': 'MP',
            'attack_speed': 'Attack Speed'
          };
          
          for (const [field, label] of Object.entries(itemFields)) {
            if (current && current[field] !== undefined && current[field] !== data[field]) {
              desc += `<div style="margin: 0.25rem 0;"><strong>${label}:</strong> ${current[field] || 'None'}</div>`;
            }
          }
          
          desc += `</div>`;
          desc += `<div style="background: rgba(0,255,0,0.1); padding: 0.75rem; border-radius: 4px;">`;
          desc += `<h4 style="margin: 0 0 0.5rem 0; color: #51cf66;">Proposed</h4>`;
          
          for (const [field, label] of Object.entries(itemFields)) {
            if (current && current[field] !== undefined && current[field] !== data[field]) {
              desc += `<div style="margin: 0.25rem 0;"><strong>${label}:</strong> ${data[field] || 'None'}</div>`;
            }
          }
          
          desc += `</div>`;
          desc += `</div>`;
          break;
          
        case 'edit_npc':
          // Show NPC name and info at the top
          desc += `<div style="margin-bottom: 1rem; padding: 0.5rem; background: rgba(139,69,19,0.1); border-radius: 4px;">`;
          desc += `<p style="margin: 0;"><strong>NPC:</strong> ${data.name || 'Unknown'}</p>`;
          if (data.npc_type) desc += `<p style="margin: 0.25rem 0 0 0;"><strong>Type:</strong> ${data.npc_type}</p>`;
          desc += `</div>`;
          
          // Create comparison grid for changed stats
          desc += `<div class="proposal-diff-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 0.5rem;">`;
          desc += `<div style="background: rgba(255,0,0,0.1); padding: 0.75rem; border-radius: 4px;">`;
          desc += `<h4 style="margin: 0 0 0.5rem 0; color: #ff6b6b;">Current</h4>`;
          
          // Show only changed fields
          const npcStatFields = {
            'level': 'Level',
            'hp': 'HP',
            'mp': 'MP',
            'ac': 'AC',
            'str': 'STR',
            'sta': 'STA',
            'agi': 'AGI',
            'dex': 'DEX',
            'wis': 'WIS',
            'int': 'INT',
            'cha': 'CHA',
            'min_dmg': 'Min Damage',
            'max_dmg': 'Max Damage',
            'attack_speed': 'Attack Speed'
          };
          
          Object.keys(npcStatFields).forEach(field => {
            if (current[field] !== undefined) {
              desc += `<p style="margin: 0.25rem 0;"><strong>${npcStatFields[field]}:</strong> ${current[field]}</p>`;
            }
          });
          
          desc += `</div>`;
          desc += `<div style="background: rgba(0,255,0,0.1); padding: 0.75rem; border-radius: 4px;">`;
          desc += `<h4 style="margin: 0 0 0.5rem 0; color: #51cf66;">Proposed</h4>`;
          
          Object.keys(npcStatFields).forEach(field => {
            if (current[field] !== undefined) {
              const changed = data[field] !== current[field];
              desc += `<p style="margin: 0.25rem 0; ${changed ? 'font-weight: bold;' : ''}">`;
              desc += `<strong>${npcStatFields[field]}:</strong> ${data[field] !== undefined ? data[field] : current[field]}`;
              desc += `</p>`;
            }
          });
          
          desc += `</div>`;
          desc += `</div>`;
          break;
          
        case 'edit_item':
          desc += `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">`;
          desc += `<div style="background: rgba(255,0,0,0.1); padding: 0.75rem; border-radius: 4px;">`;
          desc += `<h4 style="margin: 0 0 0.5rem 0; color: #ff6b6b;">Current</h4>`;
          desc += `<pre style="font-size: 0.8rem; overflow-x: auto;">${JSON.stringify(current, null, 2)}</pre>`;
          desc += `</div>`;
          desc += `<div style="background: rgba(0,255,0,0.1); padding: 0.75rem; border-radius: 4px;">`;
          desc += `<h4 style="margin: 0 0 0.5rem 0; color: #51cf66;">Proposed</h4>`;
          desc += `<pre style="font-size: 0.8rem; overflow-x: auto;">${JSON.stringify(data, null, 2)}</pre>`;
          desc += `</div>`;
          desc += `</div>`;
          break;
          
        case 'change_loot':
          // Show zone, POI and NPC info at the top
          desc += `<div style="margin-bottom: 1rem; padding: 0.5rem; background: rgba(139,69,19,0.1); border-radius: 4px;">`;
          desc += `<div style="display: flex; justify-content: space-between; align-items: center;">`;
          desc += `<div>`;
          desc += `<span style="margin-right: 1rem;"><strong>Zone:</strong> ${current.map_name || 'Unknown Zone'}</span>`;
          desc += `<span style="margin-right: 1rem;"><strong>POI:</strong> ${current.poi_name || 'Unknown POI'}</span>`;
          desc += `<span><strong>NPC:</strong> ${current.npc_name || 'Unknown NPC'}</span>`;
          desc += `</div>`;
          desc += `</div>`;
          desc += `</div>`;
          
          // Red/Green comparison grid
          desc += `<div class="proposal-diff-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 0.5rem;">`;
          
          // Current loot (left side - red)
          desc += `<div style="background: rgba(255,0,0,0.1); padding: 0.75rem; border-radius: 4px;">`;
          desc += `<h4 style="margin: 0 0 0.5rem 0; color: #ff6b6b;">Current Loot</h4>`;
          if (current.existing_loot && current.existing_loot.length > 0) {
            desc += `<ul style="margin: 0; padding-left: 1.5rem;">`;
            current.existing_loot.forEach(item => {
              desc += `<li style="margin-bottom: 0.5rem;">`;
              desc += `<strong>${item.item_name}</strong>`;
              desc += `</li>`;
            });
            desc += `</ul>`;
          } else {
            desc += `<p style="margin: 0; color: #888;">No current loot items</p>`;
          }
          desc += `</div>`;
          
          // Proposed loot (right side - green)
          desc += `<div style="background: rgba(0,255,0,0.1); padding: 0.75rem; border-radius: 4px;">`;
          desc += `<h4 style="margin: 0 0 0.5rem 0; color: #51cf66;">Proposed Loot</h4>`;
          
          // Create a map of current items for easy lookup
          const currentItemMap = new Map();
          if (current.existing_loot && current.existing_loot.length > 0) {
            current.existing_loot.forEach(item => {
              currentItemMap.set(item.item_id, item);
            });
          }
          
          // Create a map of proposed items
          const proposedItemMap = new Map();
          if (data.loot_items && data.loot_items.length > 0) {
            data.loot_items.forEach(item => {
              proposedItemMap.set(item.item_id, item);
            });
          }
          
          // Build the final list showing all items with their status
          const allItems = [];
          
          // Add all current items, marking which ones are removed
          currentItemMap.forEach((item, itemId) => {
            if (!proposedItemMap.has(itemId)) {
              // Item is being removed
              allItems.push({ ...item, status: 'removed' });
            } else {
              // Item is kept
              const proposedItem = proposedItemMap.get(itemId);
              allItems.push({ ...proposedItem, status: 'kept' });
            }
          });
          
          // Add new items
          proposedItemMap.forEach((item, itemId) => {
            if (!currentItemMap.has(itemId)) {
              allItems.push({ ...item, status: 'added' });
            }
          });
          
          if (allItems.length > 0) {
            desc += `<ul style="margin: 0; padding-left: 1.5rem;">`;
            allItems.forEach(item => {
              desc += `<li style="margin-bottom: 0.5rem;">`;
              
              // Add status indicator
              if (item.status === 'added') {
                desc += `<span style="color: #51cf66; font-weight: bold;">+ </span>`;
              } else if (item.status === 'removed') {
                desc += `<span style="color: #ff6b6b; font-weight: bold;">- </span>`;
                desc += `<span style="text-decoration: line-through; opacity: 0.7;">`;
              }
              
              desc += `<strong>${item.item_name}</strong>`;
              
              if (item.status === 'removed') {
                desc += `</span>`; // Close strikethrough span
              }
              
              desc += `</li>`;
            });
            desc += `</ul>`;
          } else {
            desc += `<p style="margin: 0; color: #888;">No items</p>`;
          }
          desc += `</div>`;
          desc += `</div>`;
          break;
      }
      
      return desc;
    }

    function formatChangeType(type) {
      const types = {
        'add_poi': 'New POI',
        'edit_poi': 'Edit POI',
        'move_poi': 'Move POI',
        'delete_poi': 'Delete POI',
        'add_npc': 'New NPC',
        'edit_npc': 'Edit NPC',
        'add_item': 'New Item',
        'edit_item': 'Edit Item',
        'change_loot': 'Change Loot'
      };
      return types[type] || type;
    }

    function formatDate(dateStr) {
      const date = new Date(dateStr);
      const now = new Date();
      const diffMs = now - date;
      const diffMins = Math.floor(diffMs / 60000);
      
      if (diffMins < 1) return 'just now';
      if (diffMins < 60) return `${diffMins}m ago`;
      if (diffMins < 1440) return `${Math.floor(diffMins / 60)}h ago`;
      if (diffMins < 10080) return `${Math.floor(diffMins / 1440)}d ago`;
      
      return date.toLocaleDateString();
    }

    async function voteProposal(proposalId, vote) {
      try {
        // Check if this is the proposer trying to downvote their own proposal
        const proposal = currentProposals.find(p => p.id === proposalId);
        if (proposal && proposal.proposer_id === currentUser.id && vote === -1) {
          showConfirmDialog(
            'Are you sure you want to withdraw your proposal? This action cannot be undone.',
            async () => {
              // Proceed with the vote
              await performVote(proposalId, vote);
            }
          );
          return;
        }
        
        // Normal vote - proceed directly
        await performVote(proposalId, vote);
      } catch (error) {
        console.error('Error voting:', error);
        showMessage('Failed to vote', 'error');
      }
    }
    
    async function performVote(proposalId, vote) {
      const response = await window.csrfHelper.fetchWithCSRF(`/api/change-proposals/${proposalId}/vote`, {
        method: 'POST',
        body: { vote }
      });
      
      if (response.ok) {
        const result = await response.json();
        
        if (result.withdrawn) {
          showMessage('Proposal withdrawn', 'info');
        } else if (result.approved) {
          showMessage('Proposal approved!', 'success');
        } else if (result.rejected) {
          showMessage('Proposal rejected', 'info');
        }
        
        // Reload proposals and update count
        loadProposals();
        loadVotingStats();
        loadInitialProposalCount();
      } else {
        const error = await response.json();
        showMessage(error.error || 'Failed to vote', 'error');
      }
    }

    async function deleteProposal(proposalId) {
      if (!confirm('Are you sure you want to delete this proposal?')) {
        return;
      }
      
      try {
        const response = await window.csrfHelper.fetchWithCSRF(`/api/change-proposals/${proposalId}`, {
          method: 'DELETE'
        });
        
        if (response.ok) {
          showMessage('Proposal deleted', 'success');
          loadProposals();
          loadVotingStats();
          loadInitialProposalCount();
          
          // Mark that the main map page should refresh POI data
          sessionStorage.setItem('refresh_pois', 'true');
          
          // Reload the page to ensure all data is fresh
          setTimeout(() => {
            window.location.reload();
          }, 500);
        } else {
          const error = await response.json();
          showMessage(error.error || 'Failed to delete proposal', 'error');
        }
      } catch (error) {
        console.error('Error deleting proposal:', error);
        showMessage('Failed to delete proposal', 'error');
      }
    }

    // Function to show NPCs for multi-mob proposals
    async function showProposalNPCs(proposalId) {
      const proposal = currentProposals.find(p => p.id === proposalId);
      if (!proposal || !proposal.npc_associations) return;
      
      const modal = document.getElementById('proposal-npcs-modal');
      const content = document.getElementById('proposal-npcs-content');
      
      // Show loading state
      content.innerHTML = '<div style="text-align: center; padding: 2rem;"><div style="color: #999;">Loading NPC details...</div></div>';
      modal.style.display = 'flex';
      
      // Fetch full NPC data for each NPC
      const npcPromises = proposal.npc_associations.map(async npc => {
        try {
          const response = await fetch(`/api/npcs/${npc.npcid}`);
          if (response.ok) {
            const fullData = await response.json();
            return { ...npc, ...fullData };
          }
        } catch (error) {
          console.error('Error fetching NPC data:', error);
        }
        return npc;
      });
      
      const npcsWithFullData = await Promise.all(npcPromises);
      
      // Check if any NPCs have details to show
      const hasAnyDetails = npcsWithFullData.some(npc => {
        return (npc.hp && npc.hp > 0) || 
               (npc.ac && npc.ac > 0) || 
               (npc.min_dmg && npc.min_dmg > 0) || 
               (npc.max_dmg && npc.max_dmg > 0) || 
               (npc.attack_speed && npc.attack_speed > 0) ||
               npc.description;
      });
      
      // Build enhanced NPC list HTML
      let html = `
        <div style="margin-bottom: 1.5rem;">
          <div style="color: #FFD700; font-weight: 600; margin-bottom: 0.5rem;">This multi-mob POI includes ${npcsWithFullData.length} NPCs:</div>
          ${hasAnyDetails ? '<div style="color: #999; font-size: 0.9rem;">Click on an NPC for more details</div>' : ''}
        </div>
      `;
      
      html += '<div style="display: grid; gap: 1rem; max-height: 50vh; overflow-y: auto; padding-right: 0.5rem;">';
      
      npcsWithFullData.forEach((npc, index) => {
        const hasFullData = npc.hp !== undefined;
        const hasValidStats = (npc.hp && npc.hp > 0) || 
                             (npc.ac && npc.ac > 0) || 
                             (npc.min_dmg && npc.min_dmg > 0) || 
                             (npc.max_dmg && npc.max_dmg > 0) || 
                             (npc.attack_speed && npc.attack_speed > 0) ||
                             npc.description;
        html += `
          <div style="background: linear-gradient(135deg, rgba(0, 0, 0, 0.4) 0%, rgba(0, 0, 0, 0.6) 100%); 
                      padding: 1rem; border-radius: 6px; border: 1px solid #444; 
                      cursor: pointer; transition: all 0.2s;"
               onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.3)';"
               onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none';"
               onclick="toggleNPCDetails('npc-details-${index}')">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <div>
                <span style="color: #FFD700; font-weight: bold; font-size: 1.1rem;">${npc.name}</span>
                <span style="color: #FFA500; margin-left: 0.75rem; font-weight: 500;">Level ${npc.level}</span>
              </div>
              <span style="color: #666; font-size: 0.85rem;">ID: ${npc.npcid}</span>
            </div>
            ${hasFullData && hasValidStats ? `
              <div id="npc-details-${index}" style="display: none; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #333;">
                ${npc.description ? `<div style="color: #bbb; margin-bottom: 0.75rem; font-style: italic;">${formatDescription(npc.description)}</div>` : ''}
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 0.75rem;">
                  ${npc.hp && npc.hp > 0 ? `
                    <div style="background: rgba(255, 0, 0, 0.1); padding: 0.5rem; border-radius: 4px; border: 1px solid rgba(255, 0, 0, 0.2);">
                      <div style="color: #888; font-size: 0.85rem; margin-bottom: 0.25rem;">HP</div>
                      <div style="color: #e74c3c; font-weight: 600; font-size: 1.1rem;">${npc.hp}</div>
                    </div>
                  ` : ''}
                  ${npc.ac && npc.ac > 0 ? `
                    <div style="background: rgba(52, 152, 219, 0.1); padding: 0.5rem; border-radius: 4px; border: 1px solid rgba(52, 152, 219, 0.2);">
                      <div style="color: #888; font-size: 0.85rem; margin-bottom: 0.25rem;">AC</div>
                      <div style="color: #3498db; font-weight: 600; font-size: 1.1rem;">${npc.ac}</div>
                    </div>
                  ` : ''}
                  ${(npc.min_dmg && npc.min_dmg > 0) || (npc.max_dmg && npc.max_dmg > 0) ? `
                    <div style="background: rgba(243, 156, 18, 0.1); padding: 0.5rem; border-radius: 4px; border: 1px solid rgba(243, 156, 18, 0.2);">
                      <div style="color: #888; font-size: 0.85rem; margin-bottom: 0.25rem;">Damage</div>
                      <div style="color: #f39c12; font-weight: 600; font-size: 1.1rem;">${npc.min_dmg || 0}-${npc.max_dmg || 0}</div>
                    </div>
                  ` : ''}
                  ${npc.attack_speed && npc.attack_speed > 0 ? `
                    <div style="background: rgba(39, 174, 96, 0.1); padding: 0.5rem; border-radius: 4px; border: 1px solid rgba(39, 174, 96, 0.2);">
                      <div style="color: #888; font-size: 0.85rem; margin-bottom: 0.25rem;">Attack Speed</div>
                      <div style="color: #27ae60; font-weight: 600; font-size: 1.1rem;">${npc.attack_speed}</div>
                    </div>
                  ` : ''}
                </div>
              </div>
            ` : ''}
          </div>
        `;
      });
      
      html += '</div>';
      content.innerHTML = html;
    }
    
    function toggleNPCDetails(detailsId) {
      const details = document.getElementById(detailsId);
      if (details) {
        details.style.display = details.style.display === 'none' ? 'block' : 'none';
      }
    }
    
    function closeProposalNPCsModal() {
      document.getElementById('proposal-npcs-modal').style.display = 'none';
    }
    
    // Add escape key handler for modal
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && document.getElementById('proposal-npcs-modal').style.display === 'flex') {
        closeProposalNPCsModal();
      }
    });
    
    // Function to view a POI proposal on the map temporarily
    function viewProposalPOI(proposalId) {
      const proposal = currentProposals.find(p => p.id === proposalId);
      if (!proposal) return;
      
      
      const data = proposal.proposed_data;
      const current = proposal.current_data;
      
      // Store the proposal data in sessionStorage for the map page to read
      const previewData = {
        proposalId: proposalId,
        changeType: proposal.change_type,
        targetId: proposal.target_id,  // Add target_id for finding the original POI
        mapId: proposal.map_id,  // Include map_id at top level for easier access
        proposed: {
          ...data,
          map_id: data.map_id || proposal.map_id,  // Include map_id
          map_name: proposal.map_name,
          type_name: proposal.type_name,
          npc_name: proposal.npc_name,
          item_name: proposal.item_name,
          // Include coordinates for edit/delete proposals
          x: data.x || proposal.poi_x,
          y: data.y || proposal.poi_y
        },
        current: {
          ...current,
          id: proposal.target_id,  // Include the POI id
          map_id: proposal.map_id,  // Include map_id for current
          // Include coordinates for edit/delete proposals
          x: current?.x || proposal.poi_x,
          y: current?.y || proposal.poi_y
        },
        proposerName: proposal.proposer_name,
        // Pass the type icon data for proper display
        type_icon_type: proposal.type_icon_type,
        type_icon_value: proposal.type_icon_value,
        // Include multi-mob and NPC associations data
        is_multi_mob: proposal.is_multi_mob,
        npc_associations: proposal.npc_associations,
        // Include voting data
        upvotes: proposal.upvotes || 0,
        downvotes: proposal.downvotes || 0,
        user_vote: proposal.user_vote || 0,
        proposer_id: proposal.proposer_id,
        proposer_donation_tier_name: proposal.proposer_donation_tier_name,
        proposer_donation_tier_color: proposal.proposer_donation_tier_color,
        proposer_donation_tier_icon: proposal.proposer_donation_tier_icon
      };
      
      
      sessionStorage.setItem('poi_proposal_preview', JSON.stringify(previewData));
      
      // Mark that we need to refresh when returning
      sessionStorage.setItem('refresh_on_return', 'true');
      
      // Navigate to the map page
      // The map_id isn't in proposed_data for edit proposals
      // For edit/move/delete/loot/edit_npc proposals, the backend provides map_id at the proposal level
      let mapId = proposal.map_id || data.map_id;
      
      if (!mapId) {
        console.error('No map_id found for proposal:', proposal);
        showMessage('Unable to locate map for this proposal', 'error');
        return;
      }
      
      // Navigate to the map page in a new tab
      window.open(`/?map_id=${mapId}`, '_blank');
      
      // Clear the preview data from this tab's sessionStorage after a short delay
      // This prevents the preview from showing if the user navigates to the map in this tab
      setTimeout(() => {
        sessionStorage.removeItem('poi_proposal_preview');
        sessionStorage.removeItem('refresh_on_return');
      }, 100);
    }
    
    function updateProposalsPagination(totalPages) {
      const pagination = document.getElementById('proposals-pagination');
      const pageInfo = document.getElementById('proposals-page-info');
      const prevBtn = document.getElementById('proposals-prev');
      const nextBtn = document.getElementById('proposals-next');
      
      if (totalPages <= 1) {
        pagination.style.display = 'none';
        return;
      }
      
      pagination.style.display = 'flex';
      pageInfo.textContent = `Page ${proposalsPage} of ${totalPages}`;
      
      prevBtn.disabled = proposalsPage === 1;
      nextBtn.disabled = proposalsPage === totalPages;
      
      prevBtn.onclick = () => {
        if (proposalsPage > 1) {
          proposalsPage--;
          loadProposals();
        }
      };
      
      nextBtn.onclick = () => {
        if (proposalsPage < totalPages) {
          proposalsPage++;
          loadProposals();
        }
      };
    }

    // Filter event handlers
    document.getElementById('proposal-type-filter')?.addEventListener('change', (e) => {
      proposalFilters.type = e.target.value;
      proposalsPage = 1;
      clearActiveCards(); // Clear active card states when filter changes
      loadProposals();
    });

    document.getElementById('proposal-filter')?.addEventListener('change', (e) => {
      proposalFilters.show = e.target.value;
      proposalsPage = 1;
      clearActiveCards(); // Clear active card states when filter changes
      loadProposals();
    });

    function showCreateProposalModal() {
      document.getElementById('create-proposal-modal').style.display = 'block';
      document.getElementById('proposal-change-type').value = '';
      document.getElementById('proposal-form-content').style.display = 'none';
      document.getElementById('proposal-notes').value = '';
    }

    function closeCreateProposalModal() {
      document.getElementById('create-proposal-modal').style.display = 'none';
    }

    function updateProposalForm() {
      const changeType = document.getElementById('proposal-change-type').value;
      const formContent = document.getElementById('proposal-form-content');
      
      if (!changeType) {
        formContent.style.display = 'none';
        return;
      }
      
      formContent.style.display = 'block';
      
      switch (changeType) {
        case 'add_npc':
          formContent.innerHTML = `
            <div class="form-group">
              <label>NPC Name *</label>
              <input type="text" id="proposal-npc-name" class="form-control" required>
            </div>
            <div class="form-group">
              <label>Level *</label>
              <input type="number" id="proposal-npc-level" class="form-control" min="1" max="100" required>
            </div>
            <div class="form-group">
              <label>Stats</label>
              <div class="stat-inputs-grid">
                <input type="number" id="proposal-npc-hp" class="form-control" placeholder="HP" min="1">
                <input type="number" id="proposal-npc-ac" class="form-control" placeholder="AC" min="0">
                <input type="number" id="proposal-npc-min-dmg" class="form-control" placeholder="Min Dmg" min="0">
                <input type="number" id="proposal-npc-max-dmg" class="form-control" placeholder="Max Dmg" min="0">
              </div>
            </div>
            <div class="form-group">
              <label>Description</label>
              <textarea id="proposal-npc-description" class="form-control" rows="2"></textarea>
            </div>
          `;
          break;
          
        case 'add_item':
          formContent.innerHTML = `
            <div class="form-group">
              <label>Item Name *</label>
              <input type="text" id="proposal-item-name" class="form-control" required>
            </div>
            <div class="form-group">
              <label>Type *</label>
              <select id="proposal-item-type" class="form-control">
                <option value="weapon">Weapon</option>
                <option value="armor">Armor</option>
                <option value="consumable">Consumable</option>
                <option value="quest">Quest Item</option>
                <option value="misc">Miscellaneous</option>
              </select>
            </div>
            <div class="form-group">
              <label>Description</label>
              <textarea id="proposal-item-description" class="form-control" rows="2"></textarea>
            </div>
          `;
          break;
          
        case 'edit_poi':
        case 'edit_npc':
        case 'edit_item':
          formContent.innerHTML = `
            <div class="form-group">
              <label>${changeType.includes('poi') ? 'POI' : changeType.includes('npc') ? 'NPC' : 'Item'} ID *</label>
              <input type="number" id="proposal-target-id" class="form-control" placeholder="Enter ID to edit" required>
            </div>
            <div class="form-group">
              <label>What changes do you want to make?</label>
              <textarea id="proposal-changes" class="form-control" rows="3" placeholder="Describe the changes..."></textarea>
            </div>
          `;
          break;
      }
    }

    async function submitProposal() {
      const changeType = document.getElementById('proposal-change-type').value;
      const notes = document.getElementById('proposal-notes').value;
      
      if (!changeType) {
        showMessage('Please select a change type', 'error');
        return;
      }
      
      let proposedData = {};
      let targetId = null;
      
      try {
        switch (changeType) {
          case 'add_npc':
            proposedData = {
              name: document.getElementById('proposal-npc-name').value,
              level: parseInt(document.getElementById('proposal-npc-level').value),
              hp: parseInt(document.getElementById('proposal-npc-hp').value) || 100,
              ac: parseInt(document.getElementById('proposal-npc-ac').value) || 10,
              min_dmg: parseInt(document.getElementById('proposal-npc-min-dmg').value) || 1,
              max_dmg: parseInt(document.getElementById('proposal-npc-max-dmg').value) || 10,
              description: document.getElementById('proposal-npc-description').value
            };
            if (!proposedData.name || !proposedData.level) {
              showMessage('Please fill in all required fields', 'error');
              return;
            }
            break;
            
          case 'add_item':
            proposedData = {
              name: document.getElementById('proposal-item-name').value,
              type: document.getElementById('proposal-item-type').value,
              description: document.getElementById('proposal-item-description').value,
              icon_type: 'emoji',
              icon_value: ''
            };
            if (!proposedData.name) {
              showMessage('Please fill in all required fields', 'error');
              return;
            }
            break;
            
          case 'edit_poi':
          case 'edit_npc':
          case 'edit_item':
            targetId = parseInt(document.getElementById('proposal-target-id').value);
            proposedData = {
              changes: document.getElementById('proposal-changes').value
            };
            if (!targetId || !proposedData.changes) {
              showMessage('Please fill in all required fields', 'error');
              return;
            }
            break;
        }
        
        const response = await window.csrfHelper.fetchWithCSRF('/api/change-proposals', {
          method: 'POST',
          body: {
            change_type: changeType,
            target_type: changeType.includes('poi') ? 'poi' : changeType.includes('npc') ? 'npc' : 'item',
            target_id: targetId,
            current_data: null,
            proposed_data: proposedData,
            notes: notes
          }
        });
        
        if (response.ok) {
          showMessage('Proposal submitted successfully!', 'success');
          closeCreateProposalModal();
          // Add small delay to ensure database transaction is complete
          setTimeout(() => {
            loadProposals();
            loadVotingStats();
            loadInitialProposalCount();
          }, 100);
        } else {
          const error = await response.json();
          showMessage(error.error || 'Failed to submit proposal', 'error');
        }
      } catch (error) {
        console.error('Error submitting proposal:', error);
        showMessage('Failed to submit proposal', 'error');
      }
    }

    async function showAdminProposalModal(proposalId) {
      const modal = document.getElementById('admin-proposal-modal');
      const content = document.getElementById('admin-proposal-content');
      
      modal.style.display = 'block';
      content.innerHTML = '<p>Loading proposal details...</p>';
      
      try {
        const response = await fetch('/api/change-proposals');
        if (response.ok) {
          const proposals = await response.json();
          const proposal = proposals.find(p => p.id === proposalId);
          
          if (!proposal) {
            content.innerHTML = '<p style="color: #f44336;">Proposal not found</p>';
            return;
          }
          
          content.innerHTML = `
            <div style="margin-bottom: 1.5rem;">
              <h3>${getProposalTitle(proposal)}</h3>
              <div class="proposal-meta">
                <span>Proposed by ${proposal.proposer_name}</span>
                <span></span>
                <span>${formatDate(proposal.created_at)}</span>
              </div>
            </div>
            
            <div style="background: #2d2d2d; padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
              <h4>Proposal Details</h4>
              ${await getProposalDescription(proposal)}
              ${proposal.notes ? `<p><strong>Notes:</strong> ${proposal.notes}</p>` : ''}
            </div>
            
            <div style="background: #2d2d2d; padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
              <h4>Current Voting</h4>
              <p>Score: ${proposal.vote_score >= 0 ? '+' : ''}${proposal.vote_score}</p>
              <p>Upvotes: ${proposal.upvotes || 0} | Downvotes: ${proposal.downvotes || 0}</p>
            </div>
            
            <div class="form-group">
              <label>Admin Notes</label>
              <textarea id="admin-proposal-notes" class="form-control" rows="3" placeholder="Add notes about your decision..."></textarea>
            </div>
            
            <div style="display: flex; gap: 1rem; justify-content: flex-end;">
              <button class="btn secondary-btn" onclick="closeAdminProposalModal()">Cancel</button>
              <button class="btn danger-btn" onclick="adminRejectProposal(${proposalId})">Reject</button>
              <button class="btn success-btn" onclick="adminApproveProposal(${proposalId})">Approve</button>
            </div>
          `;
        }
      } catch (error) {
        console.error('Error loading proposal:', error);
        content.innerHTML = '<p style="color: #f44336;">Failed to load proposal details</p>';
      }
    }

    function closeAdminProposalModal() {
      document.getElementById('admin-proposal-modal').style.display = 'none';
    }

    async function adminApproveProposal(proposalId) {
      const notes = document.getElementById('admin-proposal-notes').value;
      
      try {
        const response = await window.csrfHelper.fetchWithCSRF(`/api/admin/change-proposals/${proposalId}/action`, {
          method: 'POST',
          body: {
            action: 'approved',
            notes: notes
          }
        });
        
        if (response.ok) {
          showMessage('Proposal approved!', 'success');
          closeAdminProposalModal();
          loadProposals();
          loadInitialProposalCount();
          loadVotingStats(); // Update the voting statistics including "My Proposals" count
        } else {
          const error = await response.json();
          showMessage(error.error || 'Failed to approve proposal', 'error');
        }
      } catch (error) {
        console.error('Error approving proposal:', error);
        showMessage('Failed to approve proposal', 'error');
      }
    }

    async function adminRejectProposal(proposalId) {
      const notes = document.getElementById('admin-proposal-notes').value;
      
      if (!notes) {
        showMessage('Please provide a reason for rejection', 'error');
        return;
      }
      
      try {
        const response = await window.csrfHelper.fetchWithCSRF(`/api/admin/change-proposals/${proposalId}/action`, {
          method: 'POST',
          body: {
            action: 'rejected',
            notes: notes
          }
        });
        
        if (response.ok) {
          showMessage('Proposal rejected', 'info');
          closeAdminProposalModal();
          loadProposals();
          loadInitialProposalCount();
          loadVotingStats(); // Update the voting statistics including "My Proposals" count
        } else {
          const error = await response.json();
          showMessage(error.error || 'Failed to reject proposal', 'error');
        }
      } catch (error) {
        console.error('Error rejecting proposal:', error);
        showMessage('Failed to reject proposal', 'error');
      }
    }
    
    // Expose voting functions to window after they're defined
    window.voteProposal = voteProposal;
    window.deleteProposal = deleteProposal;
    window.showCreateProposalModal = showCreateProposalModal;
    window.showAdminProposalModal = showAdminProposalModal;
    window.closeCreateProposalModal = closeCreateProposalModal;
    window.updateProposalForm = updateProposalForm;
    window.submitProposal = submitProposal;
    window.closeAdminProposalModal = closeAdminProposalModal;
    window.adminApproveProposal = adminApproveProposal;
    window.adminRejectProposal = adminRejectProposal;
    window.viewProposalPOI = viewProposalPOI;
    window.filterByCard = filterByCard;
    window.loadAdminData = loadAdminData;

    async function loadAdminData() {
      // Load users
      loadUsers();
      // Load POI types
      loadPOITypes();
      // Load POI editor
      loadPOIEditor();
      // Load Item editor
      loadItemEditor();
      // Load NPC editor
      loadNPCEditor();
    }
    
    async function loadPOITypes() {
      const loading = document.getElementById('poi-types-loading');
      const content = document.getElementById('poi-types-content');
      
      try {
        const response = await fetch('/api/poi-types');
        if (response.ok) {
          poiTypes = await response.json();
          displayPOITypes();
          loading.style.display = 'none';
          content.style.display = 'block';
        }
      } catch (error) {
        console.error('Error loading POI types:', error);
        loading.innerHTML = '<p style="color: #dc3545;">Failed to load POI types</p>';
      }
    }
    
    function displayPOITypes() {
      const tbody = document.getElementById('poi-types-tbody');
      tbody.innerHTML = '';
      
      if (poiTypes.length === 0) {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td colspan="8" style="text-align: center; color: #666; padding: 2rem;">
            No POI types defined. Click "Add POI Type" to create one.
          </td>
        `;
        tbody.appendChild(row);
        return;
      }
      
      // Calculate pagination
      const totalPages = Math.ceil(poiTypes.length / POI_TYPES_PER_PAGE);
      const startIndex = currentPOITypePage * POI_TYPES_PER_PAGE;
      const endIndex = Math.min(startIndex + POI_TYPES_PER_PAGE, poiTypes.length);
      const paginatedTypes = poiTypes.slice(startIndex, endIndex);
      
      paginatedTypes.forEach((type, index) => {
        const row = document.createElement('tr');
        row.dataset.typeId = type.id;
        
        // Icon cell
        const iconCell = document.createElement('td');
        iconCell.style.textAlign = 'center';
        if (type.icon_type === 'emoji') {
          iconCell.style.fontSize = '1.5rem';
          iconCell.textContent = type.icon_value;
        } else if (type.icon_type === 'iconify' || type.icon_type === 'fontawesome') {
          iconCell.innerHTML = `<iconify-icon icon="${type.icon_value}" width="24" height="24"></iconify-icon>`;
        } else if (type.icon_type === 'upload') {
          const img = document.createElement('img');
          img.src = type.icon_value;
          img.style.width = '32px';
          img.style.height = '32px';
          img.style.objectFit = 'contain';
          iconCell.appendChild(img);
        }
        row.appendChild(iconCell);
        
        // Name cell
        const nameCell = document.createElement('td');
        nameCell.textContent = type.name;
        row.appendChild(nameCell);
        
        // Type cell
        const typeCell = document.createElement('td');
        typeCell.textContent = type.icon_type.charAt(0).toUpperCase() + type.icon_type.slice(1);
        row.appendChild(typeCell);
        
        // Default cell
        const defaultCell = document.createElement('td');
        defaultCell.style.textAlign = 'center';
        if (type.is_default) {
          const badge = document.createElement('span');
          badge.style.background = '#28a745';
          badge.style.color = 'white';
          badge.style.padding = '0.2rem 0.5rem';
          badge.style.borderRadius = '4px';
          badge.style.fontSize = '0.8rem';
          badge.textContent = 'Default';
          defaultCell.appendChild(badge);
        }
        row.appendChild(defaultCell);
        
        // Multi-Mob cell
        const multiMobCell = document.createElement('td');
        multiMobCell.style.textAlign = 'center';
        if (type.multi_mob) {
          const badge = document.createElement('span');
          badge.style.background = '#6f42c1';
          badge.style.color = 'white';
          badge.style.padding = '0.2rem 0.5rem';
          badge.style.borderRadius = '4px';
          badge.style.fontSize = '0.8rem';
          badge.title = 'POIs of this type can have multiple NPCs';
          badge.textContent = 'Multi';
          multiMobCell.appendChild(badge);
        }
        row.appendChild(multiMobCell);
        
        // Order cell
        const orderCell = document.createElement('td');
        orderCell.style.textAlign = 'center';
        
        const orderButtons = document.createElement('div');
        orderButtons.style.display = 'flex';
        orderButtons.style.gap = '0.25rem';
        orderButtons.style.justifyContent = 'center';
        
        if (index > 0) {
          const upBtn = document.createElement('button');
          upBtn.className = 'small-btn';
          upBtn.style.padding = '0.2rem 0.4rem';
          upBtn.textContent = '';
          upBtn.onclick = () => movePOIType(type.id, -1);
          orderButtons.appendChild(upBtn);
        }
        
        if (index < poiTypes.length - 1) {
          const downBtn = document.createElement('button');
          downBtn.className = 'small-btn';
          downBtn.style.padding = '0.2rem 0.4rem';
          downBtn.textContent = '';
          downBtn.onclick = () => movePOIType(type.id, 1);
          orderButtons.appendChild(downBtn);
        }
        
        orderCell.appendChild(orderButtons);
        row.appendChild(orderCell);
        
        // Actions cell
        const actionsCell = document.createElement('td');
        const actionsDiv = document.createElement('div');
        actionsDiv.style.display = 'flex';
        actionsDiv.style.gap = '0.5rem';
        actionsDiv.style.justifyContent = 'center';
        
        const editBtn = document.createElement('button');
        editBtn.className = 'small-btn';
        editBtn.innerHTML = '<span class="btn-icon"></span>Edit';
        editBtn.onclick = () => editPOIType(type.id);
        actionsDiv.appendChild(editBtn);
        
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'small-btn danger-btn';
        deleteBtn.innerHTML = '<span class="btn-icon"></span>Delete';
        deleteBtn.onclick = () => deletePOIType(type.id);
        actionsDiv.appendChild(deleteBtn);
        
        actionsCell.appendChild(actionsDiv);
        row.appendChild(actionsCell);
        
        tbody.appendChild(row);
      });
      
      // Update pagination info
      const paginationInfo = document.getElementById('poi-types-pagination-info');
      paginationInfo.textContent = `Showing ${startIndex + 1}-${endIndex} of ${poiTypes.length} types`;
      
      // Update pagination controls
      const paginationDiv = document.getElementById('poi-types-pagination');
      if (totalPages > 1) {
        paginationDiv.style.display = 'block';
        paginationDiv.innerHTML = '';
        
        // First page button
        const firstBtn = document.createElement('button');
        firstBtn.className = 'pagination-btn';
        firstBtn.innerHTML = '';
        firstBtn.title = 'First page';
        firstBtn.disabled = currentPOITypePage === 0;
        firstBtn.onclick = () => {
          currentPOITypePage = 0;
          displayPOITypes();
        };
        paginationDiv.appendChild(firstBtn);
        
        // Previous page button
        const prevBtn = document.createElement('button');
        prevBtn.className = 'pagination-btn';
        prevBtn.innerHTML = '';
        prevBtn.title = 'Previous page';
        prevBtn.disabled = currentPOITypePage === 0;
        prevBtn.onclick = () => {
          currentPOITypePage--;
          displayPOITypes();
        };
        paginationDiv.appendChild(prevBtn);
        
        // Page numbers
        const maxVisible = 5;
        let startPage = Math.max(0, currentPOITypePage - Math.floor(maxVisible / 2));
        let endPage = Math.min(totalPages - 1, startPage + maxVisible - 1);
        
        if (endPage - startPage < maxVisible - 1) {
          startPage = Math.max(0, endPage - maxVisible + 1);
        }
        
        if (startPage > 0) {
          const pageBtn = document.createElement('button');
          pageBtn.className = 'pagination-btn';
          pageBtn.textContent = '1';
          pageBtn.onclick = () => {
            currentPOITypePage = 0;
            displayPOITypes();
          };
          paginationDiv.appendChild(pageBtn);
          
          if (startPage > 1) {
            const ellipsis = document.createElement('span');
            ellipsis.style.padding = '0 0.5rem';
            ellipsis.style.color = '#666';
            ellipsis.textContent = '...';
            paginationDiv.appendChild(ellipsis);
          }
        }
        
        for (let i = startPage; i <= endPage; i++) {
          const pageBtn = document.createElement('button');
          pageBtn.className = 'pagination-btn';
          if (i === currentPOITypePage) {
            pageBtn.className += ' active';
          }
          pageBtn.textContent = i + 1;
          pageBtn.onclick = () => {
            currentPOITypePage = i;
            displayPOITypes();
          };
          paginationDiv.appendChild(pageBtn);
        }
        
        if (endPage < totalPages - 1) {
          if (endPage < totalPages - 2) {
            const ellipsis = document.createElement('span');
            ellipsis.style.padding = '0 0.5rem';
            ellipsis.style.color = '#666';
            ellipsis.textContent = '...';
            paginationDiv.appendChild(ellipsis);
          }
          
          const pageBtn = document.createElement('button');
          pageBtn.className = 'pagination-btn';
          pageBtn.textContent = totalPages;
          pageBtn.onclick = () => {
            currentPOITypePage = totalPages - 1;
            displayPOITypes();
          };
          paginationDiv.appendChild(pageBtn);
        }
        
        // Next page button
        const nextBtn = document.createElement('button');
        nextBtn.className = 'pagination-btn';
        nextBtn.innerHTML = '';
        nextBtn.title = 'Next page';
        nextBtn.disabled = currentPOITypePage === totalPages - 1;
        nextBtn.onclick = () => {
          currentPOITypePage++;
          displayPOITypes();
        };
        paginationDiv.appendChild(nextBtn);
        
        // Last page button
        const lastBtn = document.createElement('button');
        lastBtn.className = 'pagination-btn';
        lastBtn.innerHTML = '';
        lastBtn.title = 'Last page';
        lastBtn.disabled = currentPOITypePage === totalPages - 1;
        lastBtn.onclick = () => {
          currentPOITypePage = totalPages - 1;
          displayPOITypes();
        };
        paginationDiv.appendChild(lastBtn);
      } else {
        paginationDiv.style.display = 'none';
      }
    }
    
    function showAddPOITypeModal() {
      editingPOIType = null;
      document.getElementById('poi-type-modal-title').textContent = 'Add POI Type';
      document.getElementById('poi-type-form').reset();
      document.getElementById('emoji-input-group').style.display = 'block';
      document.getElementById('iconify-input-group').style.display = 'none';
      document.getElementById('upload-input-group').style.display = 'none';
      document.getElementById('icon-preview').innerHTML = '';
      document.getElementById('selected-iconify-preview').innerHTML = '<span style="color: #666;">?</span>';
      document.getElementById('poi-type-modal').style.display = 'flex';
      
      // Populate emoji picker with default category
      populateEmojiPicker('harvest');
    }
    
    function editPOIType(id) {
      const type = poiTypes.find(t => t.id === id);
      if (!type) return;
      
      editingPOIType = type;
      document.getElementById('poi-type-modal-title').textContent = 'Edit POI Type';
      document.getElementById('poi-type-name').value = type.name;
      
      // Set icon type
      document.querySelector(`input[name="icon-type"][value="${type.icon_type}"]`).checked = true;
      updateIconTypeDisplay();
      
      // Set icon value
      if (type.icon_type === 'emoji') {
        document.getElementById('poi-type-emoji').value = type.icon_value;
      } else if (type.icon_type === 'iconify' || type.icon_type === 'fontawesome') {
        document.getElementById('poi-type-iconify-value').value = type.icon_value;
        document.getElementById('poi-type-iconify').value = '';
        const preview = document.getElementById('selected-iconify-preview');
        preview.innerHTML = `<iconify-icon icon="${type.icon_value}" width="24" height="24"></iconify-icon>`;
      } else if (type.icon_type === 'upload') {
        const preview = document.getElementById('icon-preview');
        preview.innerHTML = `<img src="${type.icon_value}" style="width: 64px; height: 64px; object-fit: contain;">`;
      }
      
      // Set multi-mob checkbox
      document.getElementById('poi-type-multi-mob').checked = type.multi_mob || false;
      
      document.getElementById('poi-type-modal').style.display = 'flex';
    }
    
    async function savePOIType(event) {
      event.preventDefault();
      
      const name = document.getElementById('poi-type-name').value.trim();
      const iconType = document.querySelector('input[name="icon-type"]:checked').value;
      let iconValue = '';
      
      // Get icon value based on type
      if (iconType === 'emoji') {
        iconValue = document.getElementById('poi-type-emoji').value.trim();
        if (!iconValue) {
          showMessage('Please enter an emoji', 'error');
          return;
        }
      } else if (iconType === 'iconify') {
        iconValue = document.getElementById('poi-type-iconify-value').value.trim();
        if (!iconValue) {
          showMessage('Please select an icon from the library', 'error');
          return;
        }
      } else if (iconType === 'upload') {
        const fileInput = document.getElementById('poi-type-upload');
        if (!editingPOIType && !fileInput.files[0]) {
          showMessage('Please select an image', 'error');
          return;
        }
      }
      
      try {
        if (iconType === 'upload' && document.getElementById('poi-type-upload').files[0]) {
          // Upload image first
          const formData = new FormData();
          formData.append('icon', document.getElementById('poi-type-upload').files[0]);
          
          const uploadResponse = await window.csrfHelper.fetchWithCSRF('/api/poi-types/upload-icon', {
            method: 'POST',
            body: formData
          });
          
          if (!uploadResponse.ok) {
            throw new Error('Failed to upload icon');
          }
          
          const uploadData = await uploadResponse.json();
          iconValue = uploadData.iconUrl;
        } else if (iconType === 'upload' && editingPOIType) {
          // Keep existing upload value
          iconValue = editingPOIType.icon_value;
        }
        
        const body = {
          name,
          icon_type: iconType,
          icon_value: iconValue,
          multi_mob: document.getElementById('poi-type-multi-mob').checked
        };
        
        const url = editingPOIType 
          ? `/api/poi-types/${editingPOIType.id}`
          : '/api/poi-types';
          
        const method = editingPOIType ? 'PUT' : 'POST';
        
        const response = await window.csrfHelper.fetchWithCSRF(url, {
          method,
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
        
        if (response.ok) {
          showMessage(`POI type ${editingPOIType ? 'updated' : 'created'} successfully. Refresh the map to see icon changes on existing POIs.`, 'success');
          closePOITypeModal();
          loadPOITypes();
          
          // If POI editor is loaded, refresh it to show updated icons
          if (document.getElementById('poi-editor-content').style.display !== 'none') {
            loadPOIEditor();
          }
        } else {
          const error = await response.json();
          showMessage(error.error || 'Failed to save POI type', 'error');
        }
      } catch (error) {
        showMessage('Failed to save POI type', 'error');
      }
    }
    
    async function deletePOIType(id) {
      const type = poiTypes.find(t => t.id === id);
      if (!type) return;
      
      if (!confirm(`Are you sure you want to delete the POI type "${type.name}"? This cannot be undone.`)) {
        return;
      }
      
      try {
        const response = await window.csrfHelper.fetchWithCSRF(`/api/poi-types/${id}`, {
          method: 'DELETE'
        });
        
        if (response.ok) {
          showMessage('POI type deleted successfully', 'success');
          loadPOITypes();
        } else {
          const error = await response.json();
          showMessage(error.error || 'Failed to delete POI type', 'error');
        }
      } catch (error) {
        showMessage('Failed to delete POI type', 'error');
      }
    }
    
    async function movePOIType(id, direction) {
      const currentIndex = poiTypes.findIndex(t => t.id === id);
      const newIndex = currentIndex + direction;
      
      if (newIndex < 0 || newIndex >= poiTypes.length) return;
      
      // Create a copy of the array and swap positions
      const reorderedTypes = [...poiTypes];
      [reorderedTypes[currentIndex], reorderedTypes[newIndex]] = 
        [reorderedTypes[newIndex], reorderedTypes[currentIndex]];
      
      // Update display_order for all types based on their new positions
      const orderData = reorderedTypes.map((type, index) => ({
        id: type.id,
        display_order: index
      }));
      
      try {
        const response = await window.csrfHelper.fetchWithCSRF('/api/poi-types/reorder', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ order: orderData })
        });
        
        if (response.ok) {
          loadPOITypes();
          showMessage('POI type reordered successfully', 'success');
        } else {
          showMessage('Failed to reorder POI type', 'error');
        }
      } catch (error) {
        showMessage('Failed to reorder POI type', 'error');
      }
    }
    
    function closePOITypeModal() {
      document.getElementById('poi-type-modal').style.display = 'none';
      editingPOIType = null;
      document.getElementById('poi-type-form').reset();
      document.getElementById('icon-preview').innerHTML = '';
      document.getElementById('emoji-picker').style.display = 'none';
    }
    
    function updateIconTypeDisplay() {
      const iconType = document.querySelector('input[name="icon-type"]:checked').value;
      
      document.getElementById('emoji-input-group').style.display = iconType === 'emoji' ? 'block' : 'none';
      document.getElementById('iconify-input-group').style.display = iconType === 'iconify' ? 'block' : 'none';
      document.getElementById('upload-input-group').style.display = iconType === 'upload' ? 'block' : 'none';
      
      // Reset file input when switching away from upload
      if (iconType !== 'upload') {
        document.getElementById('poi-type-upload').value = '';
        document.getElementById('icon-preview').innerHTML = '';
      }
      
      // Reset iconify when switching away
      if (iconType !== 'iconify') {
        document.getElementById('poi-type-iconify').value = '';
        document.getElementById('poi-type-iconify-value').value = '';
        document.getElementById('selected-iconify-preview').innerHTML = '<span style="color: #666;">?</span>';
      }
    }
    
    function togglePOITypeEmojiPicker() {
      const picker = document.getElementById('emoji-picker');
      if (!picker) {
        console.error('Emoji picker element not found');
        return;
      }
      
      picker.style.display = picker.style.display === 'none' ? 'block' : 'none';
      
      if (picker.style.display === 'block') {
        populateEmojiPicker(currentEmojiCategory);
      }
    }
    
    function selectEmojiCategory(category) {
      currentEmojiCategory = category;
      
      // Update active button
      document.querySelectorAll('.emoji-category-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      event.target.classList.add('active');
      
      populateEmojiPicker(category);
    }
    
    function populateEmojiPicker(category) {
      const grid = document.getElementById('emoji-grid');
      if (!grid) {
        console.error('Emoji grid element not found');
        return;
      }
      grid.innerHTML = '';
      
      const emojis = emojiCategories[category] || [];
      emojis.forEach(emoji => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.style.fontSize = '1.75rem';
        btn.style.padding = '0.5rem';
        btn.style.border = '1px solid transparent';
        btn.style.background = '#2d2d2d';
        btn.style.cursor = 'pointer';
        btn.style.borderRadius = '6px';
        btn.style.minWidth = '45px';
        btn.style.minHeight = '45px';
        btn.style.display = 'flex';
        btn.style.alignItems = 'center';
        btn.style.justifyContent = 'center';
        btn.style.transition = 'all 0.2s ease';
        btn.textContent = emoji;
        
        btn.onmouseover = () => {
          btn.style.background = '#3d3d3d';
          btn.style.border = '1px solid #FFD700';
          btn.style.transform = 'scale(1.1)';
        };
        
        btn.onmouseout = () => {
          btn.style.background = '#2d2d2d';
          btn.style.border = '1px solid transparent';
          btn.style.transform = 'scale(1)';
        };
        
        btn.onclick = () => {
          document.getElementById('poi-type-emoji').value = emoji;
          document.getElementById('emoji-picker').style.display = 'none';
        };
        
        grid.appendChild(btn);
      });
    }
    
    // Handle file upload preview
    document.getElementById('poi-type-upload').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
          document.getElementById('icon-preview').innerHTML = 
            `<img src="${e.target.result}" style="width: 64px; height: 64px; object-fit: contain;">`;
        };
        reader.readAsDataURL(file);
      }
    });
    
    // Iconify functions
    let iconifySearchTimeout;
    let currentIconSet = null;
    
    // Wait for Iconify to be loaded
    window.addEventListener('DOMContentLoaded', () => {
      // Force Iconify to scan for icons after DOM is ready
      if (window.Iconify) {
        window.Iconify.scan();
      }
    });
    
    // Popular RPG-related icon searches
    const rpgIconSearches = {
      'game-icons': ['sword', 'shield', 'potion', 'treasure', 'castle', 'dragon', 'tavern', 'spell', 'armor', 'bow', 'axe', 'helmet', 'chest', 'crown', 'gem', 'scroll', 'dagger', 'mace', 'staff', 'wand', 'arrow', 'quiver', 'book', 'tome', 'crystal', 'orb', 'ring', 'amulet', 'coin', 'bag', 'merchant', 'shop', 'inn', 'temple', 'church', 'tower', 'dungeon', 'cave', 'forest', 'mountain', 'village', 'camp', 'fire', 'torch', 'lantern', 'key', 'lock', 'door', 'gate', 'bridge', 'altar', 'throne', 'banner', 'flag', 'emblem', 'crest',
        // Monsters
        'goblin', 'orc', 'troll', 'giant', 'skeleton', 'zombie', 'vampire', 'werewolf', 'demon', 'angel', 'dragon', 'wyvern', 'drake', 'hydra', 'basilisk', 'griffin', 'phoenix', 'unicorn', 'centaur', 'minotaur', 'harpy', 'siren', 'medusa', 'cyclops', 'ogre', 'imp', 'devil', 'lich', 'wraith', 'ghost', 'banshee', 'specter', 'phantom', 'gargoyle', 'golem', 'elemental', 'spider', 'rat', 'bat', 'snake', 'scorpion', 'beetle', 'wolf', 'bear', 'boar', 'lion', 'tiger', 'panther', 'eagle', 'hawk', 'raven', 'owl', 'crocodile', 'lizard', 'dinosaur', 'tentacle', 'kraken', 'leviathan', 'behemoth', 'chimera', 'manticore', 'sphinx', 'cerberus', 'hellhound', 'dire', 'swarm', 'slime', 'ooze', 'blob', 'fungus', 'plant', 'treant', 'dryad', 'fairy', 'pixie', 'sprite', 'wisp', 'shade', 'shadow', 'nightmare', 'fiend', 'aberration', 'monstrosity', 'beast', 'undead', 'construct', 'fey', 'celestial', 'infernal', 'abyssal',
        // Classes & Professions
        'wizard', 'knight', 'rogue', 'archer', 'cleric', 'paladin', 'barbarian', 'monk', 'druid', 'ranger', 'bard', 'necromancer', 'sorcerer', 'warlock', 'witch', 'shaman', 'priest', 'templar', 'crusader', 'inquisitor', 'assassin', 'thief', 'scout', 'hunter', 'tracker', 'berserker', 'warrior', 'fighter', 'gladiator', 'champion', 'hero', 'adventurer', 'mercenary', 'soldier', 'guard', 'captain', 'general', 'king', 'queen', 'prince', 'princess', 'noble', 'lord', 'lady', 'duke', 'duchess', 'baron', 'count', 'emperor', 'empress', 'merchant', 'blacksmith', 'alchemist', 'enchanter', 'artificer', 'scholar', 'sage', 'mage', 'battlemage', 'spellsword', 'bladedancer', 'shadowdancer', 'arcane', 'divine', 'nature', 'elemental', 'summoner', 'conjurer', 'illusionist', 'diviner', 'transmuter', 'abjurer', 'evoker',
        // Harvesting & Crafting
        'pickaxe', 'mining', 'ore', 'stone', 'coal', 'iron', 'gold', 'silver', 'copper', 'fishing', 'fish', 'rod', 'net', 'hook', 'bait', 'wood', 'log', 'lumber', 'tree', 'forest', 'axe', 'saw', 'harvest', 'farm', 'crop', 'wheat', 'corn', 'herb', 'plant', 'flower', 'mushroom', 'berry', 'fruit', 'vegetable', 'basket', 'sack', 'barrel', 'crate', 'shovel', 'hoe', 'scythe', 'rake', 'anvil', 'hammer', 'tongs', 'forge', 'smelting', 'crafting'],
      'mdi': ['sword', 'shield', 'castle', 'treasure', 'map', 'compass', 'flag', 'star', 'heart', 'diamond', 'crown', 'key', 'lock', 'book', 'flask', 'fire'],
      'tabler': ['sword', 'shield', 'home', 'flag', 'star', 'map', 'location', 'building', 'trophy', 'flame', 'book', 'key'],
      'ri': ['sword', 'shield', 'treasure', 'map', 'compass', 'flag', 'building', 'home', 'star', 'book', 'key', 'fire'],
      'heroicons': ['shield', 'flag', 'star', 'home', 'map', 'location-marker', 'sparkles', 'fire', 'book-open', 'key'],
      'lucide': ['sword', 'shield', 'castle', 'crown', 'gem', 'map', 'compass', 'flag', 'star', 'home', 'flame', 'book', 'key', 'scroll', 'wand']
    };
    
    async function searchIconifyIcons(query) {
      clearTimeout(iconifySearchTimeout);
      
      if (query.length < 2) {
        document.getElementById('iconify-picker').style.display = 'none';
        return;
      }
      
      iconifySearchTimeout = setTimeout(async () => {
        const resultsContainer = document.getElementById('iconify-search-results');
        resultsContainer.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 2rem;">Searching...</div>';
        document.getElementById('iconify-picker').style.display = 'block';
        
        try {
          // Search across multiple icon sets
          const iconSets = ['mdi', 'tabler', 'game-icons', 'ri', 'heroicons', 'lucide', 'material-symbols'];
          const results = [];
          
          // Use Iconify's search API
          const response = await fetch(`https://api.iconify.design/search?query=${encodeURIComponent(query)}&limit=48`);
          const data = await response.json();
          
          if (data.icons && data.icons.length > 0) {
            resultsContainer.innerHTML = '';
            for (const iconName of data.icons) {
              const iconItem = await createIconifyIconItem(iconName);
              resultsContainer.appendChild(iconItem);
            }
          } else {
            // Fallback: search in specific sets
            resultsContainer.innerHTML = '';
            let foundIcons = false;
            
            for (const set of iconSets) {
              try {
                const setResponse = await fetch(`https://api.iconify.design/collection?prefix=${set}`);
                const setData = await setResponse.json();
                
                if (setData.uncategorized) {
                  const matchingIcons = setData.uncategorized.filter(icon => 
                    icon.toLowerCase().includes(query.toLowerCase())
                  );
                  
                  for (const iconName of matchingIcons.slice(0, 8)) {
                    const fullIconName = `${set}:${iconName}`;
                    const iconItem = await createIconifyIconItem(fullIconName);
                    resultsContainer.appendChild(iconItem);
                    foundIcons = true;
                  }
                }
              } catch (err) {
              }
            }
            
            if (!foundIcons) {
              resultsContainer.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 2rem; color: #999;">No icons found. Try browsing icon sets below.</div>';
            }
          }
        } catch (error) {
          console.error('Icon search error:', error);
          resultsContainer.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 2rem; color: #dc3545;">Search failed. Try browsing icon sets.</div>';
        }
      }, 300);
    }
    
    async function loadIconifySet(setName) {
      const resultsContainer = document.getElementById('iconify-search-results');
      resultsContainer.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 2rem;">Loading icons...</div>';
      document.getElementById('iconify-picker').style.display = 'block';
      
      // Update active button
      document.querySelectorAll('.icon-set-btn').forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');
      
      currentIconSet = setName;
      
      try {
        // Get RPG-related icons for this set
        const iconSearchTerms = rpgIconSearches[setName] || ['icon'];
        const allIcons = [];
        
        // Fetch collection info
        const response = await fetch(`https://api.iconify.design/collection?prefix=${setName}`);
        const data = await response.json();
        
        if (data.uncategorized) {
          // Filter icons based on RPG-related terms
          const rpgIcons = data.uncategorized.filter(iconName => {
            const lowerName = iconName.toLowerCase();
            return iconSearchTerms.some(term => lowerName.includes(term)) ||
                   lowerName.includes('game') || lowerName.includes('rpg') || 
                   lowerName.includes('quest') || lowerName.includes('adventure');
          });
          
          // If we found RPG icons, use them; otherwise show first 48 icons
          const iconsToShow = rpgIcons.length > 0 ? rpgIcons.slice(0, 48) : data.uncategorized.slice(0, 48);
          
          resultsContainer.innerHTML = '';
          for (const iconName of iconsToShow) {
            const fullIconName = `${setName}:${iconName}`;
            const iconItem = await createIconifyIconItem(fullIconName);
            resultsContainer.appendChild(iconItem);
          }
        }
      } catch (error) {
        console.error('Failed to load icon set:', error);
        resultsContainer.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: 2rem; color: #dc3545;">Failed to load icons</div>';
      }
    }
    
    async function createIconifyIconItem(iconName) {
      const button = document.createElement('button');
      button.type = 'button';
      button.className = 'iconify-icon-item';
      button.setAttribute('data-icon', iconName);
      button.onclick = () => selectIconifyIcon(iconName);
      
      // Create a loading placeholder
      button.innerHTML = '<span style="color: #666;">...</span>';
      
      // Try to load the SVG directly - keep original colors
      try {
        const response = await fetch(`https://api.iconify.design/${iconName}.svg?width=24&height=24`);
        if (response.ok) {
          const svg = await response.text();
          button.innerHTML = svg;
        } else {
          // Fallback to web component
          button.innerHTML = `<iconify-icon icon="${iconName}" width="24" height="24"></iconify-icon>`;
        }
      } catch (error) {
        // Fallback to web component
        button.innerHTML = `<iconify-icon icon="${iconName}" width="24" height="24"></iconify-icon>`;
      }
      
      return button;
    }
    
    function selectIconifyIcon(iconName) {
      // Update hidden input
      document.getElementById('poi-type-iconify-value').value = iconName;
      
      // Update preview
      const preview = document.getElementById('selected-iconify-preview');
      preview.innerHTML = `<iconify-icon icon="${iconName}" width="24" height="24"></iconify-icon>`;
      
      // Highlight selected icon
      document.querySelectorAll('.iconify-icon-item').forEach(item => {
        item.classList.remove('selected');
      });
      event.target.closest('.iconify-icon-item').classList.add('selected');
      
      // Clear search
      document.getElementById('poi-type-iconify').value = '';
      
      // Hide picker after short delay
      setTimeout(() => {
        document.getElementById('iconify-picker').style.display = 'none';
      }, 200);
    }

    // POI Editor Functions
    let allPOIs = [];
    let filteredPOIs = [];
    let poiChanges = new Map(); // Map of poi.id -> changes object
    let currentPOIEditorPage = 0;
    const POI_EDITOR_PER_PAGE = 10;
    let maps = [];
    
    // Make POI Editor table columns resizable
    function makeColumnsResizable() {
      const table = document.querySelector('.poi-editor-table');
      if (!table) return;
      
      const headers = table.querySelectorAll('thead th');
      headers.forEach((header, index) => {
        // Don't add resizer to the last column (Delete)
        if (index === headers.length - 1) return;
        
        // Remove existing resizer if any
        const existingResizer = header.querySelector('.column-resizer');
        if (existingResizer) {
          existingResizer.remove();
        }
        
        // Create resizer element
        const resizer = document.createElement('div');
        resizer.className = 'column-resizer';
        header.appendChild(resizer);
        
        let startX = 0;
        let startWidth = 0;
        let isResizing = false;
        
        resizer.addEventListener('mousedown', (e) => {
          isResizing = true;
          startX = e.pageX;
          startWidth = header.offsetWidth;
          resizer.classList.add('resizing');
          header.classList.add('resizing');
          document.body.style.cursor = 'col-resize';
          e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
          if (!isResizing) return;
          
          const diff = e.pageX - startX;
          const newWidth = Math.max(50, startWidth + diff); // Minimum width of 50px
          header.style.width = newWidth + 'px';
        });
        
        document.addEventListener('mouseup', () => {
          if (isResizing) {
            isResizing = false;
            resizer.classList.remove('resizing');
            header.classList.remove('resizing');
            document.body.style.cursor = '';
            
            // Save column widths to localStorage
            saveColumnWidths();
          }
        });
      });
      
      // Restore saved column widths
      restoreColumnWidths();
    }
    
    // Save column widths to localStorage
    function saveColumnWidths() {
      const table = document.querySelector('.poi-editor-table');
      if (!table) return;
      
      const headers = table.querySelectorAll('thead th');
      const widths = Array.from(headers).map(header => header.style.width || header.offsetWidth + 'px');
      localStorage.setItem('poiEditorColumnWidths', JSON.stringify(widths));
    }
    
    // Restore column widths from localStorage
    function restoreColumnWidths() {
      const table = document.querySelector('.poi-editor-table');
      if (!table) return;
      
      const savedWidths = localStorage.getItem('poiEditorColumnWidths');
      if (!savedWidths) return;
      
      try {
        const widths = JSON.parse(savedWidths);
        const headers = table.querySelectorAll('thead th');
        headers.forEach((header, index) => {
          if (widths[index]) {
            header.style.width = widths[index];
          }
        });
      } catch (e) {
        console.error('Error restoring column widths:', e);
      }
    }
    
    async function loadPOIEditor() {
      const loading = document.getElementById('poi-editor-loading');
      const content = document.getElementById('poi-editor-content');
      
      try {
        // Load maps first
        const mapsResponse = await fetch('/api/maps');
        if (mapsResponse.ok) {
          maps = await mapsResponse.json();
          populateMapFilter();
        }
        
        // Load all POIs
        const response = await fetch('/api/pois/all');
        if (response.ok) {
          allPOIs = await response.json();
          filterPOIsByMap();
          loading.style.display = 'none';
          content.style.display = 'block';
          updateStats();
        } else {
          const error = await response.json();
          loading.innerHTML = `<p style="color: #dc3545;">Failed to load POIs: ${error.error || 'Unknown error'}</p>`;
        }
      } catch (error) {
        console.error('Error loading POIs:', error);
        loading.innerHTML = '<p style="color: #dc3545;">Failed to load POIs</p>';
      }
    }
    
    function populateMapFilter() {
      const select = document.getElementById('poi-map-filter');
      select.innerHTML = '<option value="all">All Maps</option>';
      
      maps.forEach(map => {
        const option = document.createElement('option');
        option.value = map.id;
        option.textContent = map.name;
        select.appendChild(option);
      });
    }
    
    function filterPOIsByMap() {
      // Check for unsaved changes before filtering
      if (poiChanges.size > 0) {
        if (!confirm('You have unsaved changes. Are you sure you want to change the map filter? Your changes will be lost.')) {
          // Reset the select to the previous value
          // Note: This is a simple approach, a more robust solution would track the previous value
          return;
        }
        // Clear changes if user confirms
        poiChanges.clear();
        updateChangeButtons();
      }
      
      const mapId = document.getElementById('poi-map-filter').value;
      
      if (mapId === 'all') {
        filteredPOIs = [...allPOIs];
      } else {
        filteredPOIs = allPOIs.filter(poi => poi.map_id === parseInt(mapId));
      }
      
      currentPOIEditorPage = 0;
      applySearchFilter();
      updateStats();
    }
    
    function displayPOIEditor() {
      const tbody = document.getElementById('poi-editor-tbody');
      tbody.innerHTML = '';
      
      if (filteredPOIs.length === 0) {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td colspan="11" style="text-align: center; color: #666; padding: 2rem;">
            No POIs found for the selected filter.
          </td>
        `;
        tbody.appendChild(row);
        return;
      }
      
      // Calculate pagination
      const totalPages = Math.ceil(filteredPOIs.length / POI_EDITOR_PER_PAGE);
      const startIndex = currentPOIEditorPage * POI_EDITOR_PER_PAGE;
      const endIndex = Math.min(startIndex + POI_EDITOR_PER_PAGE, filteredPOIs.length);
      const paginatedPOIs = filteredPOIs.slice(startIndex, endIndex);
      
      paginatedPOIs.forEach(poi => {
        const row = createPOIEditorRow(poi);
        
        // Highlight if this is the POI we're looking for
        if (window.poiEditorHighlightId && poi.id == window.poiEditorHighlightId) {
          row.classList.add('highlighted-poi');
          // Store the highlighted POI ID permanently
          window.permanentHighlightId = poi.id;
          // Scroll into view after a short delay
          setTimeout(() => {
            row.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }, 500);
        }
        
        // Re-apply highlight if it matches the permanent highlight
        if (window.permanentHighlightId && poi.id == window.permanentHighlightId) {
          row.classList.add('highlighted-poi');
        }
        
        tbody.appendChild(row);
      });
      
      // Update pagination info
      const paginationInfo = document.getElementById('poi-editor-pagination-info');
      paginationInfo.textContent = `Showing ${startIndex + 1}-${endIndex} of ${filteredPOIs.length} POIs`;
      
      // Update pagination controls
      updatePOIEditorPagination(totalPages);
      
      // Make columns resizable after table is populated
      makeColumnsResizable();
    }
    
    function createPOIEditorRow(poi) {
      const row = document.createElement('tr');
      row.dataset.poiId = poi.id;
      
      // ID cell (read-only)
      const idCell = document.createElement('td');
      idCell.textContent = poi.id;
      idCell.style.color = '#666';
      idCell.style.textAlign = 'center';
      row.appendChild(idCell);
      
      // Name cell
      const nameCell = document.createElement('td');
      const nameInput = document.createElement('input');
      nameInput.type = 'text';
      nameInput.value = poi.name || '';
      nameInput.dataset.field = 'name';
      nameInput.dataset.original = poi.name || '';
      nameInput.placeholder = 'POI Name';
      nameInput.onkeypress = (e) => handleCellKeypress(e, poi.id);
      nameInput.onblur = () => stagePOIChange(poi.id, 'name', nameInput.value);
      nameCell.appendChild(nameInput);
      row.appendChild(nameCell);
      
      // Description cell
      const descCell = document.createElement('td');
      const descTextarea = document.createElement('textarea');
      descTextarea.value = poi.description || '';
      descTextarea.dataset.field = 'description';
      descTextarea.dataset.original = poi.description || '';
      descTextarea.placeholder = 'Description (optional)';
      descTextarea.rows = 2;
      descTextarea.onkeypress = (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          stagePOIChange(poi.id, 'description', descTextarea.value);
          descTextarea.blur();
        }
      };
      descTextarea.onblur = () => stagePOIChange(poi.id, 'description', descTextarea.value);
      descCell.appendChild(descTextarea);
      row.appendChild(descCell);
      
      // Type cell (dropdown)
      const typeCell = document.createElement('td');
      const typeSelect = createPOITypeSelect(poi);
      typeCell.appendChild(typeSelect);
      row.appendChild(typeCell);
      
      // Icon cell (display only, updates with type)
      const iconCell = document.createElement('td');
      iconCell.style.textAlign = 'center';
      iconCell.className = 'poi-type-icon';
      iconCell.innerHTML = renderPOIIcon(poi);
      row.appendChild(iconCell);
      
      // Icon size
      const iconSizeCell = document.createElement('td');
      const iconSizeInput = document.createElement('input');
      iconSizeInput.type = 'number';
      iconSizeInput.value = poi.icon_size || 34;
      iconSizeInput.dataset.field = 'icon_size';
      iconSizeInput.dataset.original = poi.icon_size || 34;
      iconSizeInput.min = '10';
      iconSizeInput.max = '100';
      iconSizeInput.step = '1';
      iconSizeInput.style.width = '100%';
      iconSizeInput.onkeypress = (e) => handleCellKeypress(e, poi.id);
      iconSizeInput.onblur = () => stagePOIChange(poi.id, 'icon_size', parseInt(iconSizeInput.value));
      iconSizeCell.appendChild(iconSizeInput);
      row.appendChild(iconSizeCell);
      
      // NPC ID cell
      const npcIdCell = document.createElement('td');
      const npcIdContainer = document.createElement('div');
      npcIdContainer.style.cssText = 'display: flex; align-items: center; gap: 4px;';
      
      const npcIdInput = document.createElement('input');
      npcIdInput.type = 'text';
      npcIdInput.value = poi.npc_id ? `NPC ID: ${poi.npc_id}` : '';
      npcIdInput.dataset.field = 'npc_id';
      npcIdInput.dataset.original = poi.npc_id || '';
      npcIdInput.dataset.npcId = poi.npc_id || '';
      npcIdInput.placeholder = 'Select NPC';
      npcIdInput.style.cssText = 'flex: 1; min-width: 0;';
      npcIdInput.readOnly = true;
      
      const npcSelectBtn = document.createElement('button');
      npcSelectBtn.innerHTML = '';
      npcSelectBtn.title = 'Select NPC';
      npcSelectBtn.style.cssText = 'padding: 2px 6px; font-size: 0.9rem; cursor: pointer; background: #3a3a3a; border: 1px solid #555; border-radius: 3px; color: #e0e0e0; transition: all 0.2s;';
      npcSelectBtn.onmouseover = () => { npcSelectBtn.style.background = '#4a4a4a'; npcSelectBtn.style.borderColor = '#666'; };
      npcSelectBtn.onmouseout = () => { npcSelectBtn.style.background = '#3a3a3a'; npcSelectBtn.style.borderColor = '#555'; };
      npcSelectBtn.onclick = () => openNPCSelector(poi.id, row);
      
      const npcClearBtn = document.createElement('button');
      npcClearBtn.innerHTML = '';
      npcClearBtn.title = 'Clear NPC';
      npcClearBtn.style.cssText = 'padding: 2px 6px; font-size: 0.8rem; cursor: pointer; background: #3a3a3a; border: 1px solid #555; border-radius: 3px; color: #e0e0e0; transition: all 0.2s;';
      npcClearBtn.onmouseover = () => { npcClearBtn.style.background = '#5a3a3a'; npcClearBtn.style.borderColor = '#666'; };
      npcClearBtn.onmouseout = () => { npcClearBtn.style.background = '#3a3a3a'; npcClearBtn.style.borderColor = '#555'; };
      npcClearBtn.onclick = () => {
        npcIdInput.value = '';
        npcIdInput.dataset.npcId = '';
        stagePOIChange(poi.id, 'npc_id', null);
      };
      
      npcIdContainer.appendChild(npcIdInput);
      npcIdContainer.appendChild(npcSelectBtn);
      if (poi.npc_id) {
        npcIdContainer.appendChild(npcClearBtn);
      }
      npcIdCell.appendChild(npcIdContainer);
      row.appendChild(npcIdCell);
      
      // Item ID cell
      const itemIdCell = document.createElement('td');
      const itemIdContainer = document.createElement('div');
      itemIdContainer.style.cssText = 'display: flex; align-items: center; gap: 4px;';
      
      const itemIdInput = document.createElement('input');
      itemIdInput.type = 'text';
      itemIdInput.value = poi.item_id ? `Item ID: ${poi.item_id}` : '';
      itemIdInput.dataset.field = 'item_id';
      itemIdInput.dataset.original = poi.item_id || '';
      itemIdInput.dataset.itemId = poi.item_id || '';
      itemIdInput.placeholder = 'Select Item';
      itemIdInput.style.cssText = 'flex: 1; min-width: 0;';
      itemIdInput.readOnly = true;
      
      const itemSelectBtn = document.createElement('button');
      itemSelectBtn.innerHTML = '';
      itemSelectBtn.title = 'Select Item';
      itemSelectBtn.style.cssText = 'padding: 2px 6px; font-size: 0.9rem; cursor: pointer; background: #3a3a3a; border: 1px solid #555; border-radius: 3px; color: #e0e0e0; transition: all 0.2s;';
      itemSelectBtn.onmouseover = () => { itemSelectBtn.style.background = '#4a4a4a'; itemSelectBtn.style.borderColor = '#666'; };
      itemSelectBtn.onmouseout = () => { itemSelectBtn.style.background = '#3a3a3a'; itemSelectBtn.style.borderColor = '#555'; };
      itemSelectBtn.onclick = () => openItemSelector(poi.id, row);
      
      const itemClearBtn = document.createElement('button');
      itemClearBtn.innerHTML = '';
      itemClearBtn.title = 'Clear Item';
      itemClearBtn.style.cssText = 'padding: 2px 6px; font-size: 0.8rem; cursor: pointer; background: #3a3a3a; border: 1px solid #555; border-radius: 3px; color: #e0e0e0; transition: all 0.2s;';
      itemClearBtn.onmouseover = () => { itemClearBtn.style.background = '#5a3a3a'; itemClearBtn.style.borderColor = '#666'; };
      itemClearBtn.onmouseout = () => { itemClearBtn.style.background = '#3a3a3a'; itemClearBtn.style.borderColor = '#555'; };
      itemClearBtn.onclick = () => {
        itemIdInput.value = '';
        itemIdInput.dataset.itemId = '';
        stagePOIChange(poi.id, 'item_id', null);
      };
      
      itemIdContainer.appendChild(itemIdInput);
      itemIdContainer.appendChild(itemSelectBtn);
      if (poi.item_id) {
        itemIdContainer.appendChild(itemClearBtn);
      }
      itemIdCell.appendChild(itemIdContainer);
      row.appendChild(itemIdCell);
      
      // Created by cell (read-only)
      const createdByCell = document.createElement('td');
      createdByCell.textContent = poi.created_by_name || poi.created_by_user_id || 'System';
      createdByCell.style.color = '#999';
      createdByCell.style.fontSize = '0.85rem';
      row.appendChild(createdByCell);
      
      // Map cell (read-only)
      const mapCell = document.createElement('td');
      mapCell.textContent = poi.map_name || `Map ${poi.map_id}`;
      mapCell.style.color = '#999';
      mapCell.style.fontSize = '0.85rem';
      row.appendChild(mapCell);
      
      // Delete cell
      const deleteCell = document.createElement('td');
      deleteCell.style.textAlign = 'center';
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'delete-btn';
      deleteBtn.textContent = '';
      deleteBtn.title = 'Mark for deletion';
      deleteBtn.onclick = () => toggleDeletePOI(poi.id);
      deleteCell.appendChild(deleteBtn);
      row.appendChild(deleteCell);
      
      // Apply any existing changes
      if (poiChanges.has(poi.id)) {
        const changes = poiChanges.get(poi.id);
        
        // Check if marked for deletion
        if (changes._delete) {
          row.classList.add('marked-for-deletion');
          deleteBtn.classList.add('undo');
          deleteBtn.textContent = '';
          deleteBtn.title = 'Undo deletion';
        } else {
          // Apply other field changes
          Object.keys(changes).forEach(field => {
            if (field !== '_delete') {
              const cell = row.querySelector(`[data-field="${field}"]`);
              if (cell) {
                cell.parentElement.classList.add('cell-changed');
                cell.title = `Original: ${cell.dataset.original}`;
              }
            }
          });
        }
      }
      
      return row;
    }
    
    function createPOITypeSelect(poi) {
      // Create a custom dropdown container
      const container = document.createElement('div');
      container.className = 'custom-poi-type-select';
      container.style.position = 'relative';
      container.style.width = '100%';
      
      // Create the display element
      const display = document.createElement('div');
      display.className = 'custom-select-display';
      display.style.cssText = `
        padding: 0.35rem 2rem 0.35rem 0.5rem;
        border: 1px solid transparent;
        background: transparent;
        color: #e0e0e0;
        cursor: pointer;
        position: relative;
        min-height: 30px;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      `;
      display.dataset.field = 'type_id';
      display.dataset.original = poi.type_id;
      
      // Add dropdown arrow
      const arrow = document.createElement('span');
      arrow.style.cssText = `
        position: absolute;
        right: 0.5rem;
        top: 50%;
        transform: translateY(-50%);
        pointer-events: none;
      `;
      arrow.textContent = '';
      display.appendChild(arrow);
      
      // Create dropdown list
      const dropdown = document.createElement('div');
      dropdown.className = 'custom-select-dropdown';
      dropdown.style.cssText = `
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: #2d2d2d;
        border: 1px solid #555;
        border-radius: 4px;
        max-height: 300px;
        overflow-y: auto;
        display: none;
        z-index: 1000;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
      `;
      
      // Set initial display
      const currentType = poiTypes.find(type => type.id === poi.type_id);
      if (currentType) {
        updateSelectDisplay(display, currentType);
      } else if (poi.type_id) {
        display.innerHTML = `<span style="color: #ff6666;">Unknown Type (${poi.type_id})</span>${arrow.outerHTML}`;
        container.classList.add('invalid-type');
      }
      
      // Add all POI types to dropdown
      poiTypes.forEach(type => {
        const item = document.createElement('div');
        item.className = 'custom-select-item';
        item.style.cssText = `
          padding: 0.5rem;
          cursor: pointer;
          display: flex;
          align-items: center;
          gap: 0.5rem;
          transition: background 0.2s;
        `;
        item.dataset.value = type.id;
        
        // Add icon
        const iconSpan = document.createElement('span');
        iconSpan.style.minWidth = '24px';
        iconSpan.style.textAlign = 'center';
        
        if (type.icon_type === 'emoji') {
          iconSpan.textContent = type.icon_value;
          iconSpan.style.fontSize = '1.2rem';
        } else if (type.icon_type === 'iconify' || type.icon_type === 'fontawesome') {
          iconSpan.innerHTML = `<iconify-icon icon="${type.icon_value}" width="20" height="20"></iconify-icon>`;
        } else if (type.icon_type === 'upload' && type.icon_value) {
          iconSpan.innerHTML = `<img src="${type.icon_value}" style="width: 20px; height: 20px; object-fit: contain;">`;
        } else {
          iconSpan.textContent = '';
        }
        
        item.appendChild(iconSpan);
        item.appendChild(document.createTextNode(type.name));
        
        // Hover effect
        item.onmouseenter = () => item.style.background = 'rgba(74, 124, 89, 0.2)';
        item.onmouseleave = () => item.style.background = '';
        
        // Click handler
        item.onclick = () => {
          updateSelectDisplay(display, type);
          dropdown.style.display = 'none';
          stagePOIChange(poi.id, 'type_id', parseInt(type.id));
          updatePOIIconDisplay(poi.id, parseInt(type.id));
        };
        
        dropdown.appendChild(item);
      });
      
      // Toggle dropdown
      display.onclick = (e) => {
        e.stopPropagation();
        const isOpen = dropdown.style.display === 'block';
        // Close all other dropdowns
        document.querySelectorAll('.custom-select-dropdown').forEach(d => d.style.display = 'none');
        dropdown.style.display = isOpen ? 'none' : 'block';
      };
      
      // Close dropdown when clicking outside
      document.addEventListener('click', (e) => {
        if (!container.contains(e.target)) {
          dropdown.style.display = 'none';
        }
      });
      
      container.appendChild(display);
      container.appendChild(dropdown);
      
      return container;
    }
    
    function updateSelectDisplay(display, type) {
      // Clear current content except arrow
      const arrow = display.querySelector('span:last-child');
      display.innerHTML = '';
      
      // Add icon
      const iconSpan = document.createElement('span');
      iconSpan.style.minWidth = '24px';
      iconSpan.style.textAlign = 'center';
      
      if (type.icon_type === 'emoji') {
        iconSpan.textContent = type.icon_value;
        iconSpan.style.fontSize = '1.2rem';
      } else if (type.icon_type === 'iconify' || type.icon_type === 'fontawesome') {
        iconSpan.innerHTML = `<iconify-icon icon="${type.icon_value}" width="20" height="20"></iconify-icon>`;
      } else if (type.icon_type === 'upload' && type.icon_value) {
        iconSpan.innerHTML = `<img src="${type.icon_value}" style="width: 20px; height: 20px; object-fit: contain;">`;
      } else {
        iconSpan.textContent = '';
      }
      
      display.appendChild(iconSpan);
      display.appendChild(document.createTextNode(type.name));
      display.appendChild(arrow);
    }
    
    function renderPOIIcon(poi) {
      // First check if POI has a type_id and matching POI type
      if (poi.type_id) {
        const poiType = poiTypes.find(type => type.id === poi.type_id);
        
        if (poiType) {
          if (poiType.icon_type === 'emoji') {
            return `<span style="font-size: 1.5rem;">${poiType.icon_value}</span>`;
          } else if (poiType.icon_type === 'iconify' || poiType.icon_type === 'fontawesome') {
            return `<iconify-icon icon="${poiType.icon_value}" width="24" height="24"></iconify-icon>`;
          } else if (poiType.icon_type === 'upload' && poiType.icon_value) {
            return `<img src="${poiType.icon_value}" style="width: 24px; height: 24px; object-fit: contain;" onerror="this.style.display='none'; this.parentElement.innerHTML='';">`;
          }
        } else {
          // Type ID exists but no matching type found
          return '<span style="color: #ff6666; font-size: 1.2rem;" title="Unknown POI Type"></span>';
        }
      }
      
      // Fallback to POI's own icon if no type
      if (poi.icon) {
        // Check if it's an emoji or custom icon
        if (poi.icon.length <= 4 && !poi.icon.includes('<')) {
          return `<span style="font-size: 1.5rem;">${poi.icon}</span>`;
        } else if (poi.custom_icon) {
          // Custom icon HTML
          return poi.icon;
        }
      }
      
      // Default icon
      return '<span style="font-size: 1.5rem;"></span>';
    }
    
    function updatePOIIconDisplay(poiId, typeId) {
      const row = document.querySelector(`tr[data-poi-id="${poiId}"]`);
      if (!row) return;
      
      const iconCell = row.querySelector('.poi-type-icon');
      const poi = filteredPOIs.find(p => p.id === poiId);
      if (!poi || !iconCell) return;
      
      poi.type_id = typeId;
      iconCell.innerHTML = renderPOIIcon(poi);
    }
    
    function handleCellKeypress(e, poiId) {
      if (e.key === 'Enter') {
        e.preventDefault();
        const field = e.target.dataset.field;
        let value = e.target.value;
        
        if (field === 'x' || field === 'y') {
          value = parseFloat(value);
        }
        
        stagePOIChange(poiId, field, value);
        
        // Move to next cell on Enter
        const allInputs = Array.from(document.querySelectorAll('.poi-editor-table input:not([readonly]), .poi-editor-table textarea, .poi-editor-table select'));
        const currentIndex = allInputs.indexOf(e.target);
        if (currentIndex < allInputs.length - 1) {
          allInputs[currentIndex + 1].focus();
        } else {
          e.target.blur();
        }
      } else if (e.key === 'Tab') {
        // Let default tab behavior work, but ensure changes are staged
        setTimeout(() => {
          const field = e.target.dataset.field;
          let value = e.target.value;
          
          if (field === 'x' || field === 'y') {
            value = parseFloat(value);
          }
          
          stagePOIChange(poiId, field, value);
        }, 0);
      }
    }
    
    function stagePOIChange(poiId, field, newValue) {
      const row = document.querySelector(`tr[data-poi-id="${poiId}"]`);
      if (!row) {
        console.error(`Could not find row for POI ${poiId}`);
        return;
      }
      let cell = row.querySelector(`[data-field="${field}"]`);
      
      // For custom dropdowns, the data-field is on the display div
      if (!cell) {
        cell = row.querySelector(`.custom-select-display[data-field="${field}"]`);
      }
      
      if (!cell) {
        console.error(`Could not find cell for field ${field} in POI ${poiId}`);
        return;
      }
      
      const originalValue = cell.dataset.original;
      
      // Convert original value to appropriate type for comparison
      let originalTyped = originalValue;
      if (field === 'type_id' || field === 'icon_size' || field === 'npc_id' || field === 'item_id') {
        originalTyped = originalValue ? parseInt(originalValue) : null;
      }
      
      // Check if value actually changed
      if (newValue === originalTyped || (newValue === null && originalTyped === null) || (newValue === '' && originalTyped === '')) {
        // Remove the change if it's back to original
        if (poiChanges.has(poiId)) {
          const changes = poiChanges.get(poiId);
          delete changes[field];
          
          if (Object.keys(changes).length === 0) {
            poiChanges.delete(poiId);
          }
        }
        
        // For npc_id and item_id, the parent is the container div, then td
        let cellElement;
        if (field === 'npc_id' || field === 'item_id') {
          // Find the parent TD element more reliably
          cellElement = cell.closest('td');
        } else {
          cellElement = cell.parentElement;
        }
        
        if (cellElement) {
          cellElement.classList.remove('cell-changed');
        }
        cell.title = '';
      } else {
        // Stage the change
        if (!poiChanges.has(poiId)) {
          poiChanges.set(poiId, {});
        }
        
        poiChanges.get(poiId)[field] = newValue;
        // For npc_id and item_id, the parent is the container div, then td
        let cellElement;
        if (field === 'npc_id' || field === 'item_id') {
          // Find the parent TD element more reliably
          cellElement = cell.closest('td');
        } else {
          cellElement = cell.parentElement;
        }
        
        if (cellElement) {
          cellElement.classList.add('cell-changed');
        }
        cell.title = `Original: ${originalValue}`;
      }
      
      updateChangeButtons();
      updateStats();
    }
    
    function updateChangeButtons() {
      const hasChanges = poiChanges.size > 0;
      document.getElementById('poi-save-btn').disabled = !hasChanges;
      document.getElementById('poi-reset-btn').disabled = !hasChanges;
      
      const changeCount = poiChanges.size;
      document.getElementById('poi-change-count').textContent = changeCount;
    }
    
    async function savePOIChanges() {
      const changeCount = poiChanges.size;
      
      if (changeCount === 0) return;
      
      if (!confirm(`Save changes to ${changeCount} POI${changeCount !== 1 ? 's' : ''}?`)) {
        return;
      }
      
      // Separate updates and deletes
      const updates = [];
      const deletes = [];
      
      poiChanges.forEach((changes, poiId) => {
        if (changes._delete) {
          deletes.push(poiId);
        } else {
          updates.push({
            id: poiId,
            ...changes
          });
        }
      });
      
      try {
        let totalUpdated = 0;
        let totalDeleted = 0;
        
        // Process updates if any
        if (updates.length > 0) {
          const response = await window.csrfHelper.fetchWithCSRF('/api/pois/batch-update', {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ updates })
          });
          
          if (response.ok) {
            const result = await response.json();
            totalUpdated = result.updated;
          } else {
            const error = await response.json();
            showMessage(error.error || 'Failed to save changes', 'error');
            return;
          }
        }
        
        // Process deletes if any
        if (deletes.length > 0) {
          const deleteResponse = await window.csrfHelper.fetchWithCSRF('/api/pois/batch-delete', {
            method: 'DELETE',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ ids: deletes })
          });
          
          if (deleteResponse.ok) {
            const result = await deleteResponse.json();
            totalDeleted = result.deleted;
          } else {
            const error = await deleteResponse.json();
            showMessage(error.error || 'Failed to delete POIs', 'error');
            return;
          }
        }
        
        // Show success message
        const messages = [];
        if (totalUpdated > 0) messages.push(`${totalUpdated} POI${totalUpdated !== 1 ? 's' : ''} updated`);
        if (totalDeleted > 0) messages.push(`${totalDeleted} POI${totalDeleted !== 1 ? 's' : ''} deleted`);
        showMessage(`Successfully ${messages.join(' and ')}`, 'success');
        
        // Clear changes and reload
        poiChanges.clear();
        updateChangeButtons();
        await reloadPOIEditor();
      } catch (error) {
        console.error('Error saving POI changes:', error);
        showMessage('Failed to save changes', 'error');
      }
    }
    
    function resetPOIChanges() {
      if (poiChanges.size === 0) return;
      
      if (!confirm('Discard all unsaved changes?')) {
        return;
      }
      
      // Reset all changed cells to their original values
      poiChanges.forEach((changes, poiId) => {
        const row = document.querySelector(`tr[data-poi-id="${poiId}"]`);
        if (!row) return;
        
        Object.keys(changes).forEach(field => {
          const cell = row.querySelector(`[data-field="${field}"]`);
          if (!cell) return;
          
          const originalValue = cell.dataset.original;
          
          if (cell.tagName === 'INPUT' && cell.type === 'checkbox') {
            cell.checked = originalValue === 'true' || originalValue === true;
          } else if (cell.tagName === 'SELECT') {
            cell.value = originalValue;
          } else {
            cell.value = originalValue;
          }
          
          cell.parentElement.classList.remove('cell-changed');
          cell.title = '';
        });
      });
      
      poiChanges.clear();
      updateChangeButtons();
      showMessage('Changes discarded', 'info');
    }
    
    function toggleDeletePOI(poiId) {
      const row = document.querySelector(`tr[data-poi-id="${poiId}"]`);
      const deleteBtn = row.querySelector('.delete-btn');
      
      if (!poiChanges.has(poiId)) {
        poiChanges.set(poiId, {});
      }
      
      const changes = poiChanges.get(poiId);
      
      if (changes._delete) {
        // Undo deletion
        delete changes._delete;
        row.classList.remove('marked-for-deletion');
        deleteBtn.classList.remove('undo');
        deleteBtn.textContent = '';
        deleteBtn.title = 'Mark for deletion';
        
        // Remove all inputs from being disabled
        row.querySelectorAll('input, textarea, select, .custom-select-display').forEach(input => {
          input.style.pointerEvents = '';
          input.style.opacity = '';
        });
        
        // If no other changes, remove from change map
        if (Object.keys(changes).length === 0) {
          poiChanges.delete(poiId);
        }
      } else {
        // Mark for deletion
        changes._delete = true;
        row.classList.add('marked-for-deletion');
        deleteBtn.classList.add('undo');
        deleteBtn.textContent = '';
        deleteBtn.title = 'Undo deletion';
        
        // Clear any other changes for this POI
        Object.keys(changes).forEach(field => {
          if (field !== '_delete') {
            delete changes[field];
          }
        });
        
        // Remove cell-changed classes
        row.querySelectorAll('.cell-changed').forEach(cell => {
          cell.classList.remove('cell-changed');
          cell.title = '';
        });
      }
      
      updateChangeButtons();
      updateStats();
    }
    
    async function reloadPOIEditor() {
      const reloadBtn = event?.target?.closest('button') || document.querySelector('button[onclick="reloadPOIEditor()"]');
      const originalContent = reloadBtn.innerHTML;
      
      // Show loading state
      reloadBtn.disabled = true;
      reloadBtn.innerHTML = '<span class="loading-spinner" style="margin-right: 0.5rem;"></span>Loading...';
      
      // Add loading overlay to table
      const tableContainer = document.querySelector('.poi-editor-table-container');
      if (tableContainer) {
        const overlay = document.createElement('div');
        overlay.className = 'poi-editor-loading-overlay';
        overlay.innerHTML = '<div style="text-align: center; color: white;"><div style="font-size: 2rem; margin-bottom: 0.5rem;"></div><div>Reloading POIs...</div></div>';
        tableContainer.appendChild(overlay);
      }
      
      try {
        poiChanges.clear();
        updateChangeButtons();
        await loadPOIEditor();
        
        // Remove overlay
        const overlay = tableContainer?.querySelector('.poi-editor-loading-overlay');
        if (overlay) overlay.remove();
        
        // Show success briefly
        reloadBtn.innerHTML = '<span style="margin-right: 0.5rem;"></span>Reloaded!';
        setTimeout(() => {
          reloadBtn.innerHTML = originalContent;
          reloadBtn.disabled = false;
        }, 1000);
      } catch (error) {
        // Show error
        reloadBtn.innerHTML = '<span style="margin-right: 0.5rem;"></span>Failed';
        setTimeout(() => {
          reloadBtn.innerHTML = originalContent;
          reloadBtn.disabled = false;
        }, 2000);
      }
    }
    
    // Search and filter functionality
    let searchTerm = '';
    let sortField = null;
    let sortDirection = 'asc';
    
    function searchPOIs() {
      // Check for unsaved changes before searching (which might hide edited rows)
      if (poiChanges.size > 0) {
        const searchInput = document.getElementById('poi-search');
        const newSearchTerm = searchInput.value.toLowerCase();
        
        // Only warn if the search would actually filter results
        if (newSearchTerm && newSearchTerm !== searchTerm) {
          if (!confirm('You have unsaved changes. Searching may hide rows with pending edits. Continue?')) {
            searchInput.value = searchTerm; // Reset to previous search term
            return;
          }
        }
      }
      
      searchTerm = document.getElementById('poi-search').value.toLowerCase();
      currentPOIEditorPage = 0;
      applySearchFilter();
    }
    
    function applySearchFilter() {
      const mapId = document.getElementById('poi-map-filter').value;
      
      // Start with map-filtered POIs
      let filtered = mapId === 'all' ? [...allPOIs] : allPOIs.filter(poi => poi.map_id === parseInt(mapId));
      
      // Apply search filter
      if (searchTerm) {
        filtered = filtered.filter(poi => {
          const searchableFields = [
            poi.id?.toString(),
            poi.name,
            poi.description,
            poi.created_by_name,
            poi.poi_type_name
          ].filter(Boolean).map(field => field.toLowerCase());
          
          return searchableFields.some(field => field.includes(searchTerm));
        });
      }
      
      // Apply sorting
      if (sortField) {
        filtered.sort((a, b) => {
          let aVal = a[sortField];
          let bVal = b[sortField];
          
          // Handle null/undefined values
          if (aVal == null) aVal = '';
          if (bVal == null) bVal = '';
          
          // Handle different data types
          if (typeof aVal === 'boolean') {
            aVal = aVal ? 1 : 0;
            bVal = bVal ? 1 : 0;
          }
          
          if (typeof aVal === 'string') {
            aVal = aVal.toLowerCase();
            bVal = bVal.toLowerCase();
          }
          
          if (aVal < bVal) return sortDirection === 'asc' ? -1 : 1;
          if (aVal > bVal) return sortDirection === 'asc' ? 1 : -1;
          return 0;
        });
      }
      
      filteredPOIs = filtered;
      displayPOIEditor();
      updateStats();
    }
    
    function updateStats() {
      document.getElementById('poi-total-count').textContent = allPOIs.length;
      document.getElementById('poi-filtered-count').textContent = filteredPOIs.length;
      document.getElementById('poi-pending-count').textContent = poiChanges.size;
    }
    
    // Export functionality
    function exportPOIsToCSV() {
      const headers = ['ID', 'Name', 'Description', 'Type', 'Icon Size', 'Created By', 'Map'];
      const rows = filteredPOIs.map(poi => [
        poi.id,
        poi.name || '',
        poi.description || '',
        poi.poi_type_name || '',
        poi.icon_size || 34,
        poi.created_by_name || '',
        poi.map_name || ''
      ]);
      
      // Convert to CSV format
      const csvContent = [
        headers.join(','),
        ...rows.map(row => row.map(cell => {
          // Escape quotes and wrap in quotes if contains comma or newline
          const cellStr = String(cell);
          if (cellStr.includes(',') || cellStr.includes('\n') || cellStr.includes('"')) {
            return '"' + cellStr.replace(/"/g, '""') + '"';
          }
          return cellStr;
        }).join(','))
      ].join('\n');
      
      // Create download link
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      link.setAttribute('download', `pois_export_${new Date().toISOString().split('T')[0]}.csv`);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
    
    function updatePOIEditorPagination(totalPages) {
      const paginationDiv = document.getElementById('poi-editor-pagination');
      
      if (totalPages <= 1) {
        paginationDiv.style.display = 'none';
        return;
      }
      
      paginationDiv.style.display = 'block';
      paginationDiv.innerHTML = '';
      
      // Create pagination buttons similar to POI types pagination
      const createButton = (text, page, disabled = false) => {
        const btn = document.createElement('button');
        btn.className = 'pagination-btn';
        btn.textContent = text;
        btn.disabled = disabled;
        if (page === currentPOIEditorPage) {
          btn.className += ' active';
        }
        btn.onclick = () => {
          // Check for unsaved changes before changing page
          if (poiChanges.size > 0) {
            if (!confirm('You have unsaved changes. Are you sure you want to change pages? Your changes will be lost.')) {
              return;
            }
            // Clear changes if user confirms
            poiChanges.clear();
            updateChangeButtons();
            updateStats();
          }
          currentPOIEditorPage = page;
          displayPOIEditor();
        };
        return btn;
      };
      
      // First/Previous buttons
      paginationDiv.appendChild(createButton('', 0, currentPOIEditorPage === 0));
      paginationDiv.appendChild(createButton('', currentPOIEditorPage - 1, currentPOIEditorPage === 0));
      
      // Page numbers
      const maxVisible = 5;
      let startPage = Math.max(0, currentPOIEditorPage - Math.floor(maxVisible / 2));
      let endPage = Math.min(totalPages - 1, startPage + maxVisible - 1);
      
      if (endPage - startPage < maxVisible - 1) {
        startPage = Math.max(0, endPage - maxVisible + 1);
      }
      
      for (let i = startPage; i <= endPage; i++) {
        paginationDiv.appendChild(createButton(i + 1, i));
      }
      
      // Next/Last buttons
      paginationDiv.appendChild(createButton('', currentPOIEditorPage + 1, currentPOIEditorPage === totalPages - 1));
      paginationDiv.appendChild(createButton('', totalPages - 1, currentPOIEditorPage === totalPages - 1));
    }

    // Close modals when clicking outside
    window.addEventListener('click', function(event) {
      if (event.target.classList.contains('modal')) {
        if (event.target.id === 'share-code-modal') {
          closeShareCodeModal();
        } else if (event.target.id === 'add-shared-poi-modal') {
          closeAddSharedPOIModal();
        } else if (event.target.id === 'share-users-modal') {
          closeShareUsersModal();
        } else if (event.target.id === 'poi-type-modal') {
          closePOITypeModal();
        } else if (event.target.id === 'npc-selector-modal') {
          closeNPCSelector();
        } else if (event.target.id === 'item-selector-modal') {
          closeItemSelector();
        }
      }
    });
    
    // NPC Selector for POI Editor
    let currentPOIForNPC = null;
    let currentPOIRow = null;
    
    function openNPCSelector(poiId, row) {
      currentPOIForNPC = poiId;
      currentPOIRow = row;
      
      // Create modal
      const modalHtml = `
        <div class="modal" id="npc-selector-modal" style="display: block;">
          <div class="modal-content" style="max-width: 800px; max-height: 80vh;">
            <div class="modal-header">
              <h2>Select NPC</h2>
              <button class="close-btn" onclick="closeNPCSelector()">&times;</button>
            </div>
            <div class="modal-body" style="padding: 1rem;">
              <div style="margin-bottom: 1rem;">
                <input type="text" id="npc-selector-search" placeholder="Search NPCs by name or ID..." 
                       style="width: 100%; padding: 0.5rem; border: 1px solid #555; border-radius: 4px; background: #2d2d2d; color: #e0e0e0;"
                       oninput="filterNPCsInSelector()">
              </div>
              <div id="npc-selector-list" style="max-height: 400px; overflow-y: auto; border: 1px solid #444; border-radius: 4px;">
                <div style="text-align: center; padding: 2rem; color: #666;">Loading NPCs...</div>
              </div>
            </div>
          </div>
        </div>
      `;
      
      const modalContainer = document.createElement('div');
      modalContainer.innerHTML = modalHtml;
      document.body.appendChild(modalContainer.firstElementChild);
      
      // Load NPCs
      loadNPCsForSelector();
    }
    
    async function loadNPCsForSelector() {
      try {
        const response = await fetch('/api/npcs');
        if (response.ok) {
          const npcs = await response.json();
          displayNPCsInSelector(npcs);
        }
      } catch (error) {
        console.error('Error loading NPCs:', error);
        document.getElementById('npc-selector-list').innerHTML = 
          '<div style="text-align: center; padding: 2rem; color: #dc3545;">Failed to load NPCs</div>';
      }
    }
    
    function displayNPCsInSelector(npcs) {
      const listDiv = document.getElementById('npc-selector-list');
      if (npcs.length === 0) {
        listDiv.innerHTML = '<div style="text-align: center; padding: 2rem; color: #666;">No NPCs found</div>';
        return;
      }
      
      listDiv.innerHTML = npcs.map(npc => `
        <div class="npc-selector-item" onclick="selectNPC(${npc.id}, ${npc.npcid}, '${npc.name.replace(/'/g, "\\'")}')"
             style="padding: 0.75rem; border-bottom: 1px solid #444; cursor: pointer; transition: background 0.2s;"
             onmouseover="this.style.background='#3a3a3a'" onmouseout="this.style.background='transparent'">
          <div style="display: flex; justify-content: between; align-items: center;">
            <div>
              <strong>${npc.name}</strong> 
              <span style="color: #666; margin-left: 0.5rem;">NPC ID: ${npc.npcid}</span>
            </div>
            <div style="color: #999; font-size: 0.85rem;">
              Level ${npc.level} ${npc.npc_type}
            </div>
          </div>
        </div>
      `).join('');
    }
    
    function filterNPCsInSelector() {
      const search = document.getElementById('npc-selector-search').value.toLowerCase();
      const items = document.querySelectorAll('.npc-selector-item');
      
      items.forEach(item => {
        const text = item.textContent.toLowerCase();
        item.style.display = text.includes(search) ? 'block' : 'none';
      });
    }
    
    function selectNPC(id, npcid, name) {
      if (currentPOIForNPC && currentPOIRow) {
        // Update the input display
        const npcInput = currentPOIRow.querySelector('[data-field="npc_id"]');
        if (npcInput) {
          npcInput.value = `${name} (${npcid})`;
          npcInput.dataset.npcId = npcid;
          stagePOIChange(currentPOIForNPC, 'npc_id', npcid);
          
          // Add clear button if not already present
          const container = npcInput.parentElement;
          if (!container.querySelector('button[title="Clear NPC"]')) {
            const clearBtn = document.createElement('button');
            clearBtn.innerHTML = '';
            clearBtn.title = 'Clear NPC';
            clearBtn.style.cssText = 'padding: 2px 6px; font-size: 0.8rem; cursor: pointer; background: #3a3a3a; border: 1px solid #555; border-radius: 3px; color: #e0e0e0; transition: all 0.2s;';
            clearBtn.onmouseover = () => { clearBtn.style.background = '#5a3a3a'; clearBtn.style.borderColor = '#666'; };
            clearBtn.onmouseout = () => { clearBtn.style.background = '#3a3a3a'; clearBtn.style.borderColor = '#555'; };
            clearBtn.onclick = () => {
              npcInput.value = '';
              npcInput.dataset.npcId = '';
              stagePOIChange(currentPOIForNPC, 'npc_id', null);
              clearBtn.remove();
            };
            container.appendChild(clearBtn);
          }
          
          // Clear item_id if set
          const itemInput = currentPOIRow.querySelector('[data-field="item_id"]');
          if (itemInput && itemInput.value) {
            itemInput.value = '';
            itemInput.dataset.itemId = '';
            stagePOIChange(currentPOIForNPC, 'item_id', null);
            // Remove item clear button
            const itemClearBtn = itemInput.parentElement.querySelector('button[title="Clear Item"]');
            if (itemClearBtn) itemClearBtn.remove();
          }
        }
      }
      closeNPCSelector();
    }
    
    function closeNPCSelector() {
      const modal = document.getElementById('npc-selector-modal');
      if (modal) modal.remove();
      currentPOIForNPC = null;
      currentPOIRow = null;
    }
    window.closeNPCSelector = closeNPCSelector;
    window.filterNPCsInSelector = filterNPCsInSelector;
    window.selectNPC = selectNPC;
    
    // Item Selector for POI Editor
    let currentPOIForItem = null;
    let currentPOIRowForItem = null;
    
    function openItemSelector(poiId, row) {
      currentPOIForItem = poiId;
      currentPOIRowForItem = row;
      
      // Create modal
      const modalHtml = `
        <div class="modal" id="item-selector-modal" style="display: block;">
          <div class="modal-content" style="max-width: 800px; max-height: 80vh;">
            <div class="modal-header">
              <h2>Select Item</h2>
              <button class="close-btn" onclick="closeItemSelector()">&times;</button>
            </div>
            <div class="modal-body" style="padding: 1rem;">
              <div style="margin-bottom: 1rem;">
                <input type="text" id="item-selector-search" placeholder="Search items by name or ID..." 
                       style="width: 100%; padding: 0.5rem; border: 1px solid #555; border-radius: 4px; background: #2d2d2d; color: #e0e0e0;"
                       oninput="filterItemsInSelector()">
              </div>
              <div id="item-selector-list" style="max-height: 400px; overflow-y: auto; border: 1px solid #444; border-radius: 4px;">
                <div style="text-align: center; padding: 2rem; color: #666;">Loading items...</div>
              </div>
            </div>
          </div>
        </div>
      `;
      
      const modalContainer = document.createElement('div');
      modalContainer.innerHTML = modalHtml;
      document.body.appendChild(modalContainer.firstElementChild);
      
      // Load items
      loadItemsForSelector();
    }
    
    async function loadItemsForSelector() {
      try {
        const response = await fetch('/api/items');
        if (response.ok) {
          const items = await response.json();
          displayItemsInSelector(items);
        }
      } catch (error) {
        console.error('Error loading items:', error);
        document.getElementById('item-selector-list').innerHTML = 
          '<div style="text-align: center; padding: 2rem; color: #dc3545;">Failed to load items</div>';
      }
    }
    
    function displayItemsInSelector(items) {
      const listDiv = document.getElementById('item-selector-list');
      if (items.length === 0) {
        listDiv.innerHTML = '<div style="text-align: center; padding: 2rem; color: #666;">No items found</div>';
        return;
      }
      
      listDiv.innerHTML = items.map(item => `
        <div class="item-selector-item" onclick="selectItem(${item.id}, '${item.name.replace(/'/g, "\\'")}')"
             style="padding: 0.75rem; border-bottom: 1px solid #444; cursor: pointer; transition: background 0.2s;"
             onmouseover="this.style.background='#3a3a3a'" onmouseout="this.style.background='transparent'">
          <div style="display: flex; justify-content: between; align-items: center;">
            <div style="display: flex; align-items: center; gap: 0.5rem;">
              ${item.icon_type === 'emoji' ? 
                `<span style="font-size: 1.5rem;">${item.icon_value}</span>` :
                `<iconify-icon icon="${item.icon_value}" width="24"></iconify-icon>`
              }
              <div>
                <strong>${item.name}</strong>
                <span style="color: #666; margin-left: 0.5rem;">ID: ${item.id}</span>
              </div>
            </div>
            <div style="color: #999; font-size: 0.85rem;">
              ${item.slot || 'No slot'} - ${item.item_type || 'Unknown type'}
            </div>
          </div>
        </div>
      `).join('');
    }
    
    function filterItemsInSelector() {
      const search = document.getElementById('item-selector-search').value.toLowerCase();
      const items = document.querySelectorAll('.item-selector-item');
      
      items.forEach(item => {
        const text = item.textContent.toLowerCase();
        item.style.display = text.includes(search) ? 'block' : 'none';
      });
    }
    
    function selectItem(id, name) {
      if (currentPOIForItem && currentPOIRowForItem) {
        // Update the input display
        const itemInput = currentPOIRowForItem.querySelector('[data-field="item_id"]');
        if (itemInput) {
          itemInput.value = `${name} (${id})`;
          itemInput.dataset.itemId = id;
          stagePOIChange(currentPOIForItem, 'item_id', id);
          
          // Add clear button if not already present
          const container = itemInput.parentElement;
          if (!container.querySelector('button[title="Clear Item"]')) {
            const clearBtn = document.createElement('button');
            clearBtn.innerHTML = '';
            clearBtn.title = 'Clear Item';
            clearBtn.style.cssText = 'padding: 2px 6px; font-size: 0.8rem; cursor: pointer; background: #3a3a3a; border: 1px solid #555; border-radius: 3px; color: #e0e0e0; transition: all 0.2s;';
            clearBtn.onmouseover = () => { clearBtn.style.background = '#5a3a3a'; clearBtn.style.borderColor = '#666'; };
            clearBtn.onmouseout = () => { clearBtn.style.background = '#3a3a3a'; clearBtn.style.borderColor = '#555'; };
            clearBtn.onclick = () => {
              itemInput.value = '';
              itemInput.dataset.itemId = '';
              stagePOIChange(currentPOIForItem, 'item_id', null);
              clearBtn.remove();
            };
            container.appendChild(clearBtn);
          }
          
          // Clear npc_id if set
          const npcInput = currentPOIRowForItem.querySelector('[data-field="npc_id"]');
          if (npcInput && npcInput.value) {
            npcInput.value = '';
            npcInput.dataset.npcId = '';
            stagePOIChange(currentPOIForItem, 'npc_id', null);
            // Remove NPC clear button
            const npcClearBtn = npcInput.parentElement.querySelector('button[title="Clear NPC"]');
            if (npcClearBtn) npcClearBtn.remove();
          }
        }
      }
      closeItemSelector();
    }
    
    function closeItemSelector() {
      const modal = document.getElementById('item-selector-modal');
      if (modal) modal.remove();
      currentPOIForItem = null;
      currentPOIRowForItem = null;
    }
    window.closeItemSelector = closeItemSelector;
    window.filterItemsInSelector = filterItemsInSelector;
    window.selectItem = selectItem;
    
    // Emoji picker helper
    const badgeEmojis = {
      'Medals & Trophies': ['', '', '', '', '', '', '', ''],
      'Stars & Gems': ['', '', '', '', '', '', '', '', ''],
      'Crowns & Shields': ['', '', '', '', '', '', '', ''],
      'Nature & Elements': ['', '', '', '', '', '', '', '', '', ''],
      'Hearts & Symbols': ['', '', '', '', '', '', '', '', '', ''],
      'Other Badges': ['', '', '', '', '', '', '', '', '', '']
    };
    
    function createEmojiPickerContent(inputId) {
      let html = '';
      
      for (const [category, emojis] of Object.entries(badgeEmojis)) {
        html += `
          <div class="emoji-category">
            <div class="emoji-category-title">${category}</div>
            <div class="emoji-picker-grid">
              ${emojis.map(emoji => `
                <button type="button" class="emoji-option" onclick="selectEmoji('${inputId}', '${emoji}')">${emoji}</button>
              `).join('')}
            </div>
          </div>
        `;
      }
      
      return html;
    }
    
    function createEmojiPicker(inputId) {
      return '<div class="emoji-picker-dropdown" id="emoji-picker-' + inputId + '">' + createEmojiPickerContent(inputId) + '</div>';
    }
    
    function toggleEmojiPicker(inputId) {
      const picker = document.getElementById('emoji-picker-' + inputId);
      picker.classList.toggle('show');
      
      // Close picker when clicking outside
      if (picker.classList.contains('show')) {
        setTimeout(() => {
          document.addEventListener('click', function closeEmojiPicker(e) {
            if (!e.target.closest('.emoji-input-wrapper')) {
              picker.classList.remove('show');
              document.removeEventListener('click', closeEmojiPicker);
            }
          });
        }, 100);
      }
    }
    
    function selectEmoji(inputId, emoji) {
      const input = document.getElementById(inputId);
      input.value = emoji;
      const picker = document.getElementById('emoji-picker-' + inputId);
      picker.classList.remove('show');
    }
    
    window.toggleEmojiPicker = toggleEmojiPicker;
    window.selectEmoji = selectEmoji;
    window.sortProposals = sortProposals;
    
    // Donation Tiers Management Functions
    window.showCreateDonationTierModal = showCreateDonationTierModal;
    window.editDonationTier = editDonationTier;
    window.toggleDonationTierStatus = toggleDonationTierStatus;
    window.deleteDonationTier = deleteDonationTier;
    window.recalculateAllDonationTiers = recalculateAllDonationTiers;
    
    function showCreateDonationTierModal() {
      const modal = document.createElement('div');
      modal.className = 'modal-overlay';
      modal.innerHTML = `
        <div class="modal-content" style="max-width: 500px;">
          <h3 style="color: #FFD700; margin-bottom: 1.5rem;">Create New Donation Tier</h3>
          <form id="create-tier-form">
            <div class="form-group">
              <label>Tier Name</label>
              <input type="text" name="name" required placeholder="e.g., Bronze Supporter">
            </div>
            <div class="form-group">
              <label>Required Amount ($)</label>
              <input type="number" name="required_amount" min="0" step="0.01" required placeholder="e.g., 10.00">
            </div>
            <div class="form-group">
              <label>Badge Color (Hex)</label>
              <input type="color" name="badge_color" required value="#FFD700">
            </div>
            <div class="form-group">
              <label>Badge Icon (Emoji)</label>
              <div class="emoji-input-wrapper">
                <input type="text" id="create-tier-emoji" name="badge_icon" placeholder="e.g., " maxlength="2">
                <button type="button" class="emoji-picker-toggle" onclick="toggleEmojiPicker('create-tier-emoji')"></button>
                <div class="emoji-picker-dropdown" id="emoji-picker-create-tier-emoji"></div>
              </div>
            </div>
            <div class="form-group">
              <label>Tier Order</label>
              <input type="number" name="tier_order" min="1" required placeholder="1 = lowest tier">
              <small style="color: #999; display: block; margin-top: 0.25rem;">Lower numbers appear first. Existing tiers will be automatically shifted if needed.</small>
            </div>
            <div class="form-group">
              <label>Description</label>
              <textarea name="description" rows="3" placeholder="Description of this tier"></textarea>
            </div>
            <div class="form-group">
              <label>Perks (one per line)</label>
              <textarea name="perks" rows="4" placeholder="Badge displayed next to username&#10;Access to supporter chat&#10;Early access to features"></textarea>
            </div>
            <div class="modal-actions">
              <button type="submit" class="btn btn-primary">Create Tier</button>
              <button type="button" onclick="this.closest('.modal-overlay').remove()" class="btn btn-secondary">Cancel</button>
            </div>
          </form>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      // Populate the emoji picker
      const emojiPicker = document.getElementById('emoji-picker-create-tier-emoji');
      if (emojiPicker) {
        emojiPicker.innerHTML = createEmojiPickerContent('create-tier-emoji');
      }
      
      document.getElementById('create-tier-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        const formData = new FormData(e.target);
        const data = {
          name: formData.get('name'),
          required_amount: parseFloat(formData.get('required_amount')),
          badge_color: formData.get('badge_color'),
          badge_icon: formData.get('badge_icon') || null,
          tier_order: parseInt(formData.get('tier_order')),
          description: formData.get('description') || null,
          perks: formData.get('perks').split('\n').filter(p => p.trim()).length > 0 
            ? formData.get('perks').split('\n').filter(p => p.trim()) 
            : null
        };
        
        try {
          const csrfToken = await getCSRFToken();
          const response = await fetch('/api/donations/admin/tiers', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-CSRF-Token': csrfToken
            },
            body: JSON.stringify(data)
          });
          
          if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || 'Failed to create tier');
          }
          
          modal.remove();
          showMessage('Donation tier created successfully', 'success');
          loadDonationTiers();
        } catch (error) {
          showMessage(error.message, 'error');
        }
      });
    }
    
    
    async function toggleDonationTierStatus(tierId, activate) {
      const action = activate ? 'activate' : 'deactivate';
      if (!confirm(`Are you sure you want to ${action} this tier?`)) return;
      
      try {
        const csrfToken = await getCSRFToken();
        const response = await fetch(`/api/donations/admin/tiers/${tierId}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRF-Token': csrfToken
          },
          body: JSON.stringify({ is_active: activate })
        });
        
        if (!response.ok) throw new Error(`Failed to ${action} tier`);
        
        showMessage(`Tier ${action}d successfully`, 'success');
        loadDonationTiers();
      } catch (error) {
        showMessage(error.message, 'error');
      }
    }
    
    async function deleteDonationTier(tierId) {
      if (!confirm('Are you sure you want to delete this tier? This action cannot be undone.')) return;
      
      try {
        const csrfToken = await getCSRFToken();
        const response = await fetch(`/api/donations/admin/tiers/${tierId}`, {
          method: 'DELETE',
          headers: {
            'X-CSRF-Token': csrfToken
          }
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to delete tier');
        }
        
        showMessage('Tier deleted successfully', 'success');
        loadDonationTiers();
      } catch (error) {
        showMessage(error.message, 'error');
      }
    }
    
    async function recalculateAllDonationTiers() {
      if (!confirm('This will recalculate donation tiers for all users based on their total donations. Continue?')) return;
      
      try {
        const csrfToken = await getCSRFToken();
        const response = await fetch('/api/donations/admin/recalculate-tiers', {
          method: 'POST',
          headers: {
            'X-CSRF-Token': csrfToken
          }
        });
        
        if (!response.ok) throw new Error('Failed to recalculate tiers');
        
        const result = await response.json();
        showMessage(`Successfully recalculated tiers for ${result.updated} users`, 'success');
        loadDonationTiers();
      } catch (error) {
        showMessage('Failed to recalculate tiers', 'error');
      }
    }
    
    // Helper function to get CSRF token
    async function getCSRFToken() {
      try {
        const response = await fetch('/api/csrf-token');
        const data = await response.json();
        return data.csrfToken;
      } catch (error) {
        console.error('Failed to get CSRF token:', error);
        throw error;
      }
    }
    
    // Donation Tiers Management Functions
    let loadedDonationTiers = [];
    
    async function loadDonationTiers() {
      const section = document.getElementById('donation-tiers-section');
      if (section.classList.contains('collapsed')) return;
      
      const loadingEl = document.getElementById('donation-tiers-loading');
      const contentEl = document.getElementById('donation-tiers-content');
      const tbody = document.getElementById('donation-tiers-tbody');
      const statsEl = document.getElementById('tier-statistics');
      
      try {
        loadingEl.style.display = 'block';
        contentEl.style.display = 'none';
        
        // Load tiers
        const [tiersResponse, statsResponse] = await Promise.all([
          fetch('/api/donations/admin/tiers'),
          fetch('/api/donations/admin/stats')
        ]);
        
        if (!tiersResponse.ok || !statsResponse.ok) {
          throw new Error('Failed to load donation data');
        }
        
        const tiers = await tiersResponse.json();
        const stats = await statsResponse.json();
        
        // Store tiers globally for edit function
        loadedDonationTiers = tiers;
        
        // Display tier statistics
        statsEl.innerHTML = stats.tierStats.map(tier => `
          <div style="text-align: center; padding: 1rem; background: #2d2d2d; border-radius: 8px; border: 1px solid #444;">
            <div style="font-size: 2rem; margin-bottom: 0.5rem;">
              <span style="color: ${tier.badge_color}">${tier.badge_icon || ''}</span>
            </div>
            <div style="color: ${tier.badge_color}; font-weight: bold; margin-bottom: 0.25rem;">${tier.tier_name}</div>
            <div style="font-size: 1.5rem; font-weight: bold;">${tier.user_count}</div>
            <div style="color: #999; font-size: 0.8rem;">users</div>
          </div>
        `).join('');
        
        // Display tiers table
        tbody.innerHTML = tiers.map(tier => `
          <tr>
            <td style="text-align: center;">${tier.tier_order}</td>
            <td style="text-align: center;">
              <span style="font-size: 1.5rem; color: ${tier.badge_color}">
                ${tier.badge_icon || ''}
              </span>
            </td>
            <td>
              <span style="color: ${tier.badge_color}; font-weight: bold;">
                ${tier.name}
              </span>
            </td>
            <td>$${parseFloat(tier.required_amount).toFixed(2)}</td>
            <td>${tier.description || '-'}</td>
            <td style="text-align: center;">
              ${stats.tierStats.find(s => s.tier_name === tier.name)?.user_count || 0}
            </td>
            <td style="text-align: center;">
              <span class="status-badge ${tier.is_active ? 'status-active' : 'status-inactive'}">
                ${tier.is_active ? 'Active' : 'Inactive'}
              </span>
            </td>
            <td>
              <button onclick="editDonationTier(${tier.id})" class="action-btn" title="Edit tier">
                
              </button>
              <button onclick="toggleDonationTierStatus(${tier.id}, ${!tier.is_active})" 
                      class="action-btn" title="${tier.is_active ? 'Deactivate' : 'Activate'} tier">
                ${tier.is_active ? '' : ''}
              </button>
              ${stats.tierStats.find(s => s.tier_name === tier.name)?.user_count === 0 ? `
                <button onclick="deleteDonationTier(${tier.id})" class="action-btn" title="Delete tier" 
                        style="color: #dc3545;">
                  
                </button>
              ` : ''}
            </td>
          </tr>
        `).join('');
        
        loadingEl.style.display = 'none';
        contentEl.style.display = 'block';
      } catch (error) {
        console.error('Error loading donation tiers:', error);
        loadingEl.innerHTML = '<p style="color: #dc3545;">Failed to load donation tiers</p>';
      }
    }
    
    /* DUPLICATE - COMMENTED OUT
    async function showAddDonationTierModal() {
      const modal = document.createElement('div');
      modal.className = 'modal-overlay active';
      modal.innerHTML = `
        <div class="modal-content" style="max-width: 500px;">
          <div class="modal-header">
            <h3>Add Donation Tier</h3>
            <button class="close-btn" onclick="this.closest('.modal-overlay').remove()"></button>
          </div>
          <div class="modal-body">
            <div class="form-group">
              <label>Tier Name</label>
              <input type="text" id="tier-name" placeholder="e.g., Bronze, Silver, Gold" 
                     style="width: 100%; padding: 0.5rem; border: 1px solid #555; 
                            border-radius: 4px; background: #2d2d2d; color: #e0e0e0;">
            </div>
            
            <div class="form-group" style="margin-top: 1rem;">
              <label>Required Amount ($)</label>
              <input type="number" id="tier-amount" min="0" step="0.01" placeholder="10.00"
                     style="width: 100%; padding: 0.5rem; border: 1px solid #555; 
                            border-radius: 4px; background: #2d2d2d; color: #e0e0e0;">
            </div>
            
            <div class="form-group" style="margin-top: 1rem;">
              <label>Badge Color</label>
              <div style="display: flex; gap: 0.5rem; align-items: center;">
                <input type="color" id="tier-color" value="#FFD700"
                       style="width: 60px; height: 40px; border: 1px solid #555; 
                              border-radius: 4px; background: #2d2d2d; cursor: pointer;">
                <input type="text" id="tier-color-hex" value="#FFD700" placeholder="#FFD700"
                       style="flex: 1; padding: 0.5rem; border: 1px solid #555; 
                              border-radius: 4px; background: #2d2d2d; color: #e0e0e0;">
              </div>
            </div>
            
            <div class="form-group" style="margin-top: 1rem;">
              <label>Badge Icon (Emoji)</label>
              <input type="text" id="tier-icon" placeholder="" maxlength="2"
                     style="width: 100%; padding: 0.5rem; border: 1px solid #555; 
                            border-radius: 4px; background: #2d2d2d; color: #e0e0e0; font-size: 1.5rem;">
            </div>
            
            <div class="form-group" style="margin-top: 1rem;">
              <label>Tier Order</label>
              <input type="number" id="tier-order" min="1" value="1" 
                     style="width: 100%; padding: 0.5rem; border: 1px solid #555; 
                            border-radius: 4px; background: #2d2d2d; color: #e0e0e0;">
              <small style="color: #999;">Lower numbers appear first (1 = lowest tier)</small>
            </div>
            
            <div class="form-group" style="margin-top: 1rem;">
              <label>Description</label>
              <textarea id="tier-description" rows="3" placeholder="Description of this tier..."
                        style="width: 100%; padding: 0.5rem; border: 1px solid #555; 
                               border-radius: 4px; background: #2d2d2d; color: #e0e0e0; resize: vertical;"></textarea>
            </div>
          </div>
          <div class="modal-footer">
            <button class="secondary-btn" onclick="this.closest('.modal-overlay').remove()">Cancel</button>
            <button class="primary-btn" onclick="createDonationTier()">Create Tier</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      // Sync color picker with hex input
      const colorPicker = document.getElementById('tier-color');
      const colorHex = document.getElementById('tier-color-hex');
      
      colorPicker.addEventListener('input', (e) => {
        colorHex.value = e.target.value.toUpperCase();
      });
      
      colorHex.addEventListener('input', (e) => {
        if (/^#[0-9A-F]{6}$/i.test(e.target.value)) {
          colorPicker.value = e.target.value;
        }
      });
    } */
    
    /* DUPLICATE - COMMENTED OUT
    async function createDonationTier() {
      const name = document.getElementById('tier-name').value.trim();
      const amount = parseFloat(document.getElementById('tier-amount').value);
      const color = document.getElementById('tier-color-hex').value.trim();
      const icon = document.getElementById('tier-icon').value.trim();
      const order = parseInt(document.getElementById('tier-order').value);
      const description = document.getElementById('tier-description').value.trim();
      
      if (!name || !amount || !color || !order) {
        showMessage('Please fill in all required fields', 'error');
        return;
      }
      
      if (!/^#[0-9A-F]{6}$/i.test(color)) {
        showMessage('Invalid color format. Use hex color (e.g., #FFD700)', 'error');
        return;
      }
      
      try {
        const csrfToken = await getCSRFToken();
        const response = await fetch('/api/donations/admin/tiers', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRF-Token': csrfToken
          },
          body: JSON.stringify({
            name,
            required_amount: amount,
            badge_color: color.toUpperCase(),
            badge_icon: icon || null,
            tier_order: order,
            description: description || null,
            perks: []
          })
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to create tier');
        }
        
        document.querySelector('.modal-overlay').remove();
        showMessage('Donation tier created successfully', 'success');
        loadDonationTiers();
      } catch (error) {
        showMessage(error.message, 'error');
      }
    } */
    
    async function editDonationTier(tierId) {
      // Find the tier from our loaded data
      const tier = loadedDonationTiers.find(t => t.id === tierId);
      if (!tier) {
        showMessage('Tier not found', 'error');
        return;
      }
      
      const modal = document.createElement('div');
      modal.className = 'modal-overlay';
      modal.innerHTML = `
        <div class="modal-content" style="max-width: 500px;">
          <h3 style="color: #FFD700; margin-bottom: 1.5rem;">Edit Donation Tier</h3>
          <form id="edit-tier-form">
            <div class="form-group">
              <label>Tier Name</label>
              <input type="text" name="name" required value="${escapeHtml(tier.name)}">
            </div>
            <div class="form-group">
              <label>Required Amount ($)</label>
              <input type="number" name="required_amount" min="0" step="0.01" required value="${tier.required_amount}">
            </div>
            <div class="form-group">
              <label>Badge Color (Hex)</label>
              <input type="color" name="badge_color" required value="${tier.badge_color}">
            </div>
            <div class="form-group">
              <label>Badge Icon (Emoji)</label>
              <div class="emoji-input-wrapper">
                <input type="text" id="edit-tier-emoji-${tierId}" name="badge_icon" placeholder="e.g., " maxlength="2" value="${escapeHtml(tier.badge_icon || '')}">
                <button type="button" class="emoji-picker-toggle" onclick="toggleEmojiPicker('edit-tier-emoji-${tierId}')"></button>
                <div class="emoji-picker-dropdown" id="emoji-picker-edit-tier-emoji-${tierId}"></div>
              </div>
            </div>
            <div class="form-group">
              <label>Tier Order</label>
              <input type="number" name="tier_order" min="1" required value="${tier.tier_order}">
            </div>
            <div class="form-group">
              <label>Description (Optional)</label>
              <textarea name="description" rows="3" placeholder="Describe this tier...">${escapeHtml(tier.description || '')}</textarea>
            </div>
            <div class="form-group">
              <label>Perks (Optional, one per line)</label>
              <textarea name="perks" rows="4" placeholder="Special badge color\nAccess to exclusive features\nPriority support">${tier.perks && Array.isArray(tier.perks) ? escapeHtml(tier.perks.join('\n')) : ''}</textarea>
            </div>
            <div class="form-group">
              <label>
                <input type="checkbox" name="is_active" ${tier.is_active ? 'checked' : ''}>
                Active
              </label>
            </div>
            <div class="modal-actions" style="display: flex; gap: 1rem; justify-content: flex-end; margin-top: 1.5rem;">
              <button type="button" onclick="this.closest('.modal-overlay').remove()" class="btn btn-secondary">Cancel</button>
              <button type="submit" class="btn btn-primary">Update Tier</button>
            </div>
          </form>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      // Populate the emoji picker
      const emojiPicker = document.getElementById('emoji-picker-edit-tier-emoji-' + tierId);
      if (emojiPicker) {
        emojiPicker.innerHTML = createEmojiPickerContent('edit-tier-emoji-' + tierId);
      }
      
      document.getElementById('edit-tier-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        const formData = new FormData(e.target);
        
        const data = {
          name: formData.get('name'),
          required_amount: parseFloat(formData.get('required_amount')),
          badge_color: formData.get('badge_color'),
          badge_icon: formData.get('badge_icon') || null,
          tier_order: parseInt(formData.get('tier_order')),
          description: formData.get('description') || null,
          perks: formData.get('perks').split('\n').filter(p => p.trim()).length > 0 
            ? formData.get('perks').split('\n').filter(p => p.trim()) 
            : null,
          is_active: formData.has('is_active')
        };
        
        try {
          const csrfToken = await getCSRFToken();
          const response = await fetch(`/api/donations/admin/tiers/${tierId}`, {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
              'X-CSRF-Token': csrfToken
            },
            body: JSON.stringify(data)
          });
          
          if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || 'Failed to update tier');
          }
          
          modal.remove();
          showMessage('Donation tier updated successfully', 'success');
          loadDonationTiers();
        } catch (error) {
          showMessage(error.message, 'error');
        }
      });
    }
    
    async function toggleDonationTierStatus(tierId, activate) {
      if (!confirm(`Are you sure you want to ${activate ? 'activate' : 'deactivate'} this tier?`)) {
        return;
      }
      
      try {
        const csrfToken = await getCSRFToken();
        const response = await fetch(`/api/donations/admin/tiers/${tierId}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRF-Token': csrfToken
          },
          body: JSON.stringify({ is_active: activate })
        });
        
        if (!response.ok) throw new Error('Failed to update tier status');
        
        showMessage(`Tier ${activate ? 'activated' : 'deactivated'} successfully`, 'success');
        loadDonationTiers();
      } catch (error) {
        showMessage(error.message, 'error');
      }
    }
    
    async function deleteDonationTier(tierId) {
      if (!confirm('Are you sure you want to delete this tier? This cannot be undone.')) {
        return;
      }
      
      try {
        const csrfToken = await getCSRFToken();
        const response = await fetch(`/api/donations/admin/tiers/${tierId}`, {
          method: 'DELETE',
          headers: {
            'X-CSRF-Token': csrfToken
          }
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to delete tier');
        }
        
        showMessage('Tier deleted successfully', 'success');
        loadDonationTiers();
      } catch (error) {
        showMessage(error.message, 'error');
      }
    }
    
    async function recalculateAllDonationTiers() {
      if (!confirm('This will recalculate donation tiers for all users based on their total donations. Continue?')) {
        return;
      }
      
      try {
        const csrfToken = await getCSRFToken();
        const response = await fetch('/api/donations/admin/recalculate-tiers', {
          method: 'POST',
          headers: {
            'X-CSRF-Token': csrfToken
          }
        });
        
        if (!response.ok) throw new Error('Failed to recalculate tiers');
        
        showMessage('All user donation tiers recalculated successfully', 'success');
        loadDonationTiers();
      } catch (error) {
        showMessage(error.message, 'error');
      }
    }
    
    function showTestDonationModal() {
      const modal = document.createElement('div');
      modal.className = 'modal-overlay';
      modal.innerHTML = `
        <div class="modal-content" style="max-width: 400px;">
          <h3 style="color: #ff6b6b; margin-bottom: 1.5rem;"> Create Test Donation</h3>
          <p style="color: #FFA500; margin-bottom: 1rem; font-size: 0.9rem;">
             Development Mode Only - This creates a test donation for the current user
          </p>
          <form id="test-donation-form">
            <div class="form-group">
              <label>Amount ($)</label>
              <input type="number" name="amount" min="0.01" step="0.01" value="10.00" required>
            </div>
            <div class="form-group">
              <label>Message (Optional)</label>
              <textarea name="message" rows="3" placeholder="Test donation message">Test donation for tier testing</textarea>
            </div>
            <div class="modal-actions">
              <button type="submit" class="btn btn-primary" style="background: #ff6b6b;">Create Test Donation</button>
              <button type="button" onclick="this.closest('.modal-overlay').remove()" class="btn btn-secondary">Cancel</button>
            </div>
          </form>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      document.getElementById('test-donation-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        const formData = new FormData(e.target);
        
        try {
          const csrfToken = await getCSRFToken();
          const response = await fetch('/api/donations/test-donation', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-CSRF-Token': csrfToken
            },
            body: JSON.stringify({
              amount: parseFloat(formData.get('amount')),
              message: formData.get('message') || 'Test donation'
            })
          });
          
          if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || 'Failed to create test donation');
          }
          
          const result = await response.json();
          modal.remove();
          showMessage(result.message, 'success');
          
          // Reload donation data
          if (typeof loadUserDonations === 'function') {
            loadUserDonations();
          }
          if (typeof loadDonationsManagement === 'function') {
            loadDonationsManagement();
          }
        } catch (error) {
          showMessage(error.message, 'error');
        }
      });
    }
    
    async function resetMyDonationStats() {
      try {
        const csrfToken = await getCSRFToken();
        const response = await fetch('/api/donations/admin/reset-user-donations', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRF-Token': csrfToken
          },
          body: JSON.stringify({})
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to reset donation stats');
        }
        
        const result = await response.json();
        showMessage('Your donation stats have been fixed!', 'success');
        
        // Reload donation data
        if (typeof loadUserDonations === 'function') {
          loadUserDonations();
        }
      } catch (error) {
        showMessage('Failed to reset donation stats: ' + error.message, 'error');
      }
    }
    
    // Make functions available globally
    window.loadDonationTiers = loadDonationTiers;
    window.showCreateDonationTierModal = showCreateDonationTierModal;
    window.editDonationTier = editDonationTier;
    window.toggleDonationTierStatus = toggleDonationTierStatus;
    window.deleteDonationTier = deleteDonationTier;
    window.recalculateAllDonationTiers = recalculateAllDonationTiers;
    window.showTestDonationModal = showTestDonationModal;
    window.resetMyDonationStats = resetMyDonationStats;
    window.loadUserDonations = loadUserDonations;
    
    // Function to simulate Ko-fi webhook for testing
    async function simulateKofiWebhook() {
      const webhookData = {
        verification_token: "b9ac8182-094b-46ce-b8df-ec623784ddac",
        message_id: "test-" + Date.now(),
        timestamp: new Date().toISOString(),
        type: "Donation",
        is_public: true,
        from_name: currentUser.nickname || currentUser.name,
        message: "Test webhook donation",
        amount: "10.00",
        url: "https://ko-fi.com/Home/CoffeeShop?txid=TEST",
        email: currentUser.email,
        currency: "USD",
        is_subscription_payment: false,
        is_first_subscription_payment: false,
        kofi_transaction_id: "TEST_" + Date.now(),
        shop_items: null,
        tier_name: null,
        shipping: null
      };
      
      try {
        const response = await fetch('/api/kofi-webhook', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/x-www-form-urlencoded'
          },
          body: 'data=' + encodeURIComponent(JSON.stringify(webhookData))
        });
        
        if (response.ok) {
          const result = await response.json();
          showMessage('Webhook simulated successfully! Check donations list.', 'success');
          // Reload donations
          if (typeof loadDonationsManagement === 'function') {
            loadDonationsManagement();
          }
          if (typeof loadUserDonations === 'function') {
            loadUserDonations();
          }
        } else {
          const error = await response.text();
          showMessage('Webhook simulation failed: ' + error, 'error');
        }
      } catch (error) {
        showMessage('Failed to simulate webhook: ' + error.message, 'error');
      }
    }
    window.simulateKofiWebhook = simulateKofiWebhook;
    
    // Donation management functions
    async function showDonationDetails(donationId) {
      try {
        const response = await fetch(`/api/donations?limit=1000`);
        if (!response.ok) throw new Error('Failed to fetch donations');
        
        const data = await response.json();
        const donation = data.donations.find(d => d.id === donationId);
        
        if (!donation) {
          showMessage('Donation not found', 'error');
          return;
        }
        
        const modal = document.createElement('div');
        modal.className = 'modal-overlay';
        modal.innerHTML = `
          <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
              <h3>Donation Details</h3>
              <button class="close-btn" onclick="this.closest('.modal-overlay').remove()">&times;</button>
            </div>
            <div class="modal-body">
              <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                <div>
                  <label style="color: #999; font-size: 0.85rem;">Transaction ID</label>
                  <div style="font-family: monospace; font-size: 0.9rem;">${escapeHtml(donation.kofi_transaction_id)}</div>
                </div>
                <div>
                  <label style="color: #999; font-size: 0.85rem;">Type</label>
                  <div>${donation.type}</div>
                </div>
                <div>
                  <label style="color: #999; font-size: 0.85rem;">From</label>
                  <div>${escapeHtml(donation.from_name)}</div>
                </div>
                <div>
                  <label style="color: #999; font-size: 0.85rem;">Amount</label>
                  <div style="color: #FFD700; font-size: 1.2rem; font-weight: bold;">$${parseFloat(donation.amount).toFixed(2)} ${donation.currency}</div>
                </div>
                <div>
                  <label style="color: #999; font-size: 0.85rem;">Date</label>
                  <div>${new Date(donation.timestamp).toLocaleString()}</div>
                </div>
                <div>
                  <label style="color: #999; font-size: 0.85rem;">Email</label>
                  <div>${donation.email || '<span style="color: #666;">Not provided</span>'}</div>
                </div>
                <div>
                  <label style="color: #999; font-size: 0.85rem;">Public</label>
                  <div>${donation.is_public ? ' Yes' : ' No'}</div>
                </div>
                <div>
                  <label style="color: #999; font-size: 0.85rem;">Subscription</label>
                  <div>${donation.is_subscription ? ' Yes' : ' No'}</div>
                </div>
              </div>
              
              ${donation.message ? `
                <div style="margin-top: 1rem;">
                  <label style="color: #999; font-size: 0.85rem;">Message</label>
                  <div style="background: #2d2d2d; padding: 1rem; border-radius: 8px; margin-top: 0.5rem;">
                    ${escapeHtml(donation.message)}
                  </div>
                </div>
              ` : ''}
              
              <div style="margin-top: 1rem;">
                <label style="color: #999; font-size: 0.85rem;">Matched User</label>
                <div>
                  ${donation.user_id ? `
                    <a href="#" onclick="showUserDetail(${donation.user_id}); return false;" style="color: #4a7c59;">
                      ${escapeHtml(donation.user_name || donation.user_nickname || 'User #' + donation.user_id)}
                    </a>
                    <span style="color: #666; font-size: 0.85rem;">(${donation.matched_by})</span>
                  ` : '<span style="color: #dc3545;">Not matched</span>'}
                </div>
              </div>
              
              <div style="margin-top: 1.5rem; text-align: right;">
                <button onclick="this.closest('.modal-overlay').remove()" class="btn btn-primary">Close</button>
              </div>
            </div>
          </div>
        `;
        
        document.body.appendChild(modal);
      } catch (error) {
        console.error('Error showing donation details:', error);
        showMessage('Failed to load donation details', 'error');
      }
    }
    
    async function unmatchDonation(donationId) {
      if (!confirm('Are you sure you want to unmatch this donation from its user?')) return;
      
      try {
        // First, get the current user_id of the donation
        const donationsResponse = await fetch(`/api/donations?limit=1000`);
        const donationsData = await donationsResponse.json();
        const donation = donationsData.donations.find(d => d.id === donationId);
        const originalUserId = donation?.user_id;
        
        const csrfToken = await getCSRFToken();
        const response = await fetch(`/api/donations/${donationId}/match`, {
          method: 'PATCH',
          headers: { 
            'Content-Type': 'application/json',
            'X-CSRF-Token': csrfToken
          },
          body: JSON.stringify({ user_id: null })
        });
        
        if (!response.ok) {
          const error = await response.json();
          throw new Error(error.error || 'Failed to unmatch donation');
        }
        
        showMessage('Donation unmatched successfully', 'success');
        refreshDonations();
        
        // Refresh stats for the affected user
        if (originalUserId) {
          await refreshDonationStatsForUser(originalUserId);
        }
        
        // Mark that donation data needs refresh
        donationDataNeedsRefresh = true;
        
        // If currently on Profile tab, refresh after a short delay
        const activeTab = document.querySelector('.tab-content.active');
        if (activeTab && activeTab.id === 'profile-tab') {
          setTimeout(() => {
            loadUserDonations();
            donationDataNeedsRefresh = false;
          }, 300);
        }
      } catch (error) {
        console.error('Error unmatching donation:', error);
        showMessage('Failed to unmatch donation: ' + error.message, 'error');
      }
    }
    
    async function deleteDonation(donationId) {
      if (!confirm('Are you sure you want to delete this donation? This action cannot be undone.')) return;
      
      try {
        // First, get the user_id of the donation before deleting
        const donationsResponse = await fetch(`/api/donations?limit=1000`);
        const donationsData = await donationsResponse.json();
        const donation = donationsData.donations.find(d => d.id === donationId);
        const affectedUserId = donation?.user_id;
        
        const csrfToken = await getCSRFToken();
        const response = await fetch(`/api/donations/${donationId}`, {
          method: 'DELETE',
          headers: {
            'X-CSRF-Token': csrfToken
          }
        });
        
        if (!response.ok) throw new Error('Failed to delete donation');
        
        showMessage('Donation deleted successfully', 'success');
        refreshDonations();
        
        // Refresh stats for the affected user
        if (affectedUserId) {
          await refreshDonationStatsForUser(affectedUserId);
        }
        
        // Mark that donation data needs refresh
        donationDataNeedsRefresh = true;
        
        // If currently on Profile tab, refresh after a short delay
        const activeTab = document.querySelector('.tab-content.active');
        if (activeTab && activeTab.id === 'profile-tab') {
          setTimeout(() => {
            loadUserDonations();
            donationDataNeedsRefresh = false;
          }, 300);
        }
      } catch (error) {
        console.error('Error deleting donation:', error);
        showMessage('Failed to delete donation', 'error');
      }
    }
    
    window.showDonationDetails = showDonationDetails;
    window.unmatchDonation = unmatchDonation;
    window.deleteDonation = deleteDonation;
    
    // Load donation tier progress for user profile
    
    // Donation Management Functions
    let currentDonationsPage = 1;
    let donationsFilter = 'all';
    let donationsSearch = '';
    let donationDataNeedsRefresh = false;
    
    // Helper function to refresh donation stats after changes
    async function refreshDonationStatsForUser(userId) {
      try {
        const csrfToken = await getCSRFToken();
        await fetch('/api/donations/admin/reset-user-donations', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRF-Token': csrfToken
          },
          body: JSON.stringify({ userId: userId || currentUser.id })
        });
      } catch (error) {
        console.error('Failed to refresh donation stats:', error);
      }
    }
    
    function updateTierProgress(progress) {
      // Update current amount
      document.getElementById('progress-current-amount').textContent = progress.totalDonated.toFixed(0);
      
      // Update current tier badge
      if (progress.currentTier) {
        const badgeEl = document.getElementById('current-tier-badge');
        badgeEl.style.display = 'flex';
        badgeEl.style.borderColor = progress.currentTier.color;
        
        const iconEl = document.getElementById('current-tier-icon');
        iconEl.textContent = progress.currentTier.icon || '';
        iconEl.style.color = progress.currentTier.color;
        
        const nameEl = document.getElementById('current-tier-name');
        nameEl.textContent = progress.currentTier.name;
        nameEl.style.color = progress.currentTier.color;
      } else {
        document.getElementById('current-tier-badge').style.display = 'none';
      }
      
      // Update progress bar and next tier info
      if (progress.nextTier) {
        document.getElementById('next-tier-name').textContent = progress.nextTier.name;
        document.getElementById('next-tier-amount').textContent = progress.nextTier.requiredAmount.toFixed(0);
        document.getElementById('user-tier-progress-bar').style.width = progress.progressPercent + '%';
        document.getElementById('progress-percentage').textContent = Math.round(progress.progressPercent);
        document.getElementById('tier-complete-message').style.display = 'none';
        
        // Update next tier info color
        document.getElementById('next-tier-info').style.color = progress.nextTier.color;
        
        // For users with 0 donations, show special message
        if (progress.totalDonated === 0) {
          document.getElementById('progress-current-amount').textContent = '0';
          document.getElementById('next-tier-amount').textContent = progress.nextTier.requiredAmount.toFixed(0);
        }
      } else {
        // User has reached the highest tier
        document.getElementById('next-tier-name').textContent = 'Max Tier';
        document.getElementById('next-tier-amount').textContent = progress.totalDonated.toFixed(0);
        document.getElementById('user-tier-progress-bar').style.width = '100%';
        document.getElementById('progress-percentage').textContent = '100';
        document.getElementById('tier-complete-message').style.display = 'block';
        document.getElementById('next-tier-perks').style.display = 'none';
      }
      
      // Add hover effect to show perks tooltip
      const nextTierInfo = document.getElementById('next-tier-info');
      const perksTooltip = document.getElementById('next-tier-perks');
      
      nextTierInfo.onmouseenter = async (e) => {
        if (progress.nextTier) {
          // Load perks only when hovering
          const hasPerks = await loadNextTierPerks(progress.nextTier.id);
          if (hasPerks) {
            // Show tooltip first to get its dimensions
            perksTooltip.style.display = 'block';
            
            // Position tooltip near the element
            const rect = nextTierInfo.getBoundingClientRect();
            const tooltipHeight = perksTooltip.offsetHeight;
            const tooltipWidth = perksTooltip.offsetWidth;
            
            // Calculate position relative to viewport
            let top = rect.bottom + 5; // Default: below the element
            let left = rect.left;
            
            // Check if tooltip would go off bottom of screen
            if (top + tooltipHeight > window.innerHeight) {
              // Show above instead
              top = rect.top - tooltipHeight - 5;
            }
            
            // Check if tooltip would go off right side of screen
            if (left + tooltipWidth > window.innerWidth) {
              left = window.innerWidth - tooltipWidth - 10;
            }
            
            // Ensure tooltip doesn't go off left side
            if (left < 10) {
              left = 10;
            }
            
            // Use fixed positioning relative to viewport
            perksTooltip.style.position = 'fixed';
            perksTooltip.style.top = top + 'px';
            perksTooltip.style.left = left + 'px';
          }
        }
      };
      
      nextTierInfo.onmouseleave = () => {
        perksTooltip.style.display = 'none';
      };
    }
    
    async function loadNextTierPerks(tierId) {
      try {
        const response = await fetch('/api/donations/tiers');
        if (!response.ok) return false;
        
        const tiers = await response.json();
        const nextTier = tiers.find(t => t.id === tierId);
        
        if (nextTier && nextTier.perks && nextTier.perks.length > 0) {
          const perksList = document.getElementById('perks-list');
          perksList.innerHTML = nextTier.perks.map(perk => `<li>${escapeHtml(perk)}</li>`).join('');
          return true;
        }
        return false;
      } catch (error) {
        console.error('Error loading tier perks:', error);
        return false;
      }
    }
    
    async function loadUserDonations() {
      const loadingEl = document.getElementById('user-donations-loading');
      const contentEl = document.getElementById('user-donations-content');
      const listEl = document.getElementById('user-donations-list');
      const noDonationsEl = document.getElementById('no-user-donations');
      
      try {
        loadingEl.style.display = 'block';
        contentEl.style.display = 'none';
        
        // Load both donations and tier progress in parallel (with cache busting)
        const timestamp = Date.now();
        const [donationsResponse, progressResponse] = await Promise.all([
          fetch(`/api/donations?user_id=${currentUser.id}&limit=100&_t=${timestamp}`),
          fetch(`/api/donations/user-progress?_t=${timestamp}`)
        ]);
        
        if (!donationsResponse.ok) throw new Error('Failed to load donations');
        if (!progressResponse.ok) throw new Error('Failed to load progress');
        
        const data = await donationsResponse.json();
        const donations = data.donations || [];
        const progress = await progressResponse.json();
        
        
        loadingEl.style.display = 'none';
        contentEl.style.display = 'block';
        
        // Update tier progress
        updateTierProgress(progress);
        
        if (donations.length === 0) {
          listEl.style.display = 'none';
          noDonationsEl.style.display = 'block';
          document.getElementById('donation-nickname-hint').textContent = currentUser.nickname || currentUser.name;
          document.getElementById('user-total-donated').textContent = '0.00';
          document.getElementById('user-donation-count').textContent = '0';
          document.getElementById('user-donation-plural').textContent = 's';
        } else {
          listEl.style.display = 'block';
          noDonationsEl.style.display = 'none';
          
          // Calculate total
          const total = donations.reduce((sum, d) => sum + parseFloat(d.amount), 0);
          document.getElementById('user-total-donated').textContent = total.toFixed(2);
          document.getElementById('user-donation-count').textContent = donations.length;
          document.getElementById('user-donation-plural').textContent = donations.length === 1 ? '' : 's';
          
          // Build table
          const tableHTML = `
            <table class="admin-table" style="width: 100%;">
              <thead>
                <tr>
                  <th>Date</th>
                  <th>Amount</th>
                  <th>Type</th>
                  <th>Message</th>
                </tr>
              </thead>
              <tbody>
                ${donations.map(d => `
                  <tr>
                    <td>${new Date(d.timestamp).toLocaleDateString()}</td>
                    <td style="color: #FFD700; font-weight: bold;">$${parseFloat(d.amount).toFixed(2)}</td>
                    <td>${d.type}</td>
                    <td>${d.message ? escapeHtml(d.message) : '<span style="color: #666;">-</span>'}</td>
                  </tr>
                `).join('')}
              </tbody>
            </table>
          `;
          
          document.getElementById('user-donations-table-container').innerHTML = tableHTML;
        }
      } catch (error) {
        console.error('Error loading user donations:', error);
        loadingEl.style.display = 'none';
        contentEl.style.display = 'block';
        contentEl.innerHTML = '<p style="color: #dc3545;">Error loading donations. Please try again later.</p>';
      }
    }
    
    async function loadDonationsManagement() {
      const section = document.getElementById('donations-management-section');
      // Only skip if already loaded and visible
      if (section.dataset.loaded === 'true' && !section.classList.contains('collapsed')) {
        return;
      }
      
      const loadingEl = document.getElementById('donations-management-loading');
      const contentEl = document.getElementById('donations-management-content');
      
      try {
        loadingEl.style.display = 'block';
        contentEl.style.display = 'none';
        
        // Load statistics
        const statsResponse = await fetch('/api/donations/stats');
        if (statsResponse.ok) {
          const { stats } = await statsResponse.json();
          document.getElementById('total-donation-amount').textContent = parseFloat(stats.total_amount).toFixed(2);
          document.getElementById('total-donation-count').textContent = stats.total_donations;
          document.getElementById('unique-donors-count').textContent = stats.unique_donors;
          document.getElementById('unmatched-donations-count').textContent = stats.unmatched_donations;
        }
        
        // Load donations
        await loadDonationsList();
        
        loadingEl.style.display = 'none';
        contentEl.style.display = 'block';
        section.dataset.loaded = 'true';
      } catch (error) {
        console.error('Error loading donations management:', error);
        loadingEl.style.display = 'none';
        contentEl.style.display = 'block';
        contentEl.innerHTML = '<p style="color: #dc3545;">Error loading donations data. Please try again later.</p>';
      }
    }
    
    async function loadDonationsList() {
      try {
        let url = `/api/donations?page=${currentDonationsPage}&limit=20`;
        if (donationsFilter === 'unmatched') {
          url += '&unmatched=true';
        }
        
        const response = await fetch(url);
        if (!response.ok) throw new Error('Failed to load donations');
        
        const data = await response.json();
        const donations = data.donations || [];
        const pagination = data.pagination;
        
        // Filter by search if needed
        let filteredDonations = donations;
        if (donationsSearch) {
          const searchLower = donationsSearch.toLowerCase();
          filteredDonations = donations.filter(d => 
            d.from_name.toLowerCase().includes(searchLower)
          );
        }
        
        // Update table
        const tbody = document.getElementById('donations-tbody');
        if (filteredDonations.length === 0) {
          tbody.innerHTML = '<tr><td colspan="7" style="text-align: center; color: #999;">No donations found</td></tr>';
        } else {
          tbody.innerHTML = filteredDonations.map(d => `
            <tr>
              <td>${new Date(d.timestamp).toLocaleDateString()}</td>
              <td>${escapeHtml(d.from_name)}</td>
              <td style="color: #FFD700; font-weight: bold;">$${parseFloat(d.amount).toFixed(2)}</td>
              <td>${d.type}</td>
              <td>${d.message ? `<span title="${escapeHtml(d.message)}">${escapeHtml(d.message.substring(0, 50))}${d.message.length > 50 ? '...' : ''}</span>` : '<span style="color: #666;">-</span>'}</td>
              <td>
                ${d.user_id ? `
                  <a href="#" onclick="showUserDetail(${d.user_id}); return false;" style="color: #4a7c59;">
                    ${escapeHtml(d.user_name || d.user_nickname || 'User #' + d.user_id)}
                  </a>
                  <span style="color: #666; font-size: 0.85rem;">(${d.matched_by})</span>
                ` : `
                  <span style="color: #dc3545;">Unmatched</span>
                  <button class="small-btn" style="margin-left: 0.5rem; padding: 0.25rem 0.5rem; font-size: 0.85rem;" 
                          onclick="showDonationMatchModal(${d.id})">
                    Assign
                  </button>
                `}
              </td>
              <td>
                <div style="display: flex; gap: 0.25rem; justify-content: center;">
                  ${d.user_id ? `
                    <button class="action-btn" onclick="showDonationDetails(${d.id})" title="View details">
                      
                    </button>
                    <button class="action-btn" onclick="unmatchDonation(${d.id})" title="Unmatch from user">
                      
                    </button>
                  ` : ''}
                  <button class="action-btn" onclick="deleteDonation(${d.id})" title="Delete donation" style="color: #dc3545;">
                    
                  </button>
                </div>
              </td>
            </tr>
          `).join('');
        }
        
        // Update pagination
        const paginationEl = document.getElementById('donations-pagination');
        if (pagination && pagination.pages > 1) {
          paginationEl.style.display = 'flex';
          document.getElementById('donations-page-info').textContent = `Page ${pagination.page} of ${pagination.pages}`;
          document.getElementById('donations-prev').disabled = pagination.page <= 1;
          document.getElementById('donations-next').disabled = pagination.page >= pagination.pages;
          
          document.getElementById('donations-prev').onclick = () => {
            if (currentDonationsPage > 1) {
              currentDonationsPage--;
              loadDonationsList();
            }
          };
          
          document.getElementById('donations-next').onclick = () => {
            if (currentDonationsPage < pagination.pages) {
              currentDonationsPage++;
              loadDonationsList();
            }
          };
        } else {
          paginationEl.style.display = 'none';
        }
      } catch (error) {
        console.error('Error loading donations list:', error);
        document.getElementById('donations-tbody').innerHTML = '<tr><td colspan="7" style="text-align: center; color: #dc3545;">Error loading donations</td></tr>';
      }
    }
    
    function refreshDonations() {
      currentDonationsPage = 1;
      loadDonationsList();
      // Also refresh stats
      loadDonationsManagement();
    }
    
    // Event listeners for filters
    document.getElementById('donation-search').addEventListener('input', (e) => {
      donationsSearch = e.target.value;
      loadDonationsList();
    });
    
    document.getElementById('donation-filter').addEventListener('change', (e) => {
      donationsFilter = e.target.value;
      currentDonationsPage = 1;
      loadDonationsList();
    });
    
    // Donation matching functions
    async function showDonationMatchModal(donationId) {
      // First fetch the full donation details
      try {
        const response = await fetch(`/api/donations?limit=1000`);
        if (!response.ok) throw new Error('Failed to fetch donations');
        
        const data = await response.json();
        const donation = data.donations.find(d => d.id === donationId);
        
        if (!donation) {
          showMessage('Donation not found', 'error');
          return;
        }
        
        // Update the modal to show more information
        const modalContent = document.querySelector('#donation-match-modal .modal-body');
        const donationDetailsHtml = `
          <div style="background: #2d2d2d; padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem;">
            <h4 style="color: #FFD700; margin-top: 0;">Donation Details</h4>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
              <div>
                <p style="margin: 0.5rem 0;"><strong>Donor Name:</strong> <span id="match-donor-name">${escapeHtml(donation.from_name)}</span></p>
                <p style="margin: 0.5rem 0;"><strong>Amount:</strong> <span id="match-donation-amount" style="color: #FFD700;">$${parseFloat(donation.amount).toFixed(2)}</span></p>
                <p style="margin: 0.5rem 0;"><strong>Currency:</strong> ${donation.currency}</p>
                <p style="margin: 0.5rem 0;"><strong>Date:</strong> <span id="match-donation-date">${new Date(donation.timestamp).toLocaleDateString()}</span></p>
              </div>
              <div>
                ${donation.email ? `<p style="margin: 0.5rem 0;"><strong>Email:</strong> ${escapeHtml(donation.email)}</p>` : ''}
                <p style="margin: 0.5rem 0;"><strong>Type:</strong> ${donation.type}</p>
                <p style="margin: 0.5rem 0;"><strong>Public:</strong> ${donation.is_public ? 'Yes' : 'No'}</p>
                ${donation.is_subscription ? `<p style="margin: 0.5rem 0;"><strong>Subscription:</strong> Yes</p>` : ''}
              </div>
            </div>
            ${donation.message ? `
              <div style="margin-top: 1rem;">
                <p style="margin: 0.5rem 0 0.25rem 0;"><strong>Message:</strong></p>
                <div style="background: #1a1a1a; padding: 0.75rem; border-radius: 4px;">
                  ${escapeHtml(donation.message)}
                </div>
              </div>
            ` : ''}
            ${donation.kofi_transaction_id ? `
              <p style="margin: 0.5rem 0; font-size: 0.85rem; color: #999;">
                <strong>Transaction ID:</strong> <code>${escapeHtml(donation.kofi_transaction_id)}</code>
              </p>
            ` : ''}
          </div>
          
          <div>
            <label style="display: block; color: #e0e0e0; margin-bottom: 0.5rem;">Search for User to Match</label>
            <input type="text" id="match-user-search" placeholder="Search by name, nickname, or email..." 
                   style="width: 100%; padding: 0.5rem; border: 1px solid #555; border-radius: 4px; 
                          background: #2d2d2d; color: #e0e0e0; margin-bottom: 1rem;"
                   onkeyup="searchUsersForMatch(this.value)">
            
            <div id="match-user-results" style="max-height: 300px; overflow-y: auto;">
              <!-- User search results will appear here -->
            </div>
          </div>
          
          <input type="hidden" id="match-donation-id" value="${donationId}">
          <input type="hidden" id="match-selected-user-id">
          
          <div style="display: flex; gap: 0.5rem; justify-content: flex-end; margin-top: 1.5rem;">
            <button class="btn secondary-btn" onclick="closeDonationMatchModal()">Cancel</button>
            <button class="btn" onclick="confirmDonationMatch()" id="confirm-match-btn" disabled>Match to User</button>
          </div>
        `;
        
        modalContent.innerHTML = donationDetailsHtml;
        
        // Show the modal
        document.getElementById('donation-match-modal').style.display = 'block';
        
        // Pre-populate search with donor name or email to help find matches
        const searchInput = document.getElementById('match-user-search');
        if (donation.email) {
          searchInput.value = donation.email;
          searchUsersForMatch(donation.email);
        } else {
          searchInput.value = donation.from_name;
          searchUsersForMatch(donation.from_name);
        }
        
      } catch (error) {
        console.error('Error loading donation for matching:', error);
        showMessage('Failed to load donation details', 'error');
      }
    }
    
    function closeDonationMatchModal() {
      document.getElementById('donation-match-modal').style.display = 'none';
    }
    
    async function searchUsersForMatch(query) {
      if (query.length < 2) {
        document.getElementById('match-user-results').innerHTML = '';
        return;
      }
      
      try {
        const response = await fetch(`/api/users/search?q=${encodeURIComponent(query)}`);
        if (!response.ok) throw new Error('Search failed');
        
        const users = await response.json();
        const resultsEl = document.getElementById('match-user-results');
        
        if (users.length === 0) {
          resultsEl.innerHTML = '<p style="text-align: center; color: #999; padding: 1rem;">No users found</p>';
        } else {
          resultsEl.innerHTML = users.map(user => `
            <div class="user-match-option" style="padding: 0.75rem; border: 1px solid #444; border-radius: 4px; margin-bottom: 0.5rem; cursor: pointer; transition: all 0.2s;"
                 onmouseover="this.style.background='#3a3a3a'" 
                 onmouseout="this.style.background='transparent'"
                 onclick="selectUserForMatch(${user.id}, '${escapeHtml(user.name)}')">
              <div style="display: flex; align-items: center; gap: 0.75rem;">
                <img src="${user.picture || ''}" style="width: 40px; height: 40px; border-radius: 50%; object-fit: cover; background: #3a3a3a;" onerror="this.style.display='none'">
                <div>
                  <div style="font-weight: bold; color: #e0e0e0;">${escapeHtml(user.name)}</div>
                  ${user.nickname ? `<div style="color: #999; font-size: 0.9rem;">@${escapeHtml(user.nickname)}</div>` : ''}
                  <div style="color: #666; font-size: 0.85rem;">${escapeHtml(user.email)}</div>
                </div>
              </div>
            </div>
          `).join('');
        }
      } catch (error) {
        console.error('Error searching users:', error);
        document.getElementById('match-user-results').innerHTML = '<p style="text-align: center; color: #dc3545;">Error searching users</p>';
      }
    }
    
    function selectUserForMatch(userId, userName) {
      document.getElementById('match-selected-user-id').value = userId;
      document.getElementById('confirm-match-btn').disabled = false;
      document.getElementById('confirm-match-btn').textContent = `Match to ${userName}`;
      
      // Highlight selected user
      const options = document.querySelectorAll('.user-match-option');
      options.forEach(opt => opt.style.border = '1px solid #444');
      event.currentTarget.style.border = '2px solid #4a7c59';
    }
    
    async function confirmDonationMatch() {
      const donationId = document.getElementById('match-donation-id').value;
      const userId = document.getElementById('match-selected-user-id').value;
      
      if (!donationId || !userId) return;
      
      try {
        const csrfToken = await getCSRFToken();
        const response = await fetch(`/api/donations/${donationId}/match`, {
          method: 'PATCH',
          headers: { 
            'Content-Type': 'application/json',
            'X-CSRF-Token': csrfToken 
          },
          body: JSON.stringify({ user_id: parseInt(userId) })
        });
        
        if (!response.ok) throw new Error('Failed to match donation');
        
        showMessage('Donation successfully matched to user', 'success');
        closeDonationMatchModal();
        refreshDonations();
        
        // Refresh stats for the newly matched user
        await refreshDonationStatsForUser(parseInt(userId));
        
        // Mark that donation data needs refresh
        donationDataNeedsRefresh = true;
        
        // If currently on Profile tab, refresh after a short delay
        const activeTab = document.querySelector('.tab-content.active');
        if (activeTab && activeTab.id === 'profile-tab') {
          setTimeout(() => {
            loadUserDonations();
            donationDataNeedsRefresh = false;
          }, 300);
        }
      } catch (error) {
        console.error('Error matching donation:', error);
        showMessage('Error matching donation. Please try again.', 'error');
      }
    }
    
    // Update admin section toggle to load donations when opened
    const originalToggleAdminSection = window.toggleAdminSection;
    window.toggleAdminSection = function(sectionId) {
      originalToggleAdminSection(sectionId);
      
      if (sectionId === 'donations-management-section') {
        const section = document.getElementById(sectionId);
        if (!section.classList.contains('collapsed')) {
          loadDonationsManagement();
        }
      }
    };
    
    // Helper function to escape HTML
    function formatDescription(text) {
      if (!text) return '';
      
      // First escape HTML to prevent XSS
      let escaped = text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
      
      // Then convert URLs to clickable links
      // Match URLs starting with http://, https://, or www.
      const urlPattern = /(\b(https?:\/\/|www\.)[^\s<]+)/gi;
      escaped = escaped.replace(urlPattern, (match) => {
        let url = match;
        // Add protocol if missing
        if (url.startsWith('www.')) {
          url = 'https://' + url;
        }
        return `<a href="${url}" target="_blank" rel="noopener noreferrer" style="color: #60a5fa; text-decoration: underline;">${match}</a>`;
      });
      
      // Convert line breaks to <br>
      escaped = escaped.replace(/\n/g, '<br>');
      
      return escaped;
    }
    
    function escapeHtml(text) {
      if (!text) return '';
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    
    // Show user details in a modal
    function showUserDetail(userId) {
      // Always fetch fresh data to ensure we have the latest donation info
      fetch(`/api/users/${userId}`)
        .then(response => {
          if (!response.ok) {
            throw new Error('Failed to fetch user');
          }
          return response.json();
        })
        .then(userData => {
          displayUserDetailModal(userData);
        })
        .catch(error => {
          console.error('Error loading user details:', error);
          showMessage('Failed to load user details', 'error');
        });
    }
    
    function displayUserDetailModal(user) {
      const modal = document.createElement('div');
      modal.className = 'modal-overlay';
      modal.innerHTML = `
        <div class="modal-content" style="max-width: 600px;">
          <div class="modal-header">
            <h3>User Details</h3>
            <button class="close-btn" onclick="this.closest('.modal-overlay').remove()">&times;</button>
          </div>
          <div class="modal-body">
            <div style="display: flex; align-items: center; gap: 1rem; margin-bottom: 1.5rem;">
              ${user.picture ? `<img src="${user.picture}" style="width: 60px; height: 60px; border-radius: 50%; object-fit: cover;">` : ''}
              <div>
                <h4 style="margin: 0; color: #FFD700;">${escapeHtml(user.name)}</h4>
                ${user.nickname ? `<div style="color: #999;">@${escapeHtml(user.nickname)}</div>` : ''}
                <div style="color: #666; font-size: 0.9rem;">${escapeHtml(user.email)}</div>
              </div>
            </div>
            
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem;">
              <div style="background: #2d2d2d; padding: 1rem; border-radius: 8px;">
                <div style="color: #999; font-size: 0.85rem;">Total Donated</div>
                <div style="color: #FFD700; font-size: 1.5rem; font-weight: bold;">
                  $${parseFloat(user.total_donated || 0).toFixed(2)}
                </div>
              </div>
              
              <div style="background: #2d2d2d; padding: 1rem; border-radius: 8px;">
                <div style="color: #999; font-size: 0.85rem;">Current Tier</div>
                <div style="font-size: 1.2rem;">
                  ${user.current_donation_tier_id ? `<span style="color: ${user.tier_color || '#FFD700'}">${user.tier_icon || ''} ${user.tier_name || 'Supporter'}</span>` : '<span style="color: #666;">None</span>'}
                </div>
              </div>
              
              <div style="background: #2d2d2d; padding: 1rem; border-radius: 8px;">
                <div style="color: #999; font-size: 0.85rem;">Account Created</div>
                <div>${new Date(user.created_at).toLocaleDateString()}</div>
              </div>
              
              <div style="background: #2d2d2d; padding: 1rem; border-radius: 8px;">
                <div style="color: #999; font-size: 0.85rem;">Last Donation</div>
                <div>${user.last_donation_date ? new Date(user.last_donation_date).toLocaleDateString() : '<span style="color: #666;">Never</span>'}</div>
              </div>
              
              <div style="background: #2d2d2d; padding: 1rem; border-radius: 8px;">
                <div style="color: #999; font-size: 0.85rem;">User ID</div>
                <div>#${user.id}</div>
              </div>
              
              <div style="background: #2d2d2d; padding: 1rem; border-radius: 8px;">
                <div style="color: #999; font-size: 0.85rem;">Status</div>
                <div>${user.is_admin ? '<span style="color: #ff6b6b;">Admin</span>' : '<span style="color: #4ade80;">User</span>'}</div>
              </div>
            </div>
            
            <div style="margin-top: 1.5rem; display: flex; gap: 1rem; justify-content: flex-end;">
              <button onclick="this.closest('.modal-overlay').remove()" class="btn btn-primary">Close</button>
            </div>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
    }
    
    window.showUserDetail = showUserDetail;
    
    // Navigate to user management tab with specific user
    function viewFullUserProfile(userId) {
      // Close the modal first
      const modal = document.querySelector('.modal-overlay');
      if (modal) modal.remove();
      
      // Switch to admin tab
      document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
      });
      
      const adminTab = document.querySelector('.tab-btn[onclick*="admin"]');
      const adminContent = document.getElementById('admin-tab');
      
      if (adminTab && adminContent) {
        adminTab.classList.add('active');
        adminContent.classList.add('active');
        
        // Expand the user management section
        const userSection = document.getElementById('user-management-section');
        if (userSection && userSection.classList.contains('collapsed')) {
          toggleAdminSection('user-management-section');
        }
        
        // Load users if not already loaded
        if (!allUsers || allUsers.length === 0) {
          loadUsers();
        }
        
        // Wait a bit for users to load, then find and highlight the user
        setTimeout(() => {
          // Find the user in the list
          const targetUser = allUsers.find(u => u.id === userId);
          if (targetUser) {
            const searchInput = document.getElementById('user-search');
            if (searchInput) {
              // Search by the user's name
              searchInput.value = targetUser.name;
              searchUsers();
            }
          }
          
          // After search/display completes, highlight the user
          setTimeout(() => {
            const userRows = document.querySelectorAll('#users-tbody tr');
            userRows.forEach((row, index) => {
              // Look for the user ID in the row's data
              const avatarImg = row.querySelector('img');
              if (avatarImg && avatarImg.dataset.userId == userId) {
                row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                row.style.backgroundColor = '#3a4a3a';
                row.style.transition = 'background-color 0.3s';
                setTimeout(() => {
                  row.style.backgroundColor = '';
                }, 3000);
              }
            });
          }, 500);
        }, 500);
      }
    }
    window.viewFullUserProfile = viewFullUserProfile;
    
    // Race/Class Selector Modal Functions
    let currentRaceClassField = null;
    let currentRaceClassType = null;
    let currentRaceClassItem = null;
    let currentRaceClassInput = null;
    
    function openRaceClassModal(type, item, inputElement) {
      currentRaceClassType = type;
      currentRaceClassItem = item;
      currentRaceClassInput = inputElement;
      
      const modal = document.getElementById('race-class-selector-modal');
      const title = document.getElementById('race-class-modal-title');
      const selectAllLabel = document.getElementById('race-class-select-all-label');
      const optionsContainer = document.getElementById('race-class-options');
      
      // Set title
      title.textContent = type === 'race' ? 'Select Races' : 'Select Classes';
      selectAllLabel.textContent = type === 'race' ? 'Select All Races' : 'Select All Classes';
      
      // Clear previous options
      optionsContainer.innerHTML = '';
      
      // Get current selections
      const currentValue = item[type] || 'ALL';
      const selectedCodes = currentValue === 'ALL' ? [] : currentValue.split(' ');
      const isAllSelected = currentValue === 'ALL';
      
      // Get abbreviations
      const abbreviations = type === 'race' ? RACE_ABBREVIATIONS : CLASS_ABBREVIATIONS;
      
      // Create options
      Object.entries(abbreviations).forEach(([code, name]) => {
        if (code === 'ALL') return; // Skip ALL option
        
        const option = document.createElement('div');
        option.className = 'race-class-option';
        const isSelected = isAllSelected || selectedCodes.includes(code);
        if (isSelected) option.classList.add('selected');
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `${type}-${code}`;
        checkbox.checked = isSelected;
        checkbox.onchange = () => updateRaceClassSelection();
        
        const label = document.createElement('label');
        label.setAttribute('for', `${type}-${code}`);
        label.innerHTML = `
          <span class="code">${code}</span>
          <span class="name">${name}</span>
        `;
        
        option.appendChild(checkbox);
        option.appendChild(label);
        option.onclick = (e) => {
          if (e.target === option || e.target === label) {
            checkbox.checked = !checkbox.checked;
            updateRaceClassSelection();
          }
        };
        
        optionsContainer.appendChild(option);
      });
      
      // Set select all checkbox
      document.getElementById('race-class-select-all-checkbox').checked = isAllSelected;
      
      // Update count
      updateRaceClassCount();
      
      // Show modal
      modal.style.display = 'flex';
      document.body.style.overflow = 'hidden';
    }
    
    function closeRaceClassModal() {
      const modal = document.getElementById('race-class-selector-modal');
      modal.style.display = 'none';
      document.body.style.overflow = '';
      currentRaceClassField = null;
      currentRaceClassType = null;
      currentRaceClassItem = null;
      currentRaceClassInput = null;
    }
    
    function toggleAllRaceClass() {
      const selectAllCheckbox = document.getElementById('race-class-select-all-checkbox');
      const allCheckboxes = document.querySelectorAll('#race-class-options input[type="checkbox"]');
      
      allCheckboxes.forEach(cb => {
        cb.checked = selectAllCheckbox.checked;
      });
      
      updateRaceClassSelection();
    }
    
    function updateRaceClassSelection() {
      const allCheckboxes = document.querySelectorAll('#race-class-options input[type="checkbox"]');
      const checkedBoxes = document.querySelectorAll('#race-class-options input[type="checkbox"]:checked');
      const selectAllCheckbox = document.getElementById('race-class-select-all-checkbox');
      
      // Update select all checkbox
      selectAllCheckbox.checked = allCheckboxes.length === checkedBoxes.length;
      
      // Update visual selection
      allCheckboxes.forEach(cb => {
        const option = cb.closest('.race-class-option');
        if (cb.checked) {
          option.classList.add('selected');
        } else {
          option.classList.remove('selected');
        }
      });
      
      updateRaceClassCount();
    }
    
    function updateRaceClassCount() {
      const checkedBoxes = document.querySelectorAll('#race-class-options input[type="checkbox"]:checked');
      const allCheckboxes = document.querySelectorAll('#race-class-options input[type="checkbox"]');
      const countEl = document.getElementById('race-class-selection-count');
      
      if (checkedBoxes.length === allCheckboxes.length) {
        countEl.textContent = 'All selected';
      } else {
        countEl.textContent = `${checkedBoxes.length} selected`;
      }
    }
    
    function applyRaceClassSelection() {
      if (!currentRaceClassItem || !currentRaceClassType) return;
      
      const checkedBoxes = document.querySelectorAll('#race-class-options input[type="checkbox"]:checked');
      const allCheckboxes = document.querySelectorAll('#race-class-options input[type="checkbox"]');
      
      let newValue;
      if (checkedBoxes.length === 0 || checkedBoxes.length === allCheckboxes.length) {
        newValue = 'ALL';
      } else {
        const codes = Array.from(checkedBoxes).map(cb => cb.id.replace(`${currentRaceClassType}-`, ''));
        newValue = codes.join(' ');
      }
      
      // Update the item
      currentRaceClassItem[currentRaceClassType] = newValue;
      
      // Update the display
      if (currentRaceClassInput) {
        // Check if this is in the item editor or batch import
        if (currentRaceClassInput.classList.contains('race-display') || 
            currentRaceClassInput.classList.contains('class-display')) {
          // Item editor context
          const isAllSelected = newValue === 'ALL';
          const codes = isAllSelected ? [] : newValue.split(' ');
          const abbreviations = currentRaceClassType === 'race' ? RACE_ABBREVIATIONS : CLASS_ABBREVIATIONS;
          
          if (isAllSelected) {
            currentRaceClassInput.textContent = currentRaceClassType === 'race' ? 'All Races' : 'All Classes';
            currentRaceClassInput.title = '';
          } else if (codes.length > 3) {
            currentRaceClassInput.textContent = `${codes.length} ${currentRaceClassType}${codes.length > 1 ? 'es' : ''} selected`;
            currentRaceClassInput.title = codes.map(code => abbreviations[code] || code).join(', ');
          } else {
            currentRaceClassInput.textContent = codes.map(code => abbreviations[code] || code).join(', ');
            currentRaceClassInput.title = '';
          }
          
          // Stage the change in item editor
          if (typeof stageItemChange === 'function') {
            stageItemChange(currentRaceClassItem.id, currentRaceClassType, newValue === 'ALL' ? null : newValue);
          }
        } else {
          // Batch import context - just update the display
          currentRaceClassInput.textContent = formatRaceClassDisplay(newValue, currentRaceClassType);
        }
      }
      
      closeRaceClassModal();
    }
    
    function formatRaceClassDisplay(value, type) {
      if (!value || value === 'ALL') return 'All';
      
      const codes = value.split(' ');
      const abbreviations = type === 'race' ? RACE_ABBREVIATIONS : CLASS_ABBREVIATIONS;
      
      if (codes.length <= 3) {
        return codes.join(', ');
      } else {
        const plural = type === 'class' ? 'classes' : 'races';
        return `${codes.length} ${plural} selected`;
      }
    }
    
    // Close modal on escape
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && document.getElementById('race-class-selector-modal').style.display === 'flex') {
        closeRaceClassModal();
      }
    });
    
    // Close modal on outside click
    const raceClassModal = document.getElementById('race-class-selector-modal');
    if (raceClassModal) {
      raceClassModal.addEventListener('click', (e) => {
        if (e.target === e.currentTarget) {
          closeRaceClassModal();
        }
      });
    }
    
    // Resistance modal functionality
    let currentResistanceItem = null;
    let currentResistanceDisplay = null;
    
    function openResistanceModal(item, displayElement, resistanceCount) {
      currentResistanceItem = item;
      currentResistanceDisplay = displayElement;
      
      // Create modal if it doesn't exist
      let modal = document.getElementById('resistance-editor-modal');
      if (!modal) {
        modal = document.createElement('div');
        modal.id = 'resistance-editor-modal';
        modal.className = 'modal';
        modal.style.cssText = 'display: none; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5);';
        
        const modalContent = document.createElement('div');
        modalContent.className = 'modal-content';
        modalContent.style.cssText = 'background-color: #1a1a1a; margin: 10% auto; padding: 20px; border: 1px solid #555; width: 400px; max-width: 80%; border-radius: 8px;';
        
        modalContent.innerHTML = `
          <div class="modal-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h2 style="margin: 0; color: #60a5fa;">Edit Resistances</h2>
            <button class="close-btn" onclick="closeResistanceModal()" style="background: none; border: none; color: #999; font-size: 28px; cursor: pointer;">&times;</button>
          </div>
          <div class="modal-body">
            <div class="resistance-editor-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
              <div class="resistance-field">
                <label style="display: block; margin-bottom: 5px; color: #e0e0e0; font-size: 0.9rem;">Fire Resistance</label>
                <input type="number" id="resist-fire-input" class="form-control" style="width: 100%; background: #2d2d2d; border: 1px solid #555; color: #e0e0e0; padding: 8px; border-radius: 4px;" min="-999" max="999" step="1">
              </div>
              <div class="resistance-field">
                <label style="display: block; margin-bottom: 5px; color: #e0e0e0; font-size: 0.9rem;">Ice Resistance</label>
                <input type="number" id="resist-ice-input" class="form-control" style="width: 100%; background: #2d2d2d; border: 1px solid #555; color: #e0e0e0; padding: 8px; border-radius: 4px;" min="-999" max="999" step="1">
              </div>
              <div class="resistance-field">
                <label style="display: block; margin-bottom: 5px; color: #e0e0e0; font-size: 0.9rem;">Disease Resistance</label>
                <input type="number" id="resist-disease-input" class="form-control" style="width: 100%; background: #2d2d2d; border: 1px solid #555; color: #e0e0e0; padding: 8px; border-radius: 4px;" min="-999" max="999" step="1">
              </div>
              <div class="resistance-field">
                <label style="display: block; margin-bottom: 5px; color: #e0e0e0; font-size: 0.9rem;">Poison Resistance</label>
                <input type="number" id="resist-poison-input" class="form-control" style="width: 100%; background: #2d2d2d; border: 1px solid #555; color: #e0e0e0; padding: 8px; border-radius: 4px;" min="-999" max="999" step="1">
              </div>
              <div class="resistance-field" style="grid-column: span 2;">
                <label style="display: block; margin-bottom: 5px; color: #e0e0e0; font-size: 0.9rem;">Magic Resistance</label>
                <input type="number" id="resist-magic-input" class="form-control" style="width: 100%; background: #2d2d2d; border: 1px solid #555; color: #e0e0e0; padding: 8px; border-radius: 4px;" min="-999" max="999" step="1">
              </div>
            </div>
            <div class="modal-footer" style="margin-top: 20px; display: flex; justify-content: flex-end; gap: 10px;">
              <button class="btn secondary-btn" onclick="closeResistanceModal()">Cancel</button>
              <button class="btn primary-btn" onclick="saveResistances()">Save</button>
            </div>
          </div>
        `;
        
        modal.appendChild(modalContent);
        document.body.appendChild(modal);
        
        // Close on outside click
        modal.addEventListener('click', (e) => {
          if (e.target === modal) {
            closeResistanceModal();
          }
        });
      }
      
      // Populate current values
      const resistanceFields = ['resist_fire', 'resist_ice', 'resist_disease', 'resist_poison', 'resist_magic'];
      resistanceFields.forEach(field => {
        const fieldName = field.replace('resist_', '');
        const input = document.getElementById(`resist-${fieldName}-input`);
        if (input) {
          input.value = item[field] || 0;
        }
      });
      
      // Show modal
      modal.style.display = 'block';
      document.body.style.overflow = 'hidden';
    }
    
    function closeResistanceModal() {
      const modal = document.getElementById('resistance-editor-modal');
      if (modal) {
        modal.style.display = 'none';
        document.body.style.overflow = '';
      }
      currentResistanceItem = null;
      currentResistanceDisplay = null;
    }
    
    function saveResistances() {
      if (!currentResistanceItem) return;
      
      const resistanceFields = ['resist_fire', 'resist_ice', 'resist_disease', 'resist_poison', 'resist_magic'];
      let resistanceCount = 0;
      
      resistanceFields.forEach(field => {
        const fieldName = field.replace('resist_', '');
        const input = document.getElementById(`resist-${fieldName}-input`);
        if (input) {
          const value = parseInt(input.value) || 0;
          currentResistanceItem[field] = value;
          if (value !== 0) {
            resistanceCount++;
          }
        }
      });
      
      // Update display
      if (currentResistanceDisplay) {
        if (resistanceCount > 0) {
          currentResistanceDisplay.style.background = '#1a472a';
          currentResistanceDisplay.style.borderColor = '#2e7d32';
          currentResistanceDisplay.innerHTML = `<span style="color: #4caf50; font-weight: bold;">${resistanceCount}</span>`;
          currentResistanceDisplay.title = 'Click to edit resistances';
        } else {
          currentResistanceDisplay.style.background = '#2d2d2d';
          currentResistanceDisplay.style.borderColor = '#555';
          currentResistanceDisplay.innerHTML = '<span style="color: #666;">-</span>';
          currentResistanceDisplay.title = 'Click to add resistances';
        }
      }
      
      closeResistanceModal();
    }
    
    // Close resistance modal on escape
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && document.getElementById('resistance-editor-modal') && 
          document.getElementById('resistance-editor-modal').style.display === 'block') {
        closeResistanceModal();
      }
    });
  </script>

  <!-- Create Proposal Modal -->
  <div id="create-proposal-modal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 600px;">
      <div class="modal-header">
        <h2>Create Change Proposal</h2>
        <button class="close-btn" onclick="closeCreateProposalModal()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>Change Type</label>
          <select id="proposal-change-type" class="form-control" onchange="updateProposalForm()">
            <option value="">Select a type...</option>
            <option value="edit_poi">Edit POI</option>
            <option value="add_npc">New NPC</option>
            <option value="edit_npc">Edit NPC</option>
            <option value="add_item">New Item</option>
            <option value="edit_item">Edit Item</option>
          </select>
        </div>
        
        <div id="proposal-form-content" style="display: none;">
          <!-- Dynamic form content based on change type -->
        </div>
        
        <div class="form-group" style="margin-top: 1rem;">
          <label>Notes / Reason for Change</label>
          <textarea id="proposal-notes" class="form-control" rows="3" placeholder="Explain why this change should be made..."></textarea>
        </div>
        
        <div style="display: flex; gap: 1rem; justify-content: flex-end; margin-top: 1.5rem;">
          <button class="btn secondary-btn" onclick="closeCreateProposalModal()">Cancel</button>
          <button class="btn btn-primary" onclick="submitProposal()">Submit Proposal</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Admin Proposal Review Modal -->
  <div id="admin-proposal-modal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 800px;">
      <div class="modal-header">
        <h2>Admin Review - Change Proposal</h2>
        <button class="close-btn" onclick="closeAdminProposalModal()">&times;</button>
      </div>
      <div class="modal-body" id="admin-proposal-content">
        <!-- Content loaded dynamically -->
      </div>
    </div>
  </div>
  
  <!-- Donation Match Modal -->
  <div id="donation-match-modal" class="modal" style="display: none;">
    <div class="modal-content" style="max-width: 600px;">
      <div class="modal-header">
        <h2>Match Donation to User</h2>
        <button class="close-btn" onclick="closeDonationMatchModal()">&times;</button>
      </div>
      <div class="modal-body">
        <div style="background: #2d2d2d; padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem;">
          <h4 style="color: #FFD700; margin-top: 0;">Donation Details</h4>
          <p><strong>Donor Name:</strong> <span id="match-donor-name"></span></p>
          <p><strong>Amount:</strong> <span id="match-donation-amount" style="color: #FFD700;"></span></p>
          <p><strong>Date:</strong> <span id="match-donation-date"></span></p>
          <div id="match-donation-message-container" style="display: none;">
            <p><strong>Message:</strong></p>
            <div id="match-donation-message" style="background: #1a1a1a; padding: 0.75rem; border-radius: 4px; margin-top: 0.5rem;"></div>
          </div>
        </div>
        
        <div>
          <label style="display: block; color: #e0e0e0; margin-bottom: 0.5rem;">Search for User</label>
          <input type="text" id="match-user-search" placeholder="Search by name, nickname, or email..." 
                 style="width: 100%; padding: 0.5rem; border: 1px solid #555; border-radius: 4px; 
                        background: #2d2d2d; color: #e0e0e0; margin-bottom: 1rem;"
                 onkeyup="searchUsersForMatch(this.value)">
          
          <div id="match-user-results" style="max-height: 300px; overflow-y: auto;">
            <!-- User search results will appear here -->
          </div>
        </div>
        
        <input type="hidden" id="match-donation-id">
        <input type="hidden" id="match-selected-user-id">
        
        <div style="display: flex; gap: 0.5rem; justify-content: flex-end; margin-top: 1.5rem;">
          <button class="btn secondary-btn" onclick="closeDonationMatchModal()">Cancel</button>
          <button class="btn" onclick="confirmDonationMatch()" id="confirm-match-btn" disabled>Match to User</button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Custom Confirmation Dialog -->
  <div id="confirmDialog" class="confirm-dialog-overlay" style="display: none;">
    <div class="confirm-dialog">
      <h3 class="confirm-dialog-title">Confirm Action</h3>
      <p class="confirm-dialog-message"></p>
      <div class="confirm-dialog-buttons">
        <button class="confirm-dialog-btn confirm-dialog-btn-cancel">Cancel</button>
        <button class="confirm-dialog-btn confirm-dialog-btn-confirm">Confirm</button>
      </div>
    </div>
  </div>

  <!-- Batch Import Table Styles -->
  <style>
    /* Batch Import Table Responsive Styles */
    #batch-import-table {
      table-layout: fixed;
      width: 100%;
      min-width: 2000px; /* Increased for much wider modal */
    }
    
    /* Race/Class display in batch import */
    .batch-race-display,
    .batch-class-display {
      transition: all 0.2s;
    }
    
    .batch-race-display:hover,
    .batch-class-display:hover {
      background: #3a3a3a !important;
      border-color: #4a7c59 !important;
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    #batch-import-table th,
    #batch-import-table td {
      padding: 0.5rem 0.25rem;
      position: relative;
      overflow: hidden;
    }
    
    /* Center align all table headers */
    #batch-import-table th {
      text-align: center;
    }
    
    /* Column width adjustments for better readability with wider modal */
    #batch-import-table th:nth-child(1), /* Checkbox */
    #batch-import-table td:nth-child(1) {
      width: 60px;
      text-align: center;
    }
    
    #batch-import-table th:nth-child(2), /* Icon */
    #batch-import-table td:nth-child(2) {
      width: 70px;
      text-align: center;
    }
    
    #batch-import-table th:nth-child(3), /* Name */
    #batch-import-table td:nth-child(3) {
      width: 300px;
      min-width: 300px;
    }
    
    #batch-import-table th:nth-child(4), /* Type */
    #batch-import-table td:nth-child(4) {
      width: 140px;
    }
    
    #batch-import-table th:nth-child(5), /* Slot */
    #batch-import-table td:nth-child(5) {
      width: 140px;
    }
    
    #batch-import-table th:nth-child(6), /* Size */
    #batch-import-table td:nth-child(6) {
      width: 100px;
    }
    
    #batch-import-table th:nth-child(7), /* Weight */
    #batch-import-table td:nth-child(7) {
      width: 90px;
    }
    
    /* Stat columns - comfortable width */
    #batch-import-table .batch-stat-col {
      width: 75px !important;
      min-width: 75px !important;
    }
    
    /* Advanced columns - appropriate widths */
    #batch-import-table .batch-advanced-col:nth-child(15), /* AC */
    #batch-import-table .batch-advanced-col:nth-child(16), /* HP */
    #batch-import-table .batch-advanced-col:nth-child(17) { /* MP */
      width: 80px !important;
    }
    
    #batch-import-table .batch-advanced-col:nth-child(18), /* AS */
    #batch-import-table .batch-advanced-col:nth-child(19), /* DMG */
    #batch-import-table .batch-advanced-col:nth-child(20) { /* Delay */
      width: 85px !important;
    }
    
    #batch-import-table .batch-advanced-col:nth-child(21) { /* Skill */
      width: 150px !important;
    }
    
    #batch-import-table .batch-advanced-col:nth-child(22), /* Race */
    #batch-import-table .batch-advanced-col:nth-child(23) { /* Class */
      width: 160px !important;
    }
    
    /* Description column - takes remaining space */
    #batch-import-table th:nth-last-child(2), /* Description */
    #batch-import-table td:nth-last-child(2) {
      width: auto;
      min-width: 400px;
    }
    
    /* Actions column */
    #batch-import-table th:last-child,
    #batch-import-table td:last-child {
      width: 90px;
      text-align: center;
    }
    
    /* Input field styles for better usability */
    #batch-import-table input[type="text"],
    #batch-import-table input[type="number"],
    #batch-import-table select,
    #batch-import-table textarea {
      width: 100%;
      padding: 0.25rem 0.35rem;
      border: 1px solid transparent;
      background: transparent;
      color: #e0e0e0;
      font-size: 0.85rem;
      transition: all 0.2s;
      box-sizing: border-box;
    }
    
    /* Hover and focus states */
    #batch-import-table td:hover {
      background: rgba(74, 124, 89, 0.1);
      outline: 1px solid #4a7c59;
      outline-offset: -1px;
    }
    
    #batch-import-table input:focus,
    #batch-import-table select:focus,
    #batch-import-table textarea:focus {
      outline: none;
      border-color: #4a7c59;
      background: #2d2d2d;
      padding: 0.25rem 0.35rem;
    }
    
    /* Number inputs centered */
    #batch-import-table input[type="number"] {
      text-align: center;
    }
    
    /* Icon cell styles */
    #batch-import-table .item-icon {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      height: 30px;
      cursor: pointer;
      transition: transform 0.2s;
    }
    
    #batch-import-table .item-icon:hover {
      transform: scale(1.2);
    }
    
    /* Error states */
    #batch-import-table tr.has-error {
      background: rgba(220, 53, 69, 0.1);
    }
    
    #batch-import-table .error-cell {
      border: 1px solid #dc3545 !important;
      background: rgba(220, 53, 69, 0.2) !important;
    }
    
    /* Duplicate name warning */
    #batch-import-table tr.duplicate-name {
      background: rgba(255, 193, 7, 0.1);
    }
    
    #batch-import-table tr.duplicate-name td:nth-child(3) {
      border: 1px solid #ffc107;
      position: relative;
    }
    
    /* Make description field expandable */
    #batch-import-table textarea {
      min-height: 2rem;
      resize: vertical;
    }
    
    /* Responsive scrolling for the table container */
    #batch-import-step2 .table-container {
      overflow-x: auto;
      overflow-y: visible;
    }
    
    /* Sticky header for better usability */
    #batch-import-table thead {
      position: sticky;
      top: 0;
      background: #1a1a1a;
      z-index: 10;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    /* Compact mode for stat cells */
    #batch-import-table .batch-stat-col input {
      padding: 0.2rem !important;
      font-size: 0.8rem !important;
    }
    
    /* Cell highlighting for keyboard navigation */
    #batch-import-table td.batch-cell-focused {
      outline: 2px solid #FFD700;
      outline-offset: -2px;
      background: rgba(255, 215, 0, 0.1);
    }
    
    /* Row highlighting for keyboard navigation */
    #batch-import-table tr.batch-row-highlighted {
      background: rgba(74, 124, 89, 0.15) !important;
      box-shadow: inset 3px 0 0 #FFD700;
    }
    
    /* Ensure select dropdowns don't overflow */
    #batch-import-table select {
      padding-right: 20px;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23999' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 0.3rem center;
      background-size: 1em;
      appearance: none;
    }
    
    /* Keyboard navigation highlight */
    #batch-import-table td.batch-cell-focused {
      outline: 2px solid #FFD700 !important;
      outline-offset: -2px;
      background: rgba(255, 215, 0, 0.15) !important;
      box-shadow: inset 0 0 4px rgba(255, 215, 0, 0.3);
    }
    
    #batch-import-table td.batch-cell-focused input,
    #batch-import-table td.batch-cell-focused select,
    #batch-import-table td.batch-cell-focused textarea {
      background: #2d2d2d !important;
      border-color: #FFD700 !important;
    }
  </style>

  <!-- Batch Import Modal -->
  <div id="batch-import-modal" class="modal" style="display: none;">
    <div class="modal-content" style="width: 95%; max-width: 2400px; height: 95vh; display: flex; flex-direction: column;">
      <div class="modal-header">
        <h2>Batch Add Items</h2>
        <button class="close-btn" onclick="closeBatchImportModal()"></button>
      </div>
      
      <div class="modal-body" style="flex: 1; overflow-y: auto; padding: 0;">
        <!-- Step 1: Paste Items -->
        <div id="batch-import-step1" style="padding: 30px;">
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; height: 100%;">
            <!-- Left column: Input area -->
            <div style="display: flex; flex-direction: column;">
              <div style="background: #2a2a2a; border: 1px solid #444; border-radius: 8px; padding: 25px; flex: 1; display: flex; flex-direction: column;">
                <h3 style="margin-top: 0; color: #FFD700;">Step 1: Paste Item Data</h3>
                <p style="color: #999; margin-bottom: 20px;">Paste your item data below. Supports multiple formats.</p>
                
                <textarea 
                  id="batch-import-textarea" 
                  placeholder="Paste item data here...&#10;&#10;Simple list example:&#10;Ancient Sword&#10;Dragon Shield&#10;&#10;Table example:&#10;Name&#9;Type&#9;Slot&#9;STR&#9;Race&#9;Class&#10;Elven Blade&#9;weapon&#9;Primary&#9;5&#9;ELF HIE&#9;FTR PAL&#10;Mystic Orb&#9;misc&#9;&#9;0&#9;ALL&#9;ELE ENC NEC WIZ"
                  style="width: 100%; flex: 1; background: #1a1a1a; border: 1px solid #555; border-radius: 4px; color: #e0e0e0; padding: 15px; font-family: monospace; resize: none; min-height: 400px;"
                  oninput="updateBatchImportCount()"
                ></textarea>
                
                <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 20px;">
                  <div style="color: #999; font-size: 1.1rem;">
                    <span id="batch-import-count" style="color: #FFD700; font-weight: bold;">0</span> items detected
                  </div>
                  <div style="display: flex; gap: 15px;">
                    <div id="batch-import-actions" style="display: flex; gap: 15px;">
                      <button onclick="clearBatchImport()" class="secondary-btn" style="padding: 10px 20px;">Clear</button>
                      <button onclick="processBatchImport()" class="primary-btn" id="batch-import-process-btn" disabled style="padding: 10px 30px; font-size: 1.1rem;">
                        Process Items 
                      </button>
                    </div>
                    <div id="url-analysis-actions" style="display: none; gap: 15px;">
                      <button onclick="analyzeUrls()" class="primary-btn" style="padding: 10px 30px; font-size: 1.1rem;">
                        <span style="margin-right: 8px;"></span>
                        Analyze URLs
                      </button>
                      <button onclick="clearUrlAnalysis()" class="secondary-btn" style="padding: 10px 20px;">Clear</button>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <!-- Right column: Data Inspector -->
            <div id="batch-data-inspector" style="display: flex; flex-direction: column; gap: 20px;">
              <!-- Data Analysis -->
              <div style="background: #1f2937; border: 1px solid #374151; border-radius: 8px; padding: 20px; position: relative; overflow: hidden;">
                <div style="background: linear-gradient(135deg, #60a5fa 0%, #3b82f6 100%); position: absolute; top: 0; left: 0; right: 0; height: 3px;"></div>
                
                <h4 style="margin-top: 0; color: #60a5fa; font-size: 1.2rem; display: flex; align-items: center; gap: 10px;">
                  <span style="animation: pulse 2s infinite;"></span>
                  <span>Data Inspector</span>
                  <span id="inspector-live-indicator" style="display: none; margin-left: auto; font-size: 0.75rem; color: #10b981; animation: pulse 1s infinite;">
                    <span style="display: inline-block; width: 8px; height: 8px; background: #10b981; border-radius: 50%; margin-right: 5px;"></span>
                    LIVE
                  </span>
                  <span id="inspector-detection-mode" style="display: none; margin-left: 10px; font-size: 0.75rem; color: #FFD700; padding: 2px 8px; background: rgba(255, 215, 0, 0.1); border-radius: 12px;">
                     Structure-based Detection
                  </span>
                </h4>
                
                <div id="inspector-status" style="text-align: center; padding: 40px 20px; color: #9ca3af;">
                  <div id="inspector-status-icon" style="font-size: 2.5rem; margin-bottom: 10px; opacity: 0.3;"></div>
                  <p id="inspector-status-text" style="margin: 0;">Paste URLs to analyze</p>
                  <p id="inspector-status-subtext" style="margin: 5px 0 0 0; font-size: 0.9rem; opacity: 0.7;">The inspector will show what data will be fetched</p>
                </div>
                
                <div id="inspector-results" style="display: none;">
                  <!-- Summary Stats -->
                  <div id="inspector-summary" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 20px;">
                    <div style="background: #111827; border: 1px solid #1f2937; border-radius: 6px; padding: 12px; text-align: center;">
                      <div style="color: #9ca3af; font-size: 0.75rem; margin-bottom: 4px;">Total URLs</div>
                      <div id="inspector-total-urls" style="color: #60a5fa; font-size: 1.5rem; font-weight: bold;">0</div>
                    </div>
                    <div style="background: #111827; border: 1px solid #1f2937; border-radius: 6px; padding: 12px; text-align: center;">
                      <div style="color: #9ca3af; font-size: 0.75rem; margin-bottom: 4px;">NPCs</div>
                      <div id="inspector-npc-count" style="color: #a78bfa; font-size: 1.5rem; font-weight: bold;">0</div>
                    </div>
                    <div style="background: #111827; border: 1px solid #1f2937; border-radius: 6px; padding: 12px; text-align: center;">
                      <div style="color: #9ca3af; font-size: 0.75rem; margin-bottom: 4px;">Lists</div>
                      <div id="inspector-list-stat-count" style="color: #f59e0b; font-size: 1.5rem; font-weight: bold;">0</div>
                    </div>
                    <div style="background: #111827; border: 1px solid #1f2937; border-radius: 6px; padding: 12px; text-align: center;">
                      <div style="color: #9ca3af; font-size: 0.75rem; margin-bottom: 4px;">Est. Items</div>
                      <div id="inspector-estimated-items" style="color: #10b981; font-size: 1.5rem; font-weight: bold;">0</div>
                    </div>
                  </div>
                  
                  <!-- Hierarchical Tree View -->
                  <div id="inspector-tree-container" style="background: #111827; border: 1px solid #1f2937; border-radius: 6px; padding: 15px; max-height: 400px; overflow-y: auto;">
                    <div id="inspector-tree" style="font-family: monospace; font-size: 0.85rem;">
                      <!-- Tree structure will be rendered here -->
                    </div>
                  </div>
                  
                  <!-- Progress Bar -->
                  <div id="inspector-progress" style="display: none; margin-top: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                      <span id="inspector-progress-text" style="color: #9ca3af; font-size: 0.85rem;">Analyzing...</span>
                      <span id="inspector-progress-percent" style="color: #60a5fa; font-size: 0.85rem; font-weight: bold;">0%</span>
                    </div>
                    <div style="background: #1f2937; border-radius: 4px; height: 6px; overflow: hidden;">
                      <div id="inspector-progress-bar" style="background: linear-gradient(90deg, #3b82f6 0%, #60a5fa 100%); height: 100%; width: 0%; transition: width 0.3s ease;"></div>
                    </div>
                  </div>
                  
                  <!-- Actions -->
                  <div id="inspector-actions" style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #374151;">
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                      <div id="inspector-warnings" style="display: none;">
                        <!-- Warnings will appear here -->
                      </div>
                      <div id="inspector-hints" style="color: #9ca3af; font-size: 0.85rem;">
                        <!-- Hints will appear here -->
                      </div>
                      <div id="inspector-extract-btn-container" style="display: none; text-align: center; margin-top: 15px;">
                        <button id="inspector-extract-btn" onclick="extractFromInspector()" class="primary-btn" style="padding: 12px 30px; font-size: 1.1rem;" disabled>
                          <span style="margin-right: 8px;"></span>
                          <span id="inspector-extract-btn-text">Analyzing...</span>
                        </button>
                        <button id="inspector-exclude-cached-btn" onclick="excludeAllCachedItems()" class="secondary-btn" style="padding: 12px 30px; font-size: 1.1rem; margin-left: 15px;" title="Exclude all items that are already cached">
                          <span style="margin-right: 8px;"></span>
                          <span>Exclude Cached</span>
                        </button>
                        <button id="inspector-add-to-npc-btn" onclick="addItemsToNPC()" class="secondary-btn" style="display: none; padding: 12px 30px; font-size: 1.1rem; margin-left: 15px;" title="Add items to NPC loot list">
                          <span style="margin-right: 8px;"></span>
                          <span>Add to NPC</span>
                        </button>
                        <button id="inspector-retry-all-btn" onclick="retryAllFailedExtractions()" class="secondary-btn" style="display: none; padding: 12px 30px; font-size: 1.1rem; margin-left: 15px;">
                          <span style="margin-right: 8px;"></span>
                          <span>Retry All Failed</span>
                        </button>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- Format Detector -->
              <div id="format-detector" style="background: #1f2937; border: 1px solid #374151; border-radius: 8px; padding: 20px; display: none;">
                <h4 style="margin-top: 0; color: #60a5fa; font-size: 1.1rem;">Detected Format</h4>
                <div id="format-details" style="margin-top: 10px;">
                  <!-- Format details will be shown here -->
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Step 2: Edit Items -->
        <div id="batch-import-items-step2" style="display: none; height: 100%; flex-direction: column; padding: 30px;">
          <div style="background: #2a2a2a; border-bottom: 1px solid #444; padding: 15px 20px; flex-shrink: 0;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <div>
                <h3 style="margin: 0; color: #FFD700;">Step 2: Review and Edit Items</h3>
                <p style="margin: 5px 0 0 0; color: #999;">Review detected types and edit item properties. Click on any cell to edit.</p>
              </div>
              <div style="display: flex; gap: 10px; align-items: center;">
                <span style="color: #999;" id="batch-import-status">
                  <span id="batch-import-valid-count">0</span> valid items
                </span>
                <button onclick="backToBatchStep1()" class="secondary-btn"> Back</button>
                <button onclick="batchInsertItems()" class="primary-btn" id="batch-insert-btn">
                  <span style="margin-right: 5px;"></span>Insert All Items
                </button>
              </div>
            </div>
          </div>

          <!-- Batch Actions Bar -->
          <div style="background: #1f2937; border-bottom: 1px solid #374151; padding: 10px 20px; display: flex; gap: 10px; align-items: center; flex-shrink: 0;">
            <span style="color: #9ca3af;">Batch Actions:</span>
            <select id="batch-action-type" class="form-control" style="width: 150px;">
              <option value="">Select field...</option>
              <option value="item_type">Item Type</option>
              <option value="slot">Slot</option>
              <option value="size">Size</option>
              <option value="weight">Weight</option>
              <option value="skill">Skill</option>
              <option value="race">Race</option>
              <option value="class">Class</option>
              <optgroup label="Stats">
                <option value="str">STR</option>
                <option value="sta">STA</option>
                <option value="agi">AGI</option>
                <option value="dex">DEX</option>
                <option value="wis">WIS</option>
                <option value="int">INT</option>
                <option value="cha">CHA</option>
                <option value="ac">AC</option>
                <option value="health">HP</option>
                <option value="mana">MP</option>
                <option value="attack_speed">Attack Speed</option>
                <option value="damage">Damage</option>
                <option value="delay">Delay</option>
              </optgroup>
              <optgroup label="Resistances">
                <option value="resist_cold">Cold Resist</option>
                <option value="resist_corruption">Corruption Resist</option>
                <option value="resist_disease">Disease Resist</option>
                <option value="resist_electricity">Electricity Resist</option>
                <option value="resist_fire">Fire Resist</option>
                <option value="resist_magic">Magic Resist</option>
                <option value="resist_poison">Poison Resist</option>
              </optgroup>
            </select>
            <input type="text" id="batch-action-value" class="form-control" style="width: 150px;" placeholder="Value...">
            <button onclick="applyBatchAction()" class="secondary-btn">Apply to All</button>
            <button onclick="purgeUnchangedItems()" class="secondary-btn" style="margin-left: 10px;" title="Remove items that have no changes from existing database entries">
              <span style="margin-right: 5px;"></span>Purge Unchanged
            </button>
            <div style="margin-left: auto; display: flex; gap: 10px; align-items: center;">
              <label style="color: #9ca3af;">
                <input type="checkbox" id="batch-import-show-advanced" onchange="toggleBatchImportAdvanced()">
                Show Advanced Fields
              </label>
            </div>
          </div>

          <!-- Items Table Container -->
          <div style="flex: 1; overflow: auto; padding: 20px;">
            <div class="table-container" style="overflow-x: auto; overflow-y: visible;">
              <table class="admin-table" id="batch-import-table" style="width: 100%;">
                <thead style="position: sticky; top: 0; background: #1a1a1a; z-index: 10;">
                <tr>
                  <th style="width: 40px;">
                    <input type="checkbox" id="batch-import-select-all" onchange="toggleBatchImportSelectAll()">
                  </th>
                  <th style="width: 40px;">Icon</th>
                  <th style="width: 200px;">Name</th>
                  <th style="width: 100px;">Type</th>
                  <th style="width: 100px;">Slot</th>
                  <th style="width: 80px;">Size</th>
                  <th style="width: 80px;">Weight</th>
                  <th class="batch-stat-col" style="width: 50px;">STR</th>
                  <th class="batch-stat-col" style="width: 50px;">STA</th>
                  <th class="batch-stat-col" style="width: 50px;">AGI</th>
                  <th class="batch-stat-col" style="width: 50px;">DEX</th>
                  <th class="batch-stat-col" style="width: 50px;">WIS</th>
                  <th class="batch-stat-col" style="width: 50px;">INT</th>
                  <th class="batch-stat-col" style="width: 50px;">CHA</th>
                  <th class="batch-resist-col" style="width: 80px;">Resists</th>
                  <th class="batch-advanced-col" style="width: 50px; display: none;">AC</th>
                  <th class="batch-advanced-col" style="width: 50px; display: none;">HP</th>
                  <th class="batch-advanced-col" style="width: 50px; display: none;">MP</th>
                  <th class="batch-advanced-col" style="width: 60px; display: none;">AS</th>
                  <th class="batch-advanced-col" style="width: 60px; display: none;">DMG</th>
                  <th class="batch-advanced-col" style="width: 60px; display: none;">Delay</th>
                  <th class="batch-advanced-col" style="width: 100px; display: none;">Skill</th>
                  <th class="batch-advanced-col" style="width: 100px; display: none;">Race</th>
                  <th class="batch-advanced-col" style="width: 100px; display: none;">Class</th>
                  <th style="width: 200px;">Description</th>
                  <th style="width: 60px;">Actions</th>
                </tr>
              </thead>
              <tbody id="batch-import-tbody">
                <!-- Dynamically populated -->
              </tbody>
            </table>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Race/Class Selector Modal -->
  <div id="race-class-selector-modal" class="race-class-modal" style="display: none;">
    <div class="race-class-modal-content">
      <div class="race-class-modal-header">
        <h3 id="race-class-modal-title">Select Races</h3>
        <button class="race-class-modal-close" onclick="closeRaceClassModal()"></button>
      </div>
      
      <div class="race-class-modal-body">
        <div class="race-class-select-all" onclick="toggleAllRaceClass()">
          <input type="checkbox" id="race-class-select-all-checkbox">
          <label for="race-class-select-all-checkbox" id="race-class-select-all-label">Select All Races</label>
        </div>
        
        <div class="race-class-options" id="race-class-options">
          <!-- Options will be populated dynamically -->
        </div>
      </div>
      
      <div class="race-class-modal-footer">
        <div class="race-class-selection-count" id="race-class-selection-count">
          0 selected
        </div>
        <div class="race-class-modal-buttons">
          <button class="race-class-cancel-btn" onclick="closeRaceClassModal()">Cancel</button>
          <button class="race-class-apply-btn" onclick="applyRaceClassSelection()">Apply</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Inspector Context Menu -->
  <div id="inspector-context-menu" class="inspector-context-menu">
    <div class="context-menu-title" style="padding: 8px 12px; font-weight: bold; color: #9ca3af; font-size: 0.85rem; border-bottom: 1px solid #374151;"></div>
    <div class="inspector-context-menu-item" onclick="changeNodeType('item')">
      <span class="inspector-context-menu-icon"></span>
      <span>Mark as Item</span>
    </div>
    <div class="inspector-context-menu-item" onclick="changeNodeType('list')">
      <span class="inspector-context-menu-icon"></span>
      <span>Mark as List</span>
    </div>
    <div class="inspector-context-menu-item" onclick="changeNodeType('npc')">
      <span class="inspector-context-menu-icon"></span>
      <span>Mark as NPC</span>
    </div>
    <div class="inspector-context-menu-item" onclick="changeNodeType('unknown')">
      <span class="inspector-context-menu-icon"></span>
      <span>Mark as Unknown</span>
    </div>
    <div class="inspector-context-menu-separator"></div>
    <div class="inspector-context-menu-item" onclick="excludeSelectedNodes()">
      <span class="inspector-context-menu-icon"></span>
      <span>Exclude from Import</span>
    </div>
    <div class="inspector-context-menu-item" onclick="includeSelectedNodes()" id="include-nodes-option" style="display: none;">
      <span class="inspector-context-menu-icon"></span>
      <span>Include in Import</span>
    </div>
    <div class="inspector-context-menu-separator"></div>
    <div class="inspector-context-menu-item" onclick="inspectSelectedNodes()">
      <span class="inspector-context-menu-icon"></span>
      <span>Inspect in Browser</span>
    </div>
    <div class="inspector-context-menu-item" onclick="reverifyNode()">
      <span class="inspector-context-menu-icon"></span>
      <span>Re-verify URL</span>
    </div>
  </div>

  <!-- Proposal NPCs Modal -->
  <div id="proposal-npcs-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.8); z-index: 10000; align-items: center; justify-content: center;" onclick="if(event.target === this) closeProposalNPCsModal()">
    <div style="width: 90%; max-width: 700px; max-height: 80vh; background: #2d2d2d; border-radius: 8px; box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4); display: flex; flex-direction: column; position: relative;">
      <div style="padding: 1.5rem; border-bottom: 1px solid #444; background: #1a1a1a; border-radius: 8px 8px 0 0;">
        <h3 style="margin: 0; color: #FFD700; font-family: 'Cinzel', serif; font-size: 1.5rem;">Multi-Mob POI NPCs</h3>
        <button onclick="closeProposalNPCsModal()" style="position: absolute; top: 1.5rem; right: 1.5rem; background: #444; border: none; color: #fff; font-size: 1.25rem; cursor: pointer; width: 32px; height: 32px; border-radius: 4px; display: flex; align-items: center; justify-content: center; transition: all 0.2s;" onmouseover="this.style.background='#666'" onmouseout="this.style.background='#444'">&times;</button>
      </div>
      <div id="proposal-npcs-content" style="padding: 1.5rem; overflow-y: auto; flex: 1;">
        <!-- NPC list will be populated here -->
      </div>
    </div>
  </div>

</body>
</html>